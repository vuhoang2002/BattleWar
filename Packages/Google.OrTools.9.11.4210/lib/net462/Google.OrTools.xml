<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Google.OrTools</name>
    </assembly>
    <members>
        <member name="T:Google.OrTools.Algorithms.Int64Matrix.Int64MatrixEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.Algorithms.Int64Vector.Int64VectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.Bop.BopParametersReflection">
            <summary>Holder for reflection information generated from ortools/bop/bop_parameters.proto</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParametersReflection.Descriptor">
            <summary>File descriptor for ortools/bop/bop_parameters.proto</summary>
        </member>
        <member name="T:Google.OrTools.Bop.BopOptimizerMethod">
             <summary>
             Method used to optimize a solution in Bop.
            
             NEXT TAG: 16
             </summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopOptimizerMethod.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopOptimizerMethod.HasType">
            <summary>Gets whether the "type" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopOptimizerMethod.ClearType">
            <summary>Clears the value of the "type" field</summary>
        </member>
        <member name="T:Google.OrTools.Bop.BopOptimizerMethod.Types">
            <summary>Container for nested types declared in the BopOptimizerMethod message type.</summary>
        </member>
        <member name="T:Google.OrTools.Bop.BopSolverOptimizerSet">
            <summary>
            Set of optimizer methods to be run by an instance of the portfolio optimizer.
            Note that in the current implementation, all the methods specified in the
            repeated field methods will run on the same solver / thread.
            </summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopSolverOptimizerSet.MethodsFieldNumber">
            <summary>Field number for the "methods" field.</summary>
        </member>
        <member name="T:Google.OrTools.Bop.BopParameters">
             <summary>
             Contains the definitions for all the bop algorithm parameters and their
             default values.
            
             NEXT TAG: 42
             </summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.MaxTimeInSecondsFieldNumber">
            <summary>Field number for the "max_time_in_seconds" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.MaxTimeInSeconds">
            <summary>
            Maximum time allowed in seconds to solve a problem.
            The counter will starts as soon as Solve() is called.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasMaxTimeInSeconds">
            <summary>Gets whether the "max_time_in_seconds" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearMaxTimeInSeconds">
            <summary>Clears the value of the "max_time_in_seconds" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.MaxDeterministicTimeFieldNumber">
            <summary>Field number for the "max_deterministic_time" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.MaxDeterministicTime">
            <summary>
            Maximum time allowed in deterministic time to solve a problem.
            The deterministic time should be correlated with the real time used by the
            solver, the time unit being roughly the order of magnitude of a second.
            The counter will starts as soon as SetParameters() or SolveWithTimeLimit()
            is called.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasMaxDeterministicTime">
            <summary>Gets whether the "max_deterministic_time" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearMaxDeterministicTime">
            <summary>Clears the value of the "max_deterministic_time" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.LpMaxDeterministicTimeFieldNumber">
            <summary>Field number for the "lp_max_deterministic_time" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.LpMaxDeterministicTime">
            <summary>
            The max deterministic time given to the LP solver each time it is called.
            If this is not enough to solve the LP at hand, it will simply be called
            again later (and the solve will resume from where it stopped).
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasLpMaxDeterministicTime">
            <summary>Gets whether the "lp_max_deterministic_time" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearLpMaxDeterministicTime">
            <summary>Clears the value of the "lp_max_deterministic_time" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.MaxNumberOfConsecutiveFailingOptimizerCallsFieldNumber">
            <summary>Field number for the "max_number_of_consecutive_failing_optimizer_calls" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.MaxNumberOfConsecutiveFailingOptimizerCalls">
            <summary>
            Maximum number of consecutive optimizer calls without improving the
            current solution. If this number is reached, the search will be aborted.
            Note that this parameter only applies when an initial solution has been
            found or is provided. Also note that there is no limit to the number of
            calls, when the parameter is not set.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasMaxNumberOfConsecutiveFailingOptimizerCalls">
            <summary>Gets whether the "max_number_of_consecutive_failing_optimizer_calls" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearMaxNumberOfConsecutiveFailingOptimizerCalls">
            <summary>Clears the value of the "max_number_of_consecutive_failing_optimizer_calls" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.RelativeGapLimitFieldNumber">
            <summary>Field number for the "relative_gap_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.RelativeGapLimit">
            <summary>
            Limit used to stop the optimization as soon as the relative gap is smaller
            than the given value.
            The relative gap is defined as:
              abs(solution_cost - best_bound)
                   / max(abs(solution_cost), abs(best_bound)).
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasRelativeGapLimit">
            <summary>Gets whether the "relative_gap_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearRelativeGapLimit">
            <summary>Clears the value of the "relative_gap_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.MaxNumDecisionsInLsFieldNumber">
            <summary>Field number for the "max_num_decisions_in_ls" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.MaxNumDecisionsInLs">
            <summary>
            Maximum number of cascading decisions the solver might use to repair the
            current solution in the LS.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasMaxNumDecisionsInLs">
            <summary>Gets whether the "max_num_decisions_in_ls" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearMaxNumDecisionsInLs">
            <summary>Clears the value of the "max_num_decisions_in_ls" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.MaxNumBrokenConstraintsInLsFieldNumber">
            <summary>Field number for the "max_num_broken_constraints_in_ls" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.MaxNumBrokenConstraintsInLs">
            <summary>
            Abort the LS search tree as soon as strictly more than this number of
            constraints are broken. The default is a large value which basically
            disable this heuristic.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasMaxNumBrokenConstraintsInLs">
            <summary>Gets whether the "max_num_broken_constraints_in_ls" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearMaxNumBrokenConstraintsInLs">
            <summary>Clears the value of the "max_num_broken_constraints_in_ls" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.LogSearchProgressFieldNumber">
            <summary>Field number for the "log_search_progress" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.LogSearchProgress">
            <summary>
            Whether the solver should log the search progress to LOG(INFO).
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasLogSearchProgress">
            <summary>Gets whether the "log_search_progress" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearLogSearchProgress">
            <summary>Clears the value of the "log_search_progress" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.ComputeEstimatedImpactFieldNumber">
            <summary>Field number for the "compute_estimated_impact" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.ComputeEstimatedImpact">
            <summary>
            Compute estimated impact at each iteration when true; only once when false.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasComputeEstimatedImpact">
            <summary>Gets whether the "compute_estimated_impact" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearComputeEstimatedImpact">
            <summary>Clears the value of the "compute_estimated_impact" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.PruneSearchTreeFieldNumber">
            <summary>Field number for the "prune_search_tree" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.PruneSearchTree">
            <summary>
            Avoid exploring both branches (b, a, ...) and (a, b, ...).
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasPruneSearchTree">
            <summary>Gets whether the "prune_search_tree" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearPruneSearchTree">
            <summary>Clears the value of the "prune_search_tree" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.SortConstraintsByNumTermsFieldNumber">
            <summary>Field number for the "sort_constraints_by_num_terms" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.SortConstraintsByNumTerms">
            <summary>
            Sort constraints by increasing total number of terms instead of number of
            contributing terms.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasSortConstraintsByNumTerms">
            <summary>Gets whether the "sort_constraints_by_num_terms" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearSortConstraintsByNumTerms">
            <summary>Clears the value of the "sort_constraints_by_num_terms" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.UseRandomLnsFieldNumber">
            <summary>Field number for the "use_random_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.UseRandomLns">
            <summary>
            Use the random Large Neighborhood Search instead of the exhaustive one.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasUseRandomLns">
            <summary>Gets whether the "use_random_lns" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearUseRandomLns">
            <summary>Clears the value of the "use_random_lns" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.RandomSeedFieldNumber">
            <summary>Field number for the "random_seed" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.RandomSeed">
             <summary>
             The seed used to initialize the random generator.
            
             TODO(user): Some of our client test fail depending on this value! we need
             to fix them and ideally randomize our behavior from on test to the next so
             that this doesn't happen in the future.
             </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasRandomSeed">
            <summary>Gets whether the "random_seed" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearRandomSeed">
            <summary>Clears the value of the "random_seed" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.NumRelaxedVarsFieldNumber">
            <summary>Field number for the "num_relaxed_vars" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.NumRelaxedVars">
            <summary>
            Number of variables to relax in the exhaustive Large Neighborhood Search.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasNumRelaxedVars">
            <summary>Gets whether the "num_relaxed_vars" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearNumRelaxedVars">
            <summary>Clears the value of the "num_relaxed_vars" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.MaxNumberOfConflictsInRandomLnsFieldNumber">
            <summary>Field number for the "max_number_of_conflicts_in_random_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.MaxNumberOfConflictsInRandomLns">
            <summary>
            The number of conflicts the SAT solver has to solve a random LNS
            subproblem.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasMaxNumberOfConflictsInRandomLns">
            <summary>Gets whether the "max_number_of_conflicts_in_random_lns" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearMaxNumberOfConflictsInRandomLns">
            <summary>Clears the value of the "max_number_of_conflicts_in_random_lns" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.NumRandomLnsTriesFieldNumber">
            <summary>Field number for the "num_random_lns_tries" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.NumRandomLnsTries">
            <summary>
            Number of tries in the random lns.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasNumRandomLnsTries">
            <summary>Gets whether the "num_random_lns_tries" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearNumRandomLnsTries">
            <summary>Clears the value of the "num_random_lns_tries" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.MaxNumberOfBacktracksInLsFieldNumber">
            <summary>Field number for the "max_number_of_backtracks_in_ls" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.MaxNumberOfBacktracksInLs">
            <summary>
            Maximum number of backtracks times the number of variables in Local Search,
            ie. max num backtracks == max_number_of_backtracks_in_ls / num variables.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasMaxNumberOfBacktracksInLs">
            <summary>Gets whether the "max_number_of_backtracks_in_ls" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearMaxNumberOfBacktracksInLs">
            <summary>Clears the value of the "max_number_of_backtracks_in_ls" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.UseLpLnsFieldNumber">
            <summary>Field number for the "use_lp_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.UseLpLns">
            <summary>
            Use Large Neighborhood Search based on the LP relaxation.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasUseLpLns">
            <summary>Gets whether the "use_lp_lns" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearUseLpLns">
            <summary>Clears the value of the "use_lp_lns" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.UseSatToChooseLnsNeighbourhoodFieldNumber">
            <summary>Field number for the "use_sat_to_choose_lns_neighbourhood" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.UseSatToChooseLnsNeighbourhood">
            <summary>
            Whether we use sat propagation to choose the lns neighbourhood.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasUseSatToChooseLnsNeighbourhood">
            <summary>Gets whether the "use_sat_to_choose_lns_neighbourhood" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearUseSatToChooseLnsNeighbourhood">
            <summary>Clears the value of the "use_sat_to_choose_lns_neighbourhood" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.MaxNumberOfConflictsForQuickCheckFieldNumber">
            <summary>Field number for the "max_number_of_conflicts_for_quick_check" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.MaxNumberOfConflictsForQuickCheck">
            <summary>
            The number of conflicts the SAT solver has to solve a random LNS
            subproblem for the quick check of infeasibility.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasMaxNumberOfConflictsForQuickCheck">
            <summary>Gets whether the "max_number_of_conflicts_for_quick_check" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearMaxNumberOfConflictsForQuickCheck">
            <summary>Clears the value of the "max_number_of_conflicts_for_quick_check" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.UseSymmetryFieldNumber">
            <summary>Field number for the "use_symmetry" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.UseSymmetry">
             <summary>
             If true, find and exploit the eventual symmetries of the problem.
            
             TODO(user): turn this on by default once the symmetry finder becomes fast
             enough to be negligeable for most problem. Or at least support a time
             limit.
             </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasUseSymmetry">
            <summary>Gets whether the "use_symmetry" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearUseSymmetry">
            <summary>Clears the value of the "use_symmetry" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.ExploitSymmetryInSatFirstSolutionFieldNumber">
            <summary>Field number for the "exploit_symmetry_in_sat_first_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.ExploitSymmetryInSatFirstSolution">
            <summary>
            If true, find and exploit symmetries in proving satisfiability in the first
            problem.
            This feature is experimental. On some problems, computing symmetries may
            run forever. You may also run into unforseen problems as this feature was
            not extensively tested.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasExploitSymmetryInSatFirstSolution">
            <summary>Gets whether the "exploit_symmetry_in_sat_first_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearExploitSymmetryInSatFirstSolution">
            <summary>Clears the value of the "exploit_symmetry_in_sat_first_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.MaxNumberOfConflictsInRandomSolutionGenerationFieldNumber">
            <summary>Field number for the "max_number_of_conflicts_in_random_solution_generation" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.MaxNumberOfConflictsInRandomSolutionGeneration">
            <summary>
            The number of conflicts the SAT solver has to generate a random solution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasMaxNumberOfConflictsInRandomSolutionGeneration">
            <summary>Gets whether the "max_number_of_conflicts_in_random_solution_generation" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearMaxNumberOfConflictsInRandomSolutionGeneration">
            <summary>Clears the value of the "max_number_of_conflicts_in_random_solution_generation" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.MaxNumberOfExploredAssignmentsPerTryInLsFieldNumber">
            <summary>Field number for the "max_number_of_explored_assignments_per_try_in_ls" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.MaxNumberOfExploredAssignmentsPerTryInLs">
            <summary>
            The maximum number of assignments the Local Search iterates on during one
            try. Note that if the Local Search is called again on the same solution
            it will not restart from scratch but will iterate on the next
            max_number_of_explored_assignments_per_try_in_ls assignments.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasMaxNumberOfExploredAssignmentsPerTryInLs">
            <summary>Gets whether the "max_number_of_explored_assignments_per_try_in_ls" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearMaxNumberOfExploredAssignmentsPerTryInLs">
            <summary>Clears the value of the "max_number_of_explored_assignments_per_try_in_ls" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.UseTranspositionTableInLsFieldNumber">
            <summary>Field number for the "use_transposition_table_in_ls" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.UseTranspositionTableInLs">
            <summary>
            Whether we use an hash set during the LS to avoid exploring more than once
            the "same" state. Note that because the underlying SAT solver may learn
            information in the middle of the LS, this may make the LS slightly less
            "complete", but it should be faster.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasUseTranspositionTableInLs">
            <summary>Gets whether the "use_transposition_table_in_ls" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearUseTranspositionTableInLs">
            <summary>Clears the value of the "use_transposition_table_in_ls" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.UsePotentialOneFlipRepairsInLsFieldNumber">
            <summary>Field number for the "use_potential_one_flip_repairs_in_ls" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.UsePotentialOneFlipRepairsInLs">
            <summary>
            Whether we keep a list of variable that can potentially repair in one flip
            all the current infeasible constraints (such variable must at least appear
            in all the infeasible constraints for this to happen).
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasUsePotentialOneFlipRepairsInLs">
            <summary>Gets whether the "use_potential_one_flip_repairs_in_ls" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearUsePotentialOneFlipRepairsInLs">
            <summary>Clears the value of the "use_potential_one_flip_repairs_in_ls" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.UseLearnedBinaryClausesInLpFieldNumber">
            <summary>Field number for the "use_learned_binary_clauses_in_lp" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.UseLearnedBinaryClausesInLp">
            <summary>
            Whether we use the learned binary clauses in the Linear Relaxation.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasUseLearnedBinaryClausesInLp">
            <summary>Gets whether the "use_learned_binary_clauses_in_lp" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearUseLearnedBinaryClausesInLp">
            <summary>Clears the value of the "use_learned_binary_clauses_in_lp" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.NumberOfSolversFieldNumber">
            <summary>Field number for the "number_of_solvers" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.NumberOfSolvers">
            <summary>
            The number of solvers used to run Bop. Note that one thread will be created
            per solver. The type of communication between solvers is specified by the
            synchronization_type parameter.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasNumberOfSolvers">
            <summary>Gets whether the "number_of_solvers" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearNumberOfSolvers">
            <summary>Clears the value of the "number_of_solvers" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.SynchronizationTypeFieldNumber">
            <summary>Field number for the "synchronization_type" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasSynchronizationType">
            <summary>Gets whether the "synchronization_type" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearSynchronizationType">
            <summary>Clears the value of the "synchronization_type" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.SolverOptimizerSetsFieldNumber">
            <summary>Field number for the "solver_optimizer_sets" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.SolverOptimizerSets">
            <summary>
            List of set of optimizers to be run by the solvers.
            Note that the i_th solver will run the
            min(i, solver_optimizer_sets_size())_th optimizer set.
            The default is defined by default_solver_optimizer_sets (only one set).
            </summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.DefaultSolverOptimizerSetsFieldNumber">
            <summary>Field number for the "default_solver_optimizer_sets" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasDefaultSolverOptimizerSets">
            <summary>Gets whether the "default_solver_optimizer_sets" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearDefaultSolverOptimizerSets">
            <summary>Clears the value of the "default_solver_optimizer_sets" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.UseLpStrongBranchingFieldNumber">
            <summary>Field number for the "use_lp_strong_branching" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.UseLpStrongBranching">
            <summary>
            Use strong branching in the linear relaxation optimizer.
            The strong branching is a what-if analysis on each variable v, i.e.
            compute the best bound when v is assigned to true, compute the best bound
            when v is assigned to false, and then use those best bounds to improve the
            overall best bound.
            This is useful to improve the best_bound, but also to fix some variables
            during search.
            Note that using probing might be time consuming as it runs the LP solver
            2 * num_variables times.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasUseLpStrongBranching">
            <summary>Gets whether the "use_lp_strong_branching" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearUseLpStrongBranching">
            <summary>Clears the value of the "use_lp_strong_branching" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.DecomposerNumVariablesThresholdFieldNumber">
            <summary>Field number for the "decomposer_num_variables_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.DecomposerNumVariablesThreshold">
            <summary>
            Only try to decompose the problem when the number of variables is greater
            than the threshold.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasDecomposerNumVariablesThreshold">
            <summary>Gets whether the "decomposer_num_variables_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearDecomposerNumVariablesThreshold">
            <summary>Clears the value of the "decomposer_num_variables_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.NumBopSolversUsedByDecompositionFieldNumber">
            <summary>Field number for the "num_bop_solvers_used_by_decomposition" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.NumBopSolversUsedByDecomposition">
            <summary>
            The number of BopSolver created (thread pool workers) used by the integral
            solver to solve a decomposed problem.
            TODO(user): Merge this with the number_of_solvers parameter.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasNumBopSolversUsedByDecomposition">
            <summary>Gets whether the "num_bop_solvers_used_by_decomposition" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearNumBopSolversUsedByDecomposition">
            <summary>Clears the value of the "num_bop_solvers_used_by_decomposition" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.DecomposedProblemMinTimeInSecondsFieldNumber">
            <summary>Field number for the "decomposed_problem_min_time_in_seconds" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.DecomposedProblemMinTimeInSeconds">
            <summary>
            HACK. To avoid spending too little time on small problems, spend at least
            this time solving each of the decomposed sub-problem. This only make sense
            if num_bop_solvers_used_by_decomposition is greater than 1 so that the
            overhead can be "absorbed" by the other threads.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasDecomposedProblemMinTimeInSeconds">
            <summary>Gets whether the "decomposed_problem_min_time_in_seconds" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearDecomposedProblemMinTimeInSeconds">
            <summary>Clears the value of the "decomposed_problem_min_time_in_seconds" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.GuidedSatConflictsChunkFieldNumber">
            <summary>Field number for the "guided_sat_conflicts_chunk" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.GuidedSatConflictsChunk">
            <summary>
            The first solutions based on guided SAT will work in chunk of that many
            conflicts at the time. This allows to simulate parallelism between the
            different guiding strategy on a single core.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasGuidedSatConflictsChunk">
            <summary>Gets whether the "guided_sat_conflicts_chunk" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearGuidedSatConflictsChunk">
            <summary>Clears the value of the "guided_sat_conflicts_chunk" field</summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.MaxLpSolveForFeasibilityProblemsFieldNumber">
            <summary>Field number for the "max_lp_solve_for_feasibility_problems" field.</summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.MaxLpSolveForFeasibilityProblems">
            <summary>
            The maximum number of time the LP solver will run to feasibility for pure
            feasibility problems (with a constant-valued objective function). Set this
            to a small value, e.g., 1, if fractional solutions offer useful guidance to
            other solvers in the portfolio. A negative value means no limit.
            </summary>
        </member>
        <member name="P:Google.OrTools.Bop.BopParameters.HasMaxLpSolveForFeasibilityProblems">
            <summary>Gets whether the "max_lp_solve_for_feasibility_problems" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Bop.BopParameters.ClearMaxLpSolveForFeasibilityProblems">
            <summary>Clears the value of the "max_lp_solve_for_feasibility_problems" field</summary>
        </member>
        <member name="T:Google.OrTools.Bop.BopParameters.Types">
            <summary>Container for nested types declared in the BopParameters message type.</summary>
        </member>
        <member name="T:Google.OrTools.Bop.BopParameters.Types.ThreadSynchronizationType">
            <summary>
            Defines how the different solvers are synchronized during the search.
            Note that the synchronization (if any) occurs before each call to an
            optimizer (the smallest granularity of the solver in a parallel context).
            </summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.Types.ThreadSynchronizationType.NoSynchronization">
            <summary>
            No synchronization. The solvers run independently until the time limit
            is reached; Then learned information from each solver are aggregated.
            The final solution is the best of all found solutions.
            Pros: - No need to wait for another solver to complete its task,
                  - Adding a new solver always improves the final solution (In the
                    current implementation it still depends on the machine load and
                    the time limit).
            Cons: - No learning between solvers.
            </summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.Types.ThreadSynchronizationType.SynchronizeAll">
            <summary>
            Synchronize all solvers. Each solver waits for all other solvers to
            complete the previous optimizer run, before running again.
            The final solution is the best of all found solutions.
            Pros: - Full learning between solvers.
            Cons: - A lot of waiting time when solvers don't run at the exact same
                    speed,
                  - The quality of the final solution depends on the number of
                    solvers, adding one more solver might lead to poorer results
                    because the search goes on a different path.
            </summary>
        </member>
        <member name="F:Google.OrTools.Bop.BopParameters.Types.ThreadSynchronizationType.SynchronizeOnRight">
            <summary>
            Solver i synchronizes with solvers 0..i-1.
            This is a good tradeoff between NO_SYNCHRONIZATION and SYNCHRONIZE_ALL:
            communication while keeping a relative determinism on the result even
            when the number of solvers increases.
            The final solution is the best of all found solutions.
            Pros: - Solver i learns from i different solvers,
                  - Adding a new solver always improves the final solution (In the
                    current implementation it still depends on the machine load and
                    the time limit).
            Cons: - No full learning,
                  - Some solvers need to wait for synchronization.
            </summary>
        </member>
        <member name="T:Google.OrTools.Glop.ParametersReflection">
            <summary>Holder for reflection information generated from ortools/glop/parameters.proto</summary>
        </member>
        <member name="P:Google.OrTools.Glop.ParametersReflection.Descriptor">
            <summary>File descriptor for ortools/glop/parameters.proto</summary>
        </member>
        <member name="T:Google.OrTools.Glop.GlopParameters">
            <summary>
            next id = 72
            </summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.ScalingMethodFieldNumber">
            <summary>Field number for the "scaling_method" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasScalingMethod">
            <summary>Gets whether the "scaling_method" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearScalingMethod">
            <summary>Clears the value of the "scaling_method" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.FeasibilityRuleFieldNumber">
            <summary>Field number for the "feasibility_rule" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.FeasibilityRule">
            <summary>
            PricingRule to use during the feasibility phase.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasFeasibilityRule">
            <summary>Gets whether the "feasibility_rule" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearFeasibilityRule">
            <summary>Clears the value of the "feasibility_rule" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.OptimizationRuleFieldNumber">
            <summary>Field number for the "optimization_rule" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.OptimizationRule">
            <summary>
            PricingRule to use during the optimization phase.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasOptimizationRule">
            <summary>Gets whether the "optimization_rule" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearOptimizationRule">
            <summary>Clears the value of the "optimization_rule" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.RefactorizationThresholdFieldNumber">
            <summary>Field number for the "refactorization_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.RefactorizationThreshold">
            <summary>
            We estimate the factorization accuracy of B during each pivot by using
            the fact that we can compute the pivot coefficient in two ways:
            - From direction[leaving_row].
            - From update_row[entering_column].
            If the two values have a relative difference above this threshold, we
            trigger a refactorization.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasRefactorizationThreshold">
            <summary>Gets whether the "refactorization_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearRefactorizationThreshold">
            <summary>Clears the value of the "refactorization_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.RecomputeReducedCostsThresholdFieldNumber">
            <summary>Field number for the "recompute_reduced_costs_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.RecomputeReducedCostsThreshold">
            <summary>
            We estimate the accuracy of the iteratively computed reduced costs. If
            it falls below this threshold, we reinitialize them from scratch. Note
            that such an operation is pretty fast, so we can use a low threshold.
            It is important to have a good accuracy here (better than the
            dual_feasibility_tolerance below) to be sure of the sign of such a cost.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasRecomputeReducedCostsThreshold">
            <summary>Gets whether the "recompute_reduced_costs_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearRecomputeReducedCostsThreshold">
            <summary>Clears the value of the "recompute_reduced_costs_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.RecomputeEdgesNormThresholdFieldNumber">
            <summary>Field number for the "recompute_edges_norm_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.RecomputeEdgesNormThreshold">
            <summary>
            Note that the threshold is a relative error on the actual norm (not the
            squared one) and that edge norms are always greater than 1. Recomputing
            norms is a really expensive operation and a large threshold is ok since
            this doesn't impact directly the solution but just the entering variable
            choice.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasRecomputeEdgesNormThreshold">
            <summary>Gets whether the "recompute_edges_norm_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearRecomputeEdgesNormThreshold">
            <summary>Clears the value of the "recompute_edges_norm_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.PrimalFeasibilityToleranceFieldNumber">
            <summary>Field number for the "primal_feasibility_tolerance" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.PrimalFeasibilityTolerance">
             <summary>
             This tolerance indicates by how much we allow the variable values to go out
             of bounds and still consider the current solution primal-feasible. We also
             use the same tolerance for the error A.x - b. Note that the two errors are
             closely related if A is scaled in such a way that the greatest coefficient
             magnitude on each column is 1.0.
            
             This is also simply called feasibility tolerance in other solvers.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasPrimalFeasibilityTolerance">
            <summary>Gets whether the "primal_feasibility_tolerance" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearPrimalFeasibilityTolerance">
            <summary>Clears the value of the "primal_feasibility_tolerance" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.DualFeasibilityToleranceFieldNumber">
            <summary>Field number for the "dual_feasibility_tolerance" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.DualFeasibilityTolerance">
             <summary>
             Variables whose reduced costs have an absolute value smaller than this
             tolerance are not considered as entering candidates. That is they do not
             take part in deciding whether a solution is dual-feasible or not.
            
             Note that this value can temporarily increase during the execution of the
             algorithm if the estimated precision of the reduced costs is higher than
             this tolerance. Note also that we scale the costs (in the presolve step) so
             that the cost magnitude range contains one.
            
             This is also known as the optimality tolerance in other solvers.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasDualFeasibilityTolerance">
            <summary>Gets whether the "dual_feasibility_tolerance" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearDualFeasibilityTolerance">
            <summary>Clears the value of the "dual_feasibility_tolerance" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.RatioTestZeroThresholdFieldNumber">
            <summary>Field number for the "ratio_test_zero_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.RatioTestZeroThreshold">
             <summary>
             During the primal simplex (resp. dual simplex), the coefficients of the
             direction (resp. update row) with a magnitude lower than this threshold are
             not considered during the ratio test. This tolerance is related to the
             precision at which a Solve() involving the basis matrix can be performed.
            
             TODO(user): Automatically increase it when we detect that the precision
             of the Solve() is worse than this.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasRatioTestZeroThreshold">
            <summary>Gets whether the "ratio_test_zero_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearRatioTestZeroThreshold">
            <summary>Clears the value of the "ratio_test_zero_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.HarrisToleranceRatioFieldNumber">
            <summary>Field number for the "harris_tolerance_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HarrisToleranceRatio">
             <summary>
             This impacts the ratio test and indicates by how much we allow a basic
             variable value that we move to go out of bounds. The value should be in
             [0.0, 1.0) and should be interpreted as a ratio of the
             primal_feasibility_tolerance. Setting this to 0.0 basically disables the
             Harris ratio test while setting this too close to 1.0 will make it
             difficult to keep the variable values inside their bounds modulo the
             primal_feasibility_tolerance.
            
             Note that the same comment applies to the dual simplex ratio test. There,
             we allow the reduced costs to be of an infeasible sign by as much as this
             ratio times the dual_feasibility_tolerance.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasHarrisToleranceRatio">
            <summary>Gets whether the "harris_tolerance_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearHarrisToleranceRatio">
            <summary>Clears the value of the "harris_tolerance_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.SmallPivotThresholdFieldNumber">
            <summary>Field number for the "small_pivot_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.SmallPivotThreshold">
            <summary>
            When we choose the leaving variable, we want to avoid small pivot because
            they are the less precise and may cause numerical instabilities. For a
            pivot under this threshold times the infinity norm of the direction, we try
            various countermeasures in order to avoid using it.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasSmallPivotThreshold">
            <summary>Gets whether the "small_pivot_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearSmallPivotThreshold">
            <summary>Clears the value of the "small_pivot_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.MinimumAcceptablePivotFieldNumber">
            <summary>Field number for the "minimum_acceptable_pivot" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.MinimumAcceptablePivot">
            <summary>
            We never follow a basis change with a pivot under this threshold.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasMinimumAcceptablePivot">
            <summary>Gets whether the "minimum_acceptable_pivot" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearMinimumAcceptablePivot">
            <summary>Clears the value of the "minimum_acceptable_pivot" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.DropToleranceFieldNumber">
            <summary>Field number for the "drop_tolerance" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.DropTolerance">
            <summary>
            In order to increase the sparsity of the manipulated vectors, floating
            point values with a magnitude smaller than this parameter are set to zero
            (only in some places). This parameter should be positive or zero.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasDropTolerance">
            <summary>Gets whether the "drop_tolerance" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearDropTolerance">
            <summary>Clears the value of the "drop_tolerance" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.UseScalingFieldNumber">
            <summary>Field number for the "use_scaling" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.UseScaling">
            <summary>
            Whether or not we scale the matrix A so that the maximum coefficient on
            each line and each column is 1.0.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasUseScaling">
            <summary>Gets whether the "use_scaling" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearUseScaling">
            <summary>Clears the value of the "use_scaling" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.CostScalingFieldNumber">
            <summary>Field number for the "cost_scaling" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasCostScaling">
            <summary>Gets whether the "cost_scaling" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearCostScaling">
            <summary>Clears the value of the "cost_scaling" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.InitialBasisFieldNumber">
            <summary>Field number for the "initial_basis" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.InitialBasis">
            <summary>
            What heuristic is used to try to replace the fixed slack columns in the
            initial basis of the primal simplex.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasInitialBasis">
            <summary>Gets whether the "initial_basis" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearInitialBasis">
            <summary>Clears the value of the "initial_basis" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.UseTransposedMatrixFieldNumber">
            <summary>Field number for the "use_transposed_matrix" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.UseTransposedMatrix">
            <summary>
            Whether or not we keep a transposed version of the matrix A to speed-up the
            pricing at the cost of extra memory and the initial tranposition
            computation.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasUseTransposedMatrix">
            <summary>Gets whether the "use_transposed_matrix" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearUseTransposedMatrix">
            <summary>Clears the value of the "use_transposed_matrix" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.BasisRefactorizationPeriodFieldNumber">
            <summary>Field number for the "basis_refactorization_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.BasisRefactorizationPeriod">
            <summary>
            Number of iterations between two basis refactorizations. Note that various
            conditions in the algorithm may trigger a refactorization before this
            period is reached. Set this to 0 if you want to refactorize at each step.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasBasisRefactorizationPeriod">
            <summary>Gets whether the "basis_refactorization_period" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearBasisRefactorizationPeriod">
            <summary>Clears the value of the "basis_refactorization_period" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.DynamicallyAdjustRefactorizationPeriodFieldNumber">
            <summary>Field number for the "dynamically_adjust_refactorization_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.DynamicallyAdjustRefactorizationPeriod">
            <summary>
            If this is true, then basis_refactorization_period becomes a lower bound on
            the number of iterations between two refactorization (provided there is no
            numerical accuracy issues). Depending on the estimated time to refactorize
            vs the extra time spend in each solves because of the LU update, we try to
            balance the two times.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasDynamicallyAdjustRefactorizationPeriod">
            <summary>Gets whether the "dynamically_adjust_refactorization_period" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearDynamicallyAdjustRefactorizationPeriod">
            <summary>Clears the value of the "dynamically_adjust_refactorization_period" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.SolveDualProblemFieldNumber">
            <summary>Field number for the "solve_dual_problem" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.SolveDualProblem">
            <summary>
            Whether or not we solve the dual of the given problem.
            With a value of auto, the algorithm decide which approach is probably the
            fastest depending on the problem dimensions (see dualizer_threshold).
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasSolveDualProblem">
            <summary>Gets whether the "solve_dual_problem" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearSolveDualProblem">
            <summary>Clears the value of the "solve_dual_problem" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.DualizerThresholdFieldNumber">
            <summary>Field number for the "dualizer_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.DualizerThreshold">
            <summary>
            When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
            of constraints of the problem is more than this threshold times the number
            of variables.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasDualizerThreshold">
            <summary>Gets whether the "dualizer_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearDualizerThreshold">
            <summary>Clears the value of the "dualizer_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.SolutionFeasibilityToleranceFieldNumber">
            <summary>Field number for the "solution_feasibility_tolerance" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.SolutionFeasibilityTolerance">
             <summary>
             When the problem status is OPTIMAL, we check the optimality using this
             relative tolerance and change the status to IMPRECISE if an issue is
             detected.
            
             The tolerance is "relative" in the sense that our thresholds are:
             - tolerance * max(1.0, abs(bound)) for crossing a given bound.
             - tolerance * max(1.0, abs(cost)) for an infeasible reduced cost.
             - tolerance for an infeasible dual value.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasSolutionFeasibilityTolerance">
            <summary>Gets whether the "solution_feasibility_tolerance" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearSolutionFeasibilityTolerance">
            <summary>Clears the value of the "solution_feasibility_tolerance" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.ProvideStrongOptimalGuaranteeFieldNumber">
            <summary>Field number for the "provide_strong_optimal_guarantee" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.ProvideStrongOptimalGuarantee">
             <summary>
             If true, then when the solver returns a solution with an OPTIMAL status,
             we can guarantee that:
             - The primal variable are in their bounds.
             - The dual variable are in their bounds.
             - If we modify each component of the right-hand side a bit and each
               component of the objective function a bit, then the pair (primal values,
               dual values) is an EXACT optimal solution of the perturbed problem.
             - The modifications above are smaller than the associated tolerances as
               defined in the comment for solution_feasibility_tolerance (*).
            
             (*): This is the only place where the guarantee is not tight since we
             compute the upper bounds with scalar product of the primal/dual
             solution and the initial problem coefficients with only double precision.
            
             Note that whether or not this option is true, we still check the
             primal/dual infeasibility and objective gap. However if it is false, we
             don't move the primal/dual values within their bounds and leave them
             untouched.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasProvideStrongOptimalGuarantee">
            <summary>Gets whether the "provide_strong_optimal_guarantee" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearProvideStrongOptimalGuarantee">
            <summary>Clears the value of the "provide_strong_optimal_guarantee" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.ChangeStatusToImpreciseFieldNumber">
            <summary>Field number for the "change_status_to_imprecise" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.ChangeStatusToImprecise">
            <summary>
            If true, the internal API will change the return status to imprecise if the
            solution does not respect the internal tolerances.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasChangeStatusToImprecise">
            <summary>Gets whether the "change_status_to_imprecise" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearChangeStatusToImprecise">
            <summary>Clears the value of the "change_status_to_imprecise" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.MaxNumberOfReoptimizationsFieldNumber">
            <summary>Field number for the "max_number_of_reoptimizations" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.MaxNumberOfReoptimizations">
            <summary>
            When the solution of phase II is imprecise, we re-run the phase II with the
            opposite algorithm from that imprecise solution (i.e., if primal or dual
            simplex was used, we use dual or primal simplex, respectively). We repeat
            such re-optimization until the solution is precise, or we hit this limit.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasMaxNumberOfReoptimizations">
            <summary>Gets whether the "max_number_of_reoptimizations" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearMaxNumberOfReoptimizations">
            <summary>Clears the value of the "max_number_of_reoptimizations" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.LuFactorizationPivotThresholdFieldNumber">
            <summary>Field number for the "lu_factorization_pivot_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.LuFactorizationPivotThreshold">
            <summary>
            Threshold for LU-factorization: for stability reasons, the magnitude of the
            chosen pivot at a given step is guaranteed to be greater than this
            threshold times the maximum magnitude of all the possible pivot choices in
            the same column. The value must be in [0,1].
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasLuFactorizationPivotThreshold">
            <summary>Gets whether the "lu_factorization_pivot_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearLuFactorizationPivotThreshold">
            <summary>Clears the value of the "lu_factorization_pivot_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.MaxTimeInSecondsFieldNumber">
            <summary>Field number for the "max_time_in_seconds" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.MaxTimeInSeconds">
            <summary>
            Maximum time allowed in seconds to solve a problem.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasMaxTimeInSeconds">
            <summary>Gets whether the "max_time_in_seconds" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearMaxTimeInSeconds">
            <summary>Clears the value of the "max_time_in_seconds" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.MaxDeterministicTimeFieldNumber">
            <summary>Field number for the "max_deterministic_time" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.MaxDeterministicTime">
             <summary>
             Maximum deterministic time allowed to solve a problem. The deterministic
             time is more or less correlated to the running time, and its unit should
             be around the second (at least on a Xeon(R) CPU E5-1650 v2 @ 3.50GHz).
            
             TODO(user): Improve the correlation.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasMaxDeterministicTime">
            <summary>Gets whether the "max_deterministic_time" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearMaxDeterministicTime">
            <summary>Clears the value of the "max_deterministic_time" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.MaxNumberOfIterationsFieldNumber">
            <summary>Field number for the "max_number_of_iterations" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.MaxNumberOfIterations">
            <summary>
            Maximum number of simplex iterations to solve a problem.
            A value of -1 means no limit.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasMaxNumberOfIterations">
            <summary>Gets whether the "max_number_of_iterations" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearMaxNumberOfIterations">
            <summary>Clears the value of the "max_number_of_iterations" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.MarkowitzZlatevParameterFieldNumber">
            <summary>Field number for the "markowitz_zlatev_parameter" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.MarkowitzZlatevParameter">
            <summary>
            How many columns do we look at in the Markowitz pivoting rule to find
            a good pivot. See markowitz.h.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasMarkowitzZlatevParameter">
            <summary>Gets whether the "markowitz_zlatev_parameter" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearMarkowitzZlatevParameter">
            <summary>Clears the value of the "markowitz_zlatev_parameter" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.MarkowitzSingularityThresholdFieldNumber">
            <summary>Field number for the "markowitz_singularity_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.MarkowitzSingularityThreshold">
            <summary>
            If a pivot magnitude is smaller than this during the Markowitz LU
            factorization, then the matrix is assumed to be singular. Note that
            this is an absolute threshold and is not relative to the other possible
            pivots on the same column (see lu_factorization_pivot_threshold).
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasMarkowitzSingularityThreshold">
            <summary>Gets whether the "markowitz_singularity_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearMarkowitzSingularityThreshold">
            <summary>Clears the value of the "markowitz_singularity_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.UseDualSimplexFieldNumber">
            <summary>Field number for the "use_dual_simplex" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.UseDualSimplex">
            <summary>
            Whether or not we use the dual simplex algorithm instead of the primal.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasUseDualSimplex">
            <summary>Gets whether the "use_dual_simplex" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearUseDualSimplex">
            <summary>Clears the value of the "use_dual_simplex" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.AllowSimplexAlgorithmChangeFieldNumber">
            <summary>Field number for the "allow_simplex_algorithm_change" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.AllowSimplexAlgorithmChange">
            <summary>
            During incremental solve, let the solver decide if it use the primal or
            dual simplex algorithm depending on the current solution and on the new
            problem. Note that even if this is true, the value of use_dual_simplex
            still indicates the default algorithm that the solver will use.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasAllowSimplexAlgorithmChange">
            <summary>Gets whether the "allow_simplex_algorithm_change" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearAllowSimplexAlgorithmChange">
            <summary>Clears the value of the "allow_simplex_algorithm_change" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.DevexWeightsResetPeriodFieldNumber">
            <summary>Field number for the "devex_weights_reset_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.DevexWeightsResetPeriod">
            <summary>
            Devex weights will be reset to 1.0 after that number of updates.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasDevexWeightsResetPeriod">
            <summary>Gets whether the "devex_weights_reset_period" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearDevexWeightsResetPeriod">
            <summary>Clears the value of the "devex_weights_reset_period" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.UsePreprocessingFieldNumber">
            <summary>Field number for the "use_preprocessing" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.UsePreprocessing">
            <summary>
            Whether or not we use advanced preprocessing techniques.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasUsePreprocessing">
            <summary>Gets whether the "use_preprocessing" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearUsePreprocessing">
            <summary>Clears the value of the "use_preprocessing" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.UseMiddleProductFormUpdateFieldNumber">
            <summary>Field number for the "use_middle_product_form_update" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.UseMiddleProductFormUpdate">
            <summary>
            Whether or not to use the middle product form update rather than the
            standard eta LU update. The middle form product update should be a lot more
            efficient (close to the Forrest-Tomlin update, a bit slower but easier to
            implement). See for more details:
            Qi Huangfu, J. A. Julian Hall, "Novel update techniques for the revised
            simplex method", 28 january 2013, Technical Report ERGO-13-0001
            http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasUseMiddleProductFormUpdate">
            <summary>Gets whether the "use_middle_product_form_update" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearUseMiddleProductFormUpdate">
            <summary>Clears the value of the "use_middle_product_form_update" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.InitializeDevexWithColumnNormsFieldNumber">
            <summary>Field number for the "initialize_devex_with_column_norms" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.InitializeDevexWithColumnNorms">
            <summary>
            Whether we initialize devex weights to 1.0 or to the norms of the matrix
            columns.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasInitializeDevexWithColumnNorms">
            <summary>Gets whether the "initialize_devex_with_column_norms" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearInitializeDevexWithColumnNorms">
            <summary>Clears the value of the "initialize_devex_with_column_norms" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.ExploitSingletonColumnInInitialBasisFieldNumber">
            <summary>Field number for the "exploit_singleton_column_in_initial_basis" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.ExploitSingletonColumnInInitialBasis">
            <summary>
            Whether or not we exploit the singleton columns already present in the
            problem when we create the initial basis.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasExploitSingletonColumnInInitialBasis">
            <summary>Gets whether the "exploit_singleton_column_in_initial_basis" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearExploitSingletonColumnInInitialBasis">
            <summary>Clears the value of the "exploit_singleton_column_in_initial_basis" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.DualSmallPivotThresholdFieldNumber">
            <summary>Field number for the "dual_small_pivot_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.DualSmallPivotThreshold">
            <summary>
            Like small_pivot_threshold but for the dual simplex. This is needed because
            the dual algorithm does not interpret this value in the same way.
            TODO(user): Clean this up and use the same small pivot detection.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasDualSmallPivotThreshold">
            <summary>Gets whether the "dual_small_pivot_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearDualSmallPivotThreshold">
            <summary>Clears the value of the "dual_small_pivot_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.PreprocessorZeroToleranceFieldNumber">
            <summary>Field number for the "preprocessor_zero_tolerance" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.PreprocessorZeroTolerance">
             <summary>
             A floating point tolerance used by the preprocessors. This is used for
             things like detecting if two columns/rows are proportional or if an
             interval is empty.
            
             Note that the preprocessors also use solution_feasibility_tolerance() to
             detect if a problem is infeasible.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasPreprocessorZeroTolerance">
            <summary>Gets whether the "preprocessor_zero_tolerance" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearPreprocessorZeroTolerance">
            <summary>Clears the value of the "preprocessor_zero_tolerance" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.ObjectiveLowerLimitFieldNumber">
            <summary>Field number for the "objective_lower_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.ObjectiveLowerLimit">
             <summary>
             The solver will stop as soon as it has proven that the objective is smaller
             than objective_lower_limit or greater than objective_upper_limit. Depending
             on the simplex algorithm (primal or dual) and the optimization direction,
             note that only one bound will be used at the time.
            
             Important: The solver does not add any tolerances to these values, and as
             soon as the objective (as computed by the solver, so with some imprecision)
             crosses one of these bounds (strictly), the search will stop. It is up to
             the client to add any tolerance if needed.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasObjectiveLowerLimit">
            <summary>Gets whether the "objective_lower_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearObjectiveLowerLimit">
            <summary>Clears the value of the "objective_lower_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.ObjectiveUpperLimitFieldNumber">
            <summary>Field number for the "objective_upper_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasObjectiveUpperLimit">
            <summary>Gets whether the "objective_upper_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearObjectiveUpperLimit">
            <summary>Clears the value of the "objective_upper_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.DegenerateMinistepFactorFieldNumber">
            <summary>Field number for the "degenerate_ministep_factor" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.DegenerateMinistepFactor">
             <summary>
             During a degenerate iteration, the more conservative approach is to do a
             step of length zero (while shifting the bound of the leaving variable).
             That is, the variable values are unchanged for the primal simplex or the
             reduced cost are unchanged for the dual simplex. However, instead of doing
             a step of length zero, it seems to be better on degenerate problems to do a
             small positive step. This is what is recommended in the EXPAND procedure
             described in:
             P. E. Gill, W. Murray, M. A. Saunders, and M. H. Wright. "A practical anti-
             cycling procedure for linearly constrained optimization".
             Mathematical Programming, 45:437\u2013474, 1989.
            
             Here, during a degenerate iteration we do a small positive step of this
             factor times the primal (resp. dual) tolerance. In the primal simplex, this
             may effectively push variable values (very slightly) further out of their
             bounds (resp. reduced costs for the dual simplex).
            
             Setting this to zero reverts to the more conservative approach of a zero
             step during degenerate iterations.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasDegenerateMinistepFactor">
            <summary>Gets whether the "degenerate_ministep_factor" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearDegenerateMinistepFactor">
            <summary>Clears the value of the "degenerate_ministep_factor" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.RandomSeedFieldNumber">
            <summary>Field number for the "random_seed" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.RandomSeed">
             <summary>
             At the beginning of each solve, the random number generator used in some
             part of the solver is reinitialized to this seed. If you change the random
             seed, the solver may make different choices during the solving process.
             Note that this may lead to a different solution, for example a different
             optimal basis.
            
             For some problems, the running time may vary a lot depending on small
             change in the solving algorithm. Running the solver with different seeds
             enables to have more robust benchmarks when evaluating new features.
            
             Also note that the solver is fully deterministic: two runs of the same
             binary, on the same machine, on the exact same data and with the same
             parameters will go through the exact same iterations. If they hit a time
             limit, they might of course yield different results because one will have
             advanced farther than the other.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasRandomSeed">
            <summary>Gets whether the "random_seed" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearRandomSeed">
            <summary>Clears the value of the "random_seed" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.NumOmpThreadsFieldNumber">
            <summary>Field number for the "num_omp_threads" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.NumOmpThreads">
            <summary>
            Number of threads in the OMP parallel sections. If left to 1, the code will
            not create any OMP threads and will remain single-threaded.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasNumOmpThreads">
            <summary>Gets whether the "num_omp_threads" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearNumOmpThreads">
            <summary>Clears the value of the "num_omp_threads" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.PerturbCostsInDualSimplexFieldNumber">
            <summary>Field number for the "perturb_costs_in_dual_simplex" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.PerturbCostsInDualSimplex">
            <summary>
            When this is true, then the costs are randomly perturbed before the dual
            simplex is even started. This has been shown to improve the dual simplex
            performance. For a good reference, see Huangfu Q (2013) "High performance
            simplex solver", Ph.D, dissertation, University of Edinburgh.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasPerturbCostsInDualSimplex">
            <summary>Gets whether the "perturb_costs_in_dual_simplex" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearPerturbCostsInDualSimplex">
            <summary>Clears the value of the "perturb_costs_in_dual_simplex" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.UseDedicatedDualFeasibilityAlgorithmFieldNumber">
            <summary>Field number for the "use_dedicated_dual_feasibility_algorithm" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.UseDedicatedDualFeasibilityAlgorithm">
             <summary>
             We have two possible dual phase I algorithms. Both work on an LP that
             minimize the sum of dual infeasiblities. One use dedicated code (when this
             param is true), the other one use exactly the same code as the dual phase
             II but on an auxiliary problem where the variable bounds of the original
             problem are changed.
            
             TODO(user): For now we have both, but ideally the non-dedicated version
             will win since it is a lot less code to maintain.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasUseDedicatedDualFeasibilityAlgorithm">
            <summary>Gets whether the "use_dedicated_dual_feasibility_algorithm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearUseDedicatedDualFeasibilityAlgorithm">
            <summary>Clears the value of the "use_dedicated_dual_feasibility_algorithm" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.RelativeCostPerturbationFieldNumber">
            <summary>Field number for the "relative_cost_perturbation" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.RelativeCostPerturbation">
            <summary>
            The magnitude of the cost perturbation is given by
            RandomIn(1.0, 2.0) * (
                relative_cost_perturbation * cost
              + relative_max_cost_perturbation * max_cost);
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasRelativeCostPerturbation">
            <summary>Gets whether the "relative_cost_perturbation" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearRelativeCostPerturbation">
            <summary>Clears the value of the "relative_cost_perturbation" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.RelativeMaxCostPerturbationFieldNumber">
            <summary>Field number for the "relative_max_cost_perturbation" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasRelativeMaxCostPerturbation">
            <summary>Gets whether the "relative_max_cost_perturbation" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearRelativeMaxCostPerturbation">
            <summary>Clears the value of the "relative_max_cost_perturbation" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.InitialConditionNumberThresholdFieldNumber">
            <summary>Field number for the "initial_condition_number_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.InitialConditionNumberThreshold">
            <summary>
            If our upper bound on the condition number of the initial basis (from our
            heurisitic or a warm start) is above this threshold, we revert to an all
            slack basis.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasInitialConditionNumberThreshold">
            <summary>Gets whether the "initial_condition_number_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearInitialConditionNumberThreshold">
            <summary>Clears the value of the "initial_condition_number_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.LogSearchProgressFieldNumber">
            <summary>Field number for the "log_search_progress" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.LogSearchProgress">
            <summary>
            If true, logs the progress of a solve to LOG(INFO). Note that the same
            messages can also be turned on by displaying logs at level 1 for the
            relevant files.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasLogSearchProgress">
            <summary>Gets whether the "log_search_progress" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearLogSearchProgress">
            <summary>Clears the value of the "log_search_progress" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.LogToStdoutFieldNumber">
            <summary>Field number for the "log_to_stdout" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.LogToStdout">
            <summary>
            If true, logs will be displayed to stdout instead of using Google log info.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasLogToStdout">
            <summary>Gets whether the "log_to_stdout" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearLogToStdout">
            <summary>Clears the value of the "log_to_stdout" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.CrossoverBoundSnappingDistanceFieldNumber">
            <summary>Field number for the "crossover_bound_snapping_distance" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.CrossoverBoundSnappingDistance">
             <summary>
             If the starting basis contains FREE variable with bounds, we will move
             any such variable to their closer bounds if the distance is smaller than
             this parameter.
            
             The starting statuses can contains FREE variables with bounds, if a user
             set it like this externally. Also, any variable with an initial BASIC
             status that was not kept in the initial basis is marked as FREE before this
             step is applied.
            
             Note that by default a FREE variable is assumed to be zero unless a
             starting value was specified via SetStartingVariableValuesForNextSolve().
            
             Note that, at the end of the solve, some of these FREE variable with bounds
             and an interior point value might still be left in the final solution.
             Enable push_to_vertex to clean these up.
             </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasCrossoverBoundSnappingDistance">
            <summary>Gets whether the "crossover_bound_snapping_distance" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearCrossoverBoundSnappingDistance">
            <summary>Clears the value of the "crossover_bound_snapping_distance" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.PushToVertexFieldNumber">
            <summary>Field number for the "push_to_vertex" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.PushToVertex">
            <summary>
            If the optimization phases finishes with super-basic variables (i.e.,
            variables that either 1) have bounds but are FREE in the basis, or 2) have
            no bounds and are FREE in the basis at a nonzero value), then run a "push"
            phase to push these variables to bounds, obtaining a vertex solution. Note
            this situation can happen only if a starting value was specified via
            SetStartingVariableValuesForNextSolve().
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasPushToVertex">
            <summary>Gets whether the "push_to_vertex" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearPushToVertex">
            <summary>Clears the value of the "push_to_vertex" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.UseImpliedFreePreprocessorFieldNumber">
            <summary>Field number for the "use_implied_free_preprocessor" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.UseImpliedFreePreprocessor">
            <summary>
            If presolve runs, include the pass that detects implied free variables.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasUseImpliedFreePreprocessor">
            <summary>Gets whether the "use_implied_free_preprocessor" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearUseImpliedFreePreprocessor">
            <summary>Clears the value of the "use_implied_free_preprocessor" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.MaxValidMagnitudeFieldNumber">
            <summary>Field number for the "max_valid_magnitude" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.MaxValidMagnitude">
            <summary>
            Any finite values in the input LP must be below this threshold, otherwise
            the model will be reported invalid. This is needed to avoid floating point
            overflow when evaluating bounds * coeff for instance. In practice, users
            shouldn't use super large values in an LP. With the default threshold, even
            evaluating large constraint with variables at their bound shouldn't cause
            any overflow.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasMaxValidMagnitude">
            <summary>Gets whether the "max_valid_magnitude" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearMaxValidMagnitude">
            <summary>Clears the value of the "max_valid_magnitude" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.DropMagnitudeFieldNumber">
            <summary>Field number for the "drop_magnitude" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.DropMagnitude">
            <summary>
            Value in the input LP lower than this will be ignored. This is similar to
            drop_tolerance but more aggressive as this is used before scaling. This is
            mainly here to avoid underflow and have simpler invariant in the code, like
            a * b == 0 iff a or b is zero and things like this.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasDropMagnitude">
            <summary>Gets whether the "drop_magnitude" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearDropMagnitude">
            <summary>Clears the value of the "drop_magnitude" field</summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.DualPricePrioritizeNormFieldNumber">
            <summary>Field number for the "dual_price_prioritize_norm" field.</summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.DualPricePrioritizeNorm">
            <summary>
            On some problem like stp3d or pds-100 this makes a huge difference in
            speed and number of iterations of the dual simplex.
            </summary>
        </member>
        <member name="P:Google.OrTools.Glop.GlopParameters.HasDualPricePrioritizeNorm">
            <summary>Gets whether the "dual_price_prioritize_norm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Glop.GlopParameters.ClearDualPricePrioritizeNorm">
            <summary>Clears the value of the "dual_price_prioritize_norm" field</summary>
        </member>
        <member name="T:Google.OrTools.Glop.GlopParameters.Types">
            <summary>Container for nested types declared in the GlopParameters message type.</summary>
        </member>
        <member name="T:Google.OrTools.Glop.GlopParameters.Types.ScalingAlgorithm">
            <summary>
            Supported algorithms for scaling:
            EQUILIBRATION - progressive scaling by row and column norms until the
            marginal difference passes below a threshold.
            LINEAR_PROGRAM - EXPERIMENTAL: finding optimal scale factors using a linear
            program in the log scale.
            </summary>
        </member>
        <member name="T:Google.OrTools.Glop.GlopParameters.Types.SolverBehavior">
            <summary>
            Like a Boolean with an extra value to let the algorithm decide what is the
            best choice.
            </summary>
        </member>
        <member name="T:Google.OrTools.Glop.GlopParameters.Types.PricingRule">
            <summary>
            General strategy used during pricing.
            </summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.Types.PricingRule.Dantzig">
             <summary>
             Strategy using only the reduced cost of a variable.
            
             Note that compared to a textbook rule, we normalize the reduced cost of a
             variable using the norm of the associated column. This improves quite a
             bit the rule at almost no extra complexity. See the first paper from
             Ping-Qi Pan cited in primal_edge_norms.h.
             </summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.Types.PricingRule.SteepestEdge">
            <summary>
            Normalize the reduced costs by the norm of the edges. Since computing
            norms at each step is too expensive, reduced costs and norms are
            updated iteratively from one iteration to the next.
            </summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.Types.PricingRule.Devex">
            <summary>
            Normalize the reduced costs by an approximation of the norm of the edges.
            This should offer a good tradeoff between steepest edge and speed.
            </summary>
        </member>
        <member name="T:Google.OrTools.Glop.GlopParameters.Types.InitialBasisHeuristic">
            <summary>
            Heuristics to use in the primal simplex to remove fixed slack variables
            from the initial basis.
            </summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.Types.InitialBasisHeuristic.None">
            <summary>
            Leave the fixed slack variables in the basis.
            </summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.Types.InitialBasisHeuristic.Bixby">
             <summary>
             Use the heuristic described in:
             Robert E. Bixby, "Implementing the Simplex Method: The Initial Basis"
             ORSA Jounal on Computing, Vol. 4, No. 3, Summer 1992.
             http://joc.journal.informs.org/content/4/3/267.abstract
            
             It requires use_scaling to be true, otherwise it behaves like NONE.
             </summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.Types.InitialBasisHeuristic.Triangular">
            <summary>
            Replace the fixed columns while keeping the initial basis triangular. The
            heuristic to select which column to use first is similar to the one used
            for BIXBY. This algorithm is similar to the "advanced initial basis"
            GLPK uses by default. Both algorithm produce a triangular initial basis,
            however the heuristics used are not exactly the same.
            </summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.Types.InitialBasisHeuristic.Maros">
            <summary>
            Use a version of Maros's triangular feasibility crash
            https://books.google.fr/books?isbn=1461502578
            Chapter 9.8.2.1
            </summary>
        </member>
        <member name="T:Google.OrTools.Glop.GlopParameters.Types.CostScalingAlgorithm">
            <summary>
            This is only used if use_scaling is true. After the scaling is done, we
            also scale the objective by a constant factor. This is important because
            scaling the cost has a direct influence on the meaning of the
            dual_feasibility_tolerance. Because we usually use a fixed tolerance, the
            objective must be well scaled to make sense.
            </summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.Types.CostScalingAlgorithm.NoCostScaling">
            <summary>
            Leave the cost as is.
            </summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.Types.CostScalingAlgorithm.ContainOneCostScaling">
            <summary>
            This is the most defensive option. It makes sure that
            [min_cost_magnitude, max_cost_magnitude] contains 1.0, and if not, it
            makes the closest magnitude bound equal to one.
            </summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.Types.CostScalingAlgorithm.MeanCostScaling">
            <summary>
            Make the mean of the non-zero costs equals to one.
            </summary>
        </member>
        <member name="F:Google.OrTools.Glop.GlopParameters.Types.CostScalingAlgorithm.MedianCostScaling">
            <summary>
            Make the median of the non-zero costs equals to one.
            </summary>
        </member>
        <member name="T:Google.OrTools.Graph.FlowProblemReflection">
            <summary>Holder for reflection information generated from ortools/graph/flow_problem.proto</summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowProblemReflection.Descriptor">
            <summary>File descriptor for ortools/graph/flow_problem.proto</summary>
        </member>
        <member name="F:Google.OrTools.Graph.FlowArcProto.TailFieldNumber">
            <summary>Field number for the "tail" field.</summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowArcProto.Tail">
            <summary>
            A directed arc goes from a tail node to a head node.
            Node ids must be non-negative (>= 0).
            </summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowArcProto.HasTail">
            <summary>Gets whether the "tail" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Graph.FlowArcProto.ClearTail">
            <summary>Clears the value of the "tail" field</summary>
        </member>
        <member name="F:Google.OrTools.Graph.FlowArcProto.HeadFieldNumber">
            <summary>Field number for the "head" field.</summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowArcProto.HasHead">
            <summary>Gets whether the "head" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Graph.FlowArcProto.ClearHead">
            <summary>Clears the value of the "head" field</summary>
        </member>
        <member name="F:Google.OrTools.Graph.FlowArcProto.CapacityFieldNumber">
            <summary>Field number for the "capacity" field.</summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowArcProto.Capacity">
            <summary>
            Capacity of the arc. Must be non-negative (>= 0). If the capacity is zero,
            it is equivalent to not including the arc in the FlowModelProto.
            </summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowArcProto.HasCapacity">
            <summary>Gets whether the "capacity" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Graph.FlowArcProto.ClearCapacity">
            <summary>Clears the value of the "capacity" field</summary>
        </member>
        <member name="F:Google.OrTools.Graph.FlowArcProto.UnitCostFieldNumber">
            <summary>Field number for the "unit_cost" field.</summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowArcProto.UnitCost">
            <summary>
            Cost of this arc per unit of flow.
            Note that it can take any positive, negative or null value.
            </summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowArcProto.HasUnitCost">
            <summary>Gets whether the "unit_cost" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Graph.FlowArcProto.ClearUnitCost">
            <summary>Clears the value of the "unit_cost" field</summary>
        </member>
        <member name="F:Google.OrTools.Graph.FlowNodeProto.IdFieldNumber">
            <summary>Field number for the "id" field.</summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowNodeProto.Id">
            <summary>
            The ids must be non-negative (>= 0). They should be dense for good
            performance. Note that it is not mandatory to include nodes with no supply
            in a FlowModelProto.
            </summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowNodeProto.HasId">
            <summary>Gets whether the "id" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Graph.FlowNodeProto.ClearId">
            <summary>Clears the value of the "id" field</summary>
        </member>
        <member name="F:Google.OrTools.Graph.FlowNodeProto.SupplyFieldNumber">
            <summary>Field number for the "supply" field.</summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowNodeProto.Supply">
            <summary>
            The supply can be positive or negative in which case it means demand.
            The sum of the supplies over all nodes must always be 0.
            </summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowNodeProto.HasSupply">
            <summary>Gets whether the "supply" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Graph.FlowNodeProto.ClearSupply">
            <summary>Clears the value of the "supply" field</summary>
        </member>
        <member name="T:Google.OrTools.Graph.FlowModelProto">
            <summary>
            Holds a flow problem, see NodeProto and ArcProto for more details.
            </summary>
        </member>
        <member name="F:Google.OrTools.Graph.FlowModelProto.NodesFieldNumber">
            <summary>Field number for the "nodes" field.</summary>
        </member>
        <member name="F:Google.OrTools.Graph.FlowModelProto.ArcsFieldNumber">
            <summary>Field number for the "arcs" field.</summary>
        </member>
        <member name="F:Google.OrTools.Graph.FlowModelProto.ProblemTypeFieldNumber">
            <summary>Field number for the "problem_type" field.</summary>
        </member>
        <member name="P:Google.OrTools.Graph.FlowModelProto.HasProblemType">
            <summary>Gets whether the "problem_type" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Graph.FlowModelProto.ClearProblemType">
            <summary>Clears the value of the "problem_type" field</summary>
        </member>
        <member name="T:Google.OrTools.Graph.FlowModelProto.Types">
            <summary>Container for nested types declared in the FlowModelProto message type.</summary>
        </member>
        <member name="T:Google.OrTools.Graph.FlowModelProto.Types.ProblemType">
            <summary>
            The type of problem to solve.
            </summary>
        </member>
        <member name="T:Google.OrTools.LinearSolver.DoubleVector.DoubleVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.LinearSolver.MPConstraintVector.MPConstraintVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.LinearSolver.MPVariableVector.MPVariableVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ModelBuilder.Model">
             <summary>
              Main modeling class.
             </summary>
            
             Proposes a factory to create all modeling objects understood by the Solver.
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.#ctor">
            <summary>
            Main constructor.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.Clone">
            <summary>
            Returns a cloned model.
            </summary>
            <returns>A deep copy of the model.</returns>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.NewVar(System.Double,System.Double,System.Boolean,System.String)">
            <summary>
            reates a variable with domain [lb, ub].
            </summary>
            <param name="lb">The lower bound of the variable</param>
            <param name="ub">The upper bound of the variable</param>
            <param name="isIntegral">Indicates if the variable is restricted to take only integral values</param>
            <param name="name">The name of the variable</param>
            <returns>The new variable</returns>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.NewNumVar(System.Double,System.Double,System.String)">
            <summary>
            Creates a continuous variable with domain [lb, ub].
            </summary>
            <param name="lb">The lower bound of the variable</param>
            <param name="ub">The upper bound of the variable</param>
            <param name="name">The name of the variable</param>
            <returns>The new continuous variable</returns>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.NewIntVar(System.Double,System.Double,System.String)">
            <summary>
            Creates an integer variable with domain [lb, ub].
            </summary>
            <param name="lb">The lower bound of the variable</param>
            <param name="ub">The upper bound of the variable</param>
            <param name="name">The name of the variable</param>
            <returns>The new integer variable</returns>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.NewBoolVar(System.String)">
            <summary>
            Creates a bool variable with the given name.
            </summary>
            <param name="name">The name of the variable</param>
            <returns>The new Boolean variable</returns>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.NewConstant(System.Double)">
            <summary>
            Creates a constant variable.
            </summary>
            <param name="value">the value of the constant variable</param>
            <returns>A new variable with a fixed value</returns>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.VarFromIndex(System.Int32)">
            Rebuilds a variable from its index.
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.Add(Google.OrTools.ModelBuilder.BoundedLinearExpression)">
            <summary>
            Adds a Linear constraint to the model.
            </summary>
            <param name="lin">A bounded linear expression</param>
            <returns>A linear expression</returns>
            <exception cref="T:System.ArgumentException">Throw when the constraint is not supported by the linear solver</exception>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.AddLinearConstraint(Google.OrTools.ModelBuilder.LinearExpr,System.Double,System.Double)">
            <summary>
            Adds the constraint expr in [lb, ub].
            </summary>
            <param name="expr">The constrained expression</param>
            <param name="lb">the constrained lower bound of the expression</param>
            <param name="ub">the constrained upper bound of the expression</param>
            <returns>the linear constraint</returns>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.ConstraintFromIndex(System.Int32)">
            Rebuilds a linear constraint from its index.
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.AddEnforced(Google.OrTools.ModelBuilder.BoundedLinearExpression,Google.OrTools.ModelBuilder.Variable,System.Boolean)">
            <summary>
            Adds an enforced Linear constraint to the model.
            </summary>
            <param name="lin">A bounded linear expression</param>
            <param name="iVar">The indicator variable of the constraint.</param>
            <param name="iValue">The indicator value of the constraint.</param>
            <returns>A linear expression</returns>
            <exception cref="T:System.ArgumentException">Throw when the constraint is not supported by the linear solver</exception>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.AddEnforcedLinearConstraint(Google.OrTools.ModelBuilder.LinearExpr,System.Double,System.Double,Google.OrTools.ModelBuilder.Variable,System.Boolean)">
            <summary>
            Adds the constraint iVar == iValue => expr in [lb, ub].
            </summary>
            <param name="expr">The constrained expression</param>
            <param name="lb">the lower bound of the constraint</param>
            <param name="ub">the upper bound of the constraint</param>
            <param name="iVar">the indicator variable of the constraint</param>
            <param name="iValue">the indicator value of the constraint</param>
            <returns>the enforced linear constraint</returns>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.EnforcedConstraintFromIndex(System.Int32)">
            Rebuilds a linear constraint from its index.
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.Minimize(Google.OrTools.ModelBuilder.LinearExpr)">
            <summary>
            Minimize expression.
            </summary>
            <param name="obj">the linear expression to minimize</param>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.Maximize(Google.OrTools.ModelBuilder.LinearExpr)">
            <summary>
            Maximize expression.
            </summary>
            <param name="obj">the linear expression to maximize</param>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.Optimize(Google.OrTools.ModelBuilder.LinearExpr,System.Boolean)">
            <summary>
            Sets the objective expression.
            </summary>
            <param name="obj">the linear expression to optimize</param>
            <param name="maximize">the direction of the optimization</param>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.Model.ObjectiveOffset">
            <summary>
            The offset of the objective.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.ClearHints">
            <summary>
            Remove all hints from the model.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.AddHint(Google.OrTools.ModelBuilder.Variable,System.Double)">
            <summary>
            Adds var == value as a hint to the model.  Note that variables must not appear more than once in the list of
            hints.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.VariablesCount">
            <summary>
            Returns the number of variables in the model.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.ConstraintsCount">
            <summary>
            Returns the number of constraints in the model.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.Model.Name">
            <summary>
            The name of the model.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.ExportToFile(System.String)">
             <summary>
             Write the model as a protocol buffer to 'file'.
             </summary>
             @param file file to write the model to. If the filename ends with 'txt', the model will be
                written as a text file, otherwise, the binary format will be used.
            @return true if the model was correctly written.
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Model.ImportFromFile(System.String)">
             <summary>
             load the model as a protocol buffer from 'file'.
             </summary>
             @param file file to read the model from.
            @return true if the model was correctly loaded.
        </member>
        <member name="P:Google.OrTools.ModelBuilder.Model.Helper">
            <summary>
            The model builder helper.
            </summary>
        </member>
        <member name="T:Google.OrTools.ModelBuilder.LinearConstraint">
            <summary>
            Wrapper around a linear constraint stored in the ModelBuilderHelper instance.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.LinearConstraint.Index">
            <summary>
            Returns the index of the constraint in the model.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.LinearConstraint.Helper">
            <summary>
            Returns the constraint builder.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.LinearConstraint.LowerBound">
            <summary>
            The lower bound of the constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.LinearConstraint.UpperBound">
            <summary>
            The upper bound of the constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.LinearConstraint.Name">
            <summary>
            The name of the variable given upon creation.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearConstraint.AddTerm(Google.OrTools.ModelBuilder.Variable,System.Double)">
            <summary>
            Adds var * coeff to the constraint.
            </summary>
            <param name="var">the variable of the term to add</param>
            <param name="coeff">the coefficient of the term to add</param>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearConstraint.SetVariableCoefficient(Google.OrTools.ModelBuilder.Variable,System.Double)">
            <summary>
            Sets the coefficient of var to coeff, adding or removing a term if needed.
            </summary>
            <param name="var">the variable of the term to set</param>
            <param name="coeff">the coefficient of the term to set</param>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearConstraint.ClearTerms">
            <summary>
            Clear all terms of the constraint.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearConstraint.WithName(System.String)">
            <summary>
            Inline name setter.
            </summary>
            <param name="name">the new name of the variable</param>
            <returns>this</returns>
        </member>
        <member name="T:Google.OrTools.ModelBuilder.EnforcedLinearConstraint">
            <summary>
            Wrapper around an enforced linear constraint stored in the ModelBuilderHelper instance.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.EnforcedLinearConstraint.Index">
            <summary>
            Returns the index of the constraint in the model.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.EnforcedLinearConstraint.Helper">
            <summary>
            Returns the constraint builder.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.EnforcedLinearConstraint.LowerBound">
            <summary>
            The lower bound of the constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.EnforcedLinearConstraint.UpperBound">
            <summary>
            The upper bound of the constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.EnforcedLinearConstraint.IndicatorVariable">
            <summary>
            The indicator variable of the constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.EnforcedLinearConstraint.IndicatorValue">
            <summary>
            The indicator value of the constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.EnforcedLinearConstraint.Name">
            <summary>
            The name of the variable given upon creation.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.EnforcedLinearConstraint.AddTerm(Google.OrTools.ModelBuilder.Variable,System.Double)">
            <summary>
            Adds var * coeff to the constraint.
            </summary>
            <param name="var">the variable of the term to add</param>
            <param name="coeff">the coefficient of the term to add</param>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.EnforcedLinearConstraint.SetVariableCoefficient(Google.OrTools.ModelBuilder.Variable,System.Double)">
            <summary>
            Sets the coefficient of var to coeff, adding or removing a term if needed.
            </summary>
            <param name="var">the variable of the term to set</param>
            <param name="coeff">the coefficient of the term to set</param>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.EnforcedLinearConstraint.ClearTerms">
            <summary>
            Clear all terms of the constraint.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.EnforcedLinearConstraint.WithName(System.String)">
            <summary>
            Inline setter
            </summary>
            <param name="name">The name to assign</param>
            <returns>this</returns>
        </member>
        <member name="T:Google.OrTools.ModelBuilder.LinearExpr">
            <summary>
            Holds a linear expression: <c>sum (ai * xi) + b</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExpr.Sum(System.Collections.Generic.IEnumerable{Google.OrTools.ModelBuilder.LinearExpr})">
            <summary> Creates <c>Sum(exprs)</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExpr.WeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.ModelBuilder.LinearExpr},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary> Creates <c>Sum(exprs[i] * coeffs[i])</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExpr.WeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.ModelBuilder.LinearExpr},System.Collections.Generic.IEnumerable{System.Double})">
            <summary> Creates <c>Sum(exprs[i] * coeffs[i])</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExpr.Term(Google.OrTools.ModelBuilder.LinearExpr,System.Double)">
            <summary> Creates <c>expr * coeff</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExpr.Affine(Google.OrTools.ModelBuilder.LinearExpr,System.Double,System.Double)">
            <summary> Creates <c>expr * coeff + offset</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExpr.Constant(System.Double)">
            <summary> Creates a constant expression.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExpr.NewBuilder(System.Int32)">
            <summary> Creates a builder class for linear expression.</summary> 
        </member>
        <member name="T:Google.OrTools.ModelBuilder.LinearExprBuilder">
            <summary> A builder class for linear expressions.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExprBuilder.Add(Google.OrTools.ModelBuilder.LinearExpr)">
            <summary> Adds <c>expr</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExprBuilder.Add(System.Double)">
            <summary> Adds <c>constant</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExprBuilder.AddTerm(Google.OrTools.ModelBuilder.LinearExpr,System.Double)">
            <summary> Adds <c>expr * coefficient</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExprBuilder.AddSum(System.Collections.Generic.IEnumerable{Google.OrTools.ModelBuilder.LinearExpr})">
            <summary> Adds <c>sum(exprs)</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExprBuilder.AddWeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.ModelBuilder.LinearExpr},System.Collections.Generic.IEnumerable{System.Double})">
            <summary> Adds <c>sum(exprs[i] * coeffs[i])</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExprBuilder.AddWeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.ModelBuilder.LinearExpr},System.Collections.Generic.IEnumerable{System.Int64})">
            <summary> Adds <c>sum(exprs[i] * coeffs[i])</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.LinearExprBuilder.AddWeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.ModelBuilder.LinearExpr},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary> Adds <c>sum(exprs[i] * coeffs[i])</c> to the builder.</summary> 
        </member>
        <member name="T:Google.OrTools.ModelBuilder.Variable">
            <summary>
            Holds a variable.
            </summary>
            <remarks>
            This class must be constructed from the CpModel class.
            </remarks>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.Variable.Index">
            Returns the index of the variable in the underlying ModelBuilderHelper. 
        </member>
        <member name="P:Google.OrTools.ModelBuilder.Variable.Helper">
            The underlying VariableProto. 
        </member>
        <member name="P:Google.OrTools.ModelBuilder.Variable.LowerBound">
            Returns the domain of the variable. 
        </member>
        <member name="P:Google.OrTools.ModelBuilder.Variable.Name">
            Returns the name of the variable given upon creation. 
        </member>
        <member name="T:Google.OrTools.ModelBuilder.BoundedLinearExpression">
            <summary>
            Holds a linear constraint: <c> expression  domain</c>
            </summary>
            <remarks>
            This class must be constructed from the CpModel class or from the comparison operators.
            </remarks>
        </member>
        <member name="T:Google.OrTools.ModelBuilder.Solver">
            <summary>
            Model solver class
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.#ctor(System.String)">
            <summary>
            Creates the solver with the supplied solver backend.
            </summary>
            <param name="solverName">the name of the solver backend</param>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.Solve(Google.OrTools.ModelBuilder.Model)">
            <summary>
            Solves given model, and returns the status of the response.
            </summary>
            <param name="model">the model to solve</param>
            <returns>the status of the solve</returns>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.EnableOutput(System.Boolean)">
            <summary>
            Enables or disables the underlying solver output.
            </summary>
            <param name="enable">the Boolean that controls the output</param>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.SetTimeLimitInSeconds(System.Double)">
            Sets the time limit for the solve in seconds. 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.SetSolverSpecificParameters(System.String)">
            Sets solver specific parameters as string. 
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.SolverIsSupported">
            <summary>
            Returns whether solver specified during the ctor was found and correctly installed.
            </summary>
            <returns>whether the solver is supported or not</returns>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.InterruptSolve">
            <summary>
            Tries to interrupt the solve. Returns true if the feature is supported.
            </summary>
            <returns>whether the solver supports interruption</returns>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.HasResponse">
            <summary>
            Returns true if solve() was called, and a response was returned.
            </summary>
            <returns>whether solve did happen</returns>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.HasSolution">
            <summary>
            Returns true if solve() was called, and a solution was returned.
            </summary>
            <returns>whether a solution was found</returns>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.Solver.ObjectiveValue">
            <summary>
            The best objective value found during search. This raises a SolverException if no solution has been found,
            or if Solve() has not been called.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.Solver.BestObjectiveBound">
            <summary>
            The best objective bound found during search. This raises a SolverException if no solution has been found,
            or if Solve() has not been called.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.Value(Google.OrTools.ModelBuilder.Variable)">
            <summary>
            The value of a variable in the current solution. This raises a SolverException if no solution has been
            found, or if Solve() has not been called.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.ReducedCost(Google.OrTools.ModelBuilder.Variable)">
            <summary>
            The reduced cost of a variable in the current solution. This raises a SolverException if no solution has
            been found, or if Solve() has not been called.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.DualValue(Google.OrTools.ModelBuilder.LinearConstraint)">
            <summary>
            The dual value of a linear constraint in the current solution. This raises a SolverException if no solution
            has been found, or if Solve() has not been called.
            </summary>
        </member>
        <member name="M:Google.OrTools.ModelBuilder.Solver.Activity(Google.OrTools.ModelBuilder.LinearConstraint)">
            <summary>
            The activity of a constraint in the current solution. This raises a SolverException if no solution has been
            found, or if Solve() has not been called.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.Solver.LogCallback">
            <summary>
            Sets the log callback for the solver.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.Solver.WallTime">
            <summary>
            Returns the elapsed time since the creation of the solver.
            </summary>
        </member>
        <member name="P:Google.OrTools.ModelBuilder.Solver.UserTime">
            <summary>
            Returns the user time since the creation of the solver.
            </summary>
        </member>
        <member name="T:Google.OrTools.ModelBuilder.DoubleVector.DoubleVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ModelBuilder.IntVector.IntVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.DecisionBuilderVector.DecisionBuilderVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.Int64Vector.Int64VectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.Int64VectorVector.Int64VectorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.IntervalVarVector.IntervalVarVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.IntVarVector.IntVarVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.IntVector.IntVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.IntVectorVector.IntVectorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchFilterVector.LocalSearchFilterVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchOperatorVector.LocalSearchOperatorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingEnumsReflection">
            <summary>Holder for reflection information generated from ortools/constraint_solver/routing_enums.proto</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingEnumsReflection.Descriptor">
            <summary>File descriptor for ortools/constraint_solver/routing_enums.proto</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.FirstSolutionStrategy">
            <summary>
            First solution strategies, used as starting point of local search.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types">
            <summary>Container for nested types declared in the FirstSolutionStrategy message type.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.Unset">
            <summary>
            See the homonymous value in LocalSearchMetaheuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.Automatic">
            <summary>
            Lets the solver detect which strategy to use according to the model being
            solved.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.PathCheapestArc">
            <summary>
            --- Path addition heuristics ---
            Starting from a route "start" node, connect it to the node which produces
            the cheapest route segment, then extend the route by iterating on the
            last node added to the route.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.PathMostConstrainedArc">
            <summary>
            Same as PATH_CHEAPEST_ARC, but arcs are evaluated with a comparison-based
            selector which will favor the most constrained arc first. To assign a
            selector to the routing model, see
            RoutingModel::ArcIsMoreConstrainedThanArc() in routing.h for details.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.EvaluatorStrategy">
            <summary>
            Same as PATH_CHEAPEST_ARC, except that arc costs are evaluated using the
            function passed to RoutingModel::SetFirstSolutionEvaluator()
            (cf. routing.h).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.Savings">
            <summary>
            Savings algorithm (Clarke &amp; Wright).
            Reference: Clarke, G. &amp; Wright, J.W.:
            "Scheduling of Vehicles from a Central Depot to a Number of Delivery
            Points", Operations Research, Vol. 12, 1964, pp. 568-581
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.Sweep">
            <summary>
            Sweep algorithm (Wren &amp; Holliday).
            Reference: Anthony Wren &amp; Alan Holliday: Computer Scheduling of Vehicles
            from One or More Depots to a Number of Delivery Points Operational
            Research Quarterly (1970-1977),
            Vol. 23, No. 3 (Sep., 1972), pp. 333-344
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.Christofides">
            <summary>
            Christofides algorithm (actually a variant of the Christofides algorithm
            using a maximal matching instead of a maximum matching, which does
            not guarantee the 3/2 factor of the approximation on a metric travelling
            salesman). Works on generic vehicle routing models by extending a route
            until no nodes can be inserted on it.
            Reference: Nicos Christofides, Worst-case analysis of a new heuristic for
            the travelling salesman problem, Report 388, Graduate School of
            Industrial Administration, CMU, 1976.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.AllUnperformed">
            <summary>
            --- Path insertion heuristics ---
            Make all nodes inactive. Only finds a solution if nodes are optional (are
            element of a disjunction constraint with a finite penalty cost).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.BestInsertion">
            <summary>
            Iteratively build a solution by inserting the cheapest node at its
            cheapest position; the cost of insertion is based on the global cost
            function of the routing model. As of 2/2012, only works on models with
            optional nodes (with finite penalty costs).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.ParallelCheapestInsertion">
            <summary>
            Iteratively build a solution by inserting the cheapest node at its
            cheapest position; the cost of insertion is based on the arc cost
            function. Is faster than BEST_INSERTION.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.SequentialCheapestInsertion">
            <summary>
            Iteratively build a solution by constructing routes sequentially, for
            each route inserting the cheapest node at its cheapest position until the
            route is completed; the cost of insertion is based on the arc cost
            function. Is faster than PARALLEL_CHEAPEST_INSERTION.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.LocalCheapestInsertion">
            <summary>
            Iteratively build a solution by inserting each node at its cheapest
            position; the cost of insertion is based on the arc cost function.
            Differs from PARALLEL_CHEAPEST_INSERTION by the node selected for
            insertion; here nodes are considered in decreasing order of distance to
            the start/ends of the routes, i.e. farthest nodes are inserted first.
            Is faster than SEQUENTIAL_CHEAPEST_INSERTION.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.LocalCheapestCostInsertion">
            <summary>
            Same as LOCAL_CHEAPEST_INSERTION except that the cost of insertion is
            based on the routing model cost function instead of arc costs only.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.GlobalCheapestArc">
            <summary>
            --- Variable-based heuristics ---
            Iteratively connect two nodes which produce the cheapest route segment.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.LocalCheapestArc">
            <summary>
            Select the first node with an unbound successor and connect it to the
            node which produces the cheapest route segment.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.FirstUnboundMinValue">
            <summary>
            Select the first node with an unbound successor and connect it to the
            first available node.
            This is equivalent to the CHOOSE_FIRST_UNBOUND strategy combined with
            ASSIGN_MIN_VALUE (cf. constraint_solver.h).
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic">
            <summary>
            Local search metaheuristics used to guide the search. Apart from greedy
            descent, they will try to escape local minima.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types">
            <summary>Container for nested types declared in the LocalSearchMetaheuristic message type.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.Unset">
            <summary>
            Means "not set". If the solver sees that, it'll behave like for
            AUTOMATIC. But this value won't override others upon a proto MergeFrom(),
            whereas "AUTOMATIC" will.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.Automatic">
            <summary>
            Lets the solver select the metaheuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.GreedyDescent">
            <summary>
            Accepts improving (cost-reducing) local search neighbors until a local
            minimum is reached.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.GuidedLocalSearch">
            <summary>
            Uses guided local search to escape local minima
            (cf. http://en.wikipedia.org/wiki/Guided_Local_Search); this is generally
            the most efficient metaheuristic for vehicle routing.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.SimulatedAnnealing">
            <summary>
            Uses simulated annealing to escape local minima
            (cf. http://en.wikipedia.org/wiki/Simulated_annealing).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.TabuSearch">
            <summary>
            Uses tabu search to escape local minima
            (cf. http://en.wikipedia.org/wiki/Tabu_search).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.GenericTabuSearch">
            <summary>
            Uses tabu search on a list of variables to escape local minima. The list
            of variables to use must be provided via the SetTabuVarsCallback
            callback.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingParametersReflection">
            <summary>Holder for reflection information generated from ortools/constraint_solver/routing_parameters.proto</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingParametersReflection.Descriptor">
            <summary>File descriptor for ortools/constraint_solver/routing_parameters.proto</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingSearchParameters">
             <summary>
             Parameters defining the search used to solve vehicle routing problems.
            
             If a parameter is unset (or, equivalently, set to its default value),
             then the routing library will pick its preferred value for that parameter
             automatically: this should be the case for most parameters.
             To see those "default" parameters, call GetDefaultRoutingSearchParameters().
             Next ID: 61
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.FirstSolutionStrategyFieldNumber">
            <summary>Field number for the "first_solution_strategy" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.FirstSolutionStrategy">
            <summary>
            First solution strategies, used as starting point of local search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseUnfilteredFirstSolutionStrategyFieldNumber">
            <summary>Field number for the "use_unfiltered_first_solution_strategy" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseUnfilteredFirstSolutionStrategy">
             <summary>
             --- Advanced first solutions strategy settings ---
             Don't touch these unless you know what you are doing.
            
             Use filtered version of first solution strategy if available.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsNeighborsRatioFieldNumber">
            <summary>Field number for the "savings_neighbors_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsNeighborsRatio">
            <summary>
            Parameters specific to the Savings first solution heuristic.
            Ratio (in ]0, 1]) of neighbors to consider for each node when constructing
            the savings. If unspecified, its value is considered to be 1.0.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsMaxMemoryUsageBytesFieldNumber">
            <summary>Field number for the "savings_max_memory_usage_bytes" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsMaxMemoryUsageBytes">
            <summary>
            The number of neighbors considered for each node in the Savings heuristic
            is chosen so that the space used to store the savings doesn't exceed
            savings_max_memory_usage_bytes, which must be in ]0, 1e10].
            NOTE: If both savings_neighbors_ratio and savings_max_memory_usage_bytes
            are specified, the number of neighbors considered for each node will be the
            minimum of the two numbers determined by these parameters.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsAddReverseArcsFieldNumber">
            <summary>Field number for the "savings_add_reverse_arcs" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsAddReverseArcs">
            <summary>
            Add savings related to reverse arcs when finding the nearest neighbors
            of the nodes.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsArcCoefficientFieldNumber">
            <summary>Field number for the "savings_arc_coefficient" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsArcCoefficient">
            <summary>
            Coefficient of the cost of the arc for which the saving value is being
            computed:
            Saving(a-->b) = Cost(a-->end) + Cost(start-->b)
                            - savings_arc_coefficient * Cost(a-->b)
            This parameter must be greater than 0, and its default value is 1.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsParallelRoutesFieldNumber">
            <summary>Field number for the "savings_parallel_routes" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsParallelRoutes">
            <summary>
            When true, the routes are built in parallel, sequentially otherwise.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFarthestSeedsRatioFieldNumber">
            <summary>Field number for the "cheapest_insertion_farthest_seeds_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFarthestSeedsRatio">
            <summary>
            Ratio (between 0 and 1) of available vehicles in the model on which
            farthest nodes of the model are inserted as seeds in the
            GlobalCheapestInsertion first solution heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFirstSolutionNeighborsRatioFieldNumber">
            <summary>Field number for the "cheapest_insertion_first_solution_neighbors_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFirstSolutionNeighborsRatio">
             <summary>
             Ratio (in ]0, 1]) of closest non start/end nodes to consider as neighbors
             for each node when creating new insertions in the parallel/sequential
             cheapest insertion heuristic.
             If not overridden, its default value is 1, meaning all neighbors will be
             considered.
             The neighborhood ratio is coupled with the corresponding min_neighbors
             integer, indicating the minimum number of neighbors to consider for each
             node:
             num_closest_neighbors =
                    max(min_neighbors, neighbors_ratio * NUM_NON_START_END_NODES)
             This minimum number of neighbors must be greater or equal to 1, its
             default value.
            
             Neighbors ratio and minimum number of neighbors for the first solution
             heuristic.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFirstSolutionMinNeighborsFieldNumber">
            <summary>Field number for the "cheapest_insertion_first_solution_min_neighbors" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionLsOperatorNeighborsRatioFieldNumber">
            <summary>Field number for the "cheapest_insertion_ls_operator_neighbors_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionLsOperatorNeighborsRatio">
            <summary>
            Neighbors ratio and minimum number of neighbors for the heuristic when used
            in a local search operator (see
            local_search_operators.use_global_cheapest_insertion_path_lns and
            local_search_operators.use_global_cheapest_insertion_chain_lns below).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionLsOperatorMinNeighborsFieldNumber">
            <summary>Field number for the "cheapest_insertion_ls_operator_min_neighbors" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFirstSolutionUseNeighborsRatioForInitializationFieldNumber">
            <summary>Field number for the "cheapest_insertion_first_solution_use_neighbors_ratio_for_initialization" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFirstSolutionUseNeighborsRatioForInitialization">
            <summary>
            Whether or not to only consider closest neighbors when initializing the
            assignment for the first solution.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionAddUnperformedEntriesFieldNumber">
            <summary>Field number for the "cheapest_insertion_add_unperformed_entries" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionAddUnperformedEntries">
            <summary>
            Whether or not to consider entries making the nodes/pairs unperformed in
            the GlobalCheapestInsertion heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LocalCheapestInsertionPickupDeliveryStrategyFieldNumber">
            <summary>Field number for the "local_cheapest_insertion_pickup_delivery_strategy" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LocalCheapestInsertionPickupDeliveryStrategy">
            <summary>
            Choice of insertion strategy for pickup/delivery pairs, used in local
            cheapest insertion, both first solution heuristic and LNS.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LocalCheapestCostInsertionPickupDeliveryStrategyFieldNumber">
            <summary>Field number for the "local_cheapest_cost_insertion_pickup_delivery_strategy" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LocalCheapestCostInsertionPickupDeliveryStrategy">
            <summary>
            Choice of insertion strategy for pickup/delivery pairs, used in local
            cheapest cost insertion, both first solution heuristic and LNS.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ChristofidesUseMinimumMatchingFieldNumber">
            <summary>Field number for the "christofides_use_minimum_matching" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ChristofidesUseMinimumMatching">
            <summary>
            If true use minimum matching instead of minimal matching in the
            Christofides algorithm.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.FirstSolutionOptimizationPeriodFieldNumber">
            <summary>Field number for the "first_solution_optimization_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.FirstSolutionOptimizationPeriod">
            <summary>
            If non zero, a period p indicates that every p node insertions or additions
            to a path, an optimization of the current partial solution will be
            performed. As of 12/2023:
            - this requires that a secondary routing model has been passed to the main
              one,
            - this is only supported by LOCAL_CHEAPEST_INSERTION and
            LOCAL_CHEAPEST_COST_INSERTION.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LocalSearchOperatorsFieldNumber">
            <summary>Field number for the "local_search_operators" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LsOperatorNeighborsRatioFieldNumber">
            <summary>Field number for the "ls_operator_neighbors_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LsOperatorNeighborsRatio">
            <summary>
            Neighbors ratio and minimum number of neighbors considered in local
            search operators (see cheapest_insertion_first_solution_neighbors_ratio
            and cheapest_insertion_first_solution_min_neighbors for more information).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LsOperatorMinNeighborsFieldNumber">
            <summary>Field number for the "ls_operator_min_neighbors" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseMultiArmedBanditConcatenateOperatorsFieldNumber">
            <summary>Field number for the "use_multi_armed_bandit_concatenate_operators" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseMultiArmedBanditConcatenateOperators">
            <summary>
            If true, the solver will use multi-armed bandit concatenate operators. It
            dynamically chooses the next neighbor operator in order to get the best
            objective improvement.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.MultiArmedBanditCompoundOperatorMemoryCoefficientFieldNumber">
            <summary>Field number for the "multi_armed_bandit_compound_operator_memory_coefficient" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.MultiArmedBanditCompoundOperatorMemoryCoefficient">
            <summary>
            Memory coefficient related to the multi-armed bandit compound operator.
            Sets how much the objective improvement of previous accepted neighbors
            influence the current average improvement.
            This parameter should be between 0 and 1.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.MultiArmedBanditCompoundOperatorExplorationCoefficientFieldNumber">
            <summary>Field number for the "multi_armed_bandit_compound_operator_exploration_coefficient" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.MultiArmedBanditCompoundOperatorExplorationCoefficient">
            <summary>
            Positive parameter defining the exploration coefficient of the multi-armed
            bandit compound operator. Sets how often we explore rarely used and
            unsuccessful in the past operators
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.RelocateExpensiveChainNumArcsToConsiderFieldNumber">
            <summary>Field number for the "relocate_expensive_chain_num_arcs_to_consider" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.RelocateExpensiveChainNumArcsToConsider">
            <summary>
            Number of expensive arcs to consider cutting in the RelocateExpensiveChain
            neighborhood operator (see
            LocalSearchNeighborhoodOperators.use_relocate_expensive_chain()).
            This parameter must be greater than 2.
            NOTE(user): The number of neighbors generated by the operator for
            relocate_expensive_chain_num_arcs_to_consider = K is around
            K*(K-1)/2 * number_of_routes * number_of_nodes.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.HeuristicExpensiveChainLnsNumArcsToConsiderFieldNumber">
            <summary>Field number for the "heuristic_expensive_chain_lns_num_arcs_to_consider" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.HeuristicExpensiveChainLnsNumArcsToConsider">
            <summary>
            Number of expensive arcs to consider cutting in the
            FilteredHeuristicExpensiveChainLNSOperator operator.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.HeuristicCloseNodesLnsNumNodesFieldNumber">
            <summary>Field number for the "heuristic_close_nodes_lns_num_nodes" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.HeuristicCloseNodesLnsNumNodes">
            <summary>
            Number of closest nodes to consider for each node during the destruction
            phase of the FilteredHeuristicCloseNodesLNSOperator.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LocalSearchMetaheuristicFieldNumber">
            <summary>Field number for the "local_search_metaheuristic" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LocalSearchMetaheuristic">
            <summary>
            Local search metaheuristics used to guide the search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.GuidedLocalSearchLambdaCoefficientFieldNumber">
            <summary>Field number for the "guided_local_search_lambda_coefficient" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.GuidedLocalSearchLambdaCoefficient">
            <summary>
            These are advanced settings which should not be modified unless you know
            what you are doing.
            Lambda coefficient used to penalize arc costs when GUIDED_LOCAL_SEARCH is
            used. Must be positive.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.GuidedLocalSearchResetPenaltiesOnNewBestSolutionFieldNumber">
            <summary>Field number for the "guided_local_search_reset_penalties_on_new_best_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.GuidedLocalSearchResetPenaltiesOnNewBestSolution">
            <summary>
            Whether to reset penalties when a new best solution is found. The effect is
            that a greedy descent is started before the next penalization phase.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseDepthFirstSearchFieldNumber">
            <summary>Field number for the "use_depth_first_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseDepthFirstSearch">
             <summary>
             --- Search control ---
            
             If true, the solver should use depth-first search rather than local search
             to solve the problem.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseCpFieldNumber">
            <summary>Field number for the "use_cp" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseCp">
            <summary>
            If true, use the CP solver to find a solution. Either local or depth-first
            search will be used depending on the value of use_depth_first_search. Will
            be run before the CP-SAT solver (cf. use_cp_sat).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseCpSatFieldNumber">
            <summary>Field number for the "use_cp_sat" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseCpSat">
            <summary>
            If true, use the CP-SAT solver to find a solution. If use_cp is also true,
            the CP-SAT solver will be run after the CP solver if there is time
            remaining and will use the CP solution as a hint for the CP-SAT search.
            As of 5/2019, only TSP models can be solved.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseGeneralizedCpSatFieldNumber">
            <summary>Field number for the "use_generalized_cp_sat" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseGeneralizedCpSat">
            <summary>
            If true, use the CP-SAT solver to find a solution on generalized routing
            model. If use_cp is also true, the CP-SAT solver will be run after the CP
            solver if there is time remaining and will use the CP solution as a hint
            for the CP-SAT search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SatParametersFieldNumber">
            <summary>Field number for the "sat_parameters" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SatParameters">
            <summary>
            If use_cp_sat or use_generalized_cp_sat is true, contains the SAT algorithm
            parameters which will be used.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ReportIntermediateCpSatSolutionsFieldNumber">
            <summary>Field number for the "report_intermediate_cp_sat_solutions" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ReportIntermediateCpSatSolutions">
            <summary>
            If use_cp_sat or use_generalized_cp_sat is true, will report intermediate
            solutions found by CP-SAT to solution listeners.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.FallbackToCpSatSizeThresholdFieldNumber">
            <summary>Field number for the "fallback_to_cp_sat_size_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.FallbackToCpSatSizeThreshold">
            <summary>
            If model.Size() is less than the threshold and that no solution has been
            found, attempt a pass with CP-SAT.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ContinuousSchedulingSolverFieldNumber">
            <summary>Field number for the "continuous_scheduling_solver" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.MixedIntegerSchedulingSolverFieldNumber">
            <summary>Field number for the "mixed_integer_scheduling_solver" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.DisableSchedulingBewareThisMayDegradePerformanceFieldNumber">
            <summary>Field number for the "disable_scheduling_beware_this_may_degrade_performance" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.DisableSchedulingBewareThisMayDegradePerformance">
            <summary>
            Setting this to true completely disables the LP and MIP scheduling in the
            solver. This overrides the 2 SchedulingSolver options above.
            </summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.HasDisableSchedulingBewareThisMayDegradePerformance">
            <summary>Gets whether the "disable_scheduling_beware_this_may_degrade_performance" field is set</summary>
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ClearDisableSchedulingBewareThisMayDegradePerformance">
            <summary>Clears the value of the "disable_scheduling_beware_this_may_degrade_performance" field</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.OptimizationStepFieldNumber">
            <summary>Field number for the "optimization_step" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.OptimizationStep">
            <summary>
            Minimum step by which the solution must be improved in local search. 0
            means "unspecified". If this value is fractional, it will get rounded to
            the nearest integer.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.NumberOfSolutionsToCollectFieldNumber">
            <summary>Field number for the "number_of_solutions_to_collect" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.NumberOfSolutionsToCollect">
            <summary>
            Number of solutions to collect during the search. Corresponds to the best
            solutions found during the search. 0 means "unspecified".
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SolutionLimitFieldNumber">
            <summary>Field number for the "solution_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SolutionLimit">
            <summary>
            -- Search limits --
            Limit to the number of solutions generated during the search. 0 means
            "unspecified".
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.TimeLimitFieldNumber">
            <summary>Field number for the "time_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.TimeLimit">
            <summary>
            Limit to the time spent in the search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LnsTimeLimitFieldNumber">
            <summary>Field number for the "lns_time_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LnsTimeLimit">
            <summary>
            Limit to the time spent in the completion search for each local search
            neighbor.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SecondaryLsTimeLimitRatioFieldNumber">
            <summary>Field number for the "secondary_ls_time_limit_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SecondaryLsTimeLimitRatio">
            <summary>
            Ratio of the overall time limit spent in a secondary LS phase with only
            intra-route and insertion operators, meant to "cleanup" the current
            solution before stopping the search.
            TODO(user): Since these operators are very fast, add a parameter to cap
            the max time allocated for this second phase (e.g.
            Duration max_secondary_ls_time_limit).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ImprovementLimitParametersFieldNumber">
            <summary>Field number for the "improvement_limit_parameters" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ImprovementLimitParameters">
            <summary>
            The improvement search limit is added to the solver if the following
            parameters are set.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseFullPropagationFieldNumber">
            <summary>Field number for the "use_full_propagation" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseFullPropagation">
             <summary>
             --- Propagation control ---
             These are advanced settings which should not be modified unless you know
             what you are doing.
            
             Use constraints with full propagation in routing model (instead of 'light'
             propagation only). Full propagation is only necessary when using
             depth-first search or for models which require strong propagation to
             finalize the value of secondary variables.
             Changing this setting to true will slow down the search in most cases and
             increase memory consumption in all cases.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogSearchFieldNumber">
            <summary>Field number for the "log_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogSearch">
             <summary>
             --- Miscellaneous ---
             Some of these are advanced settings which should not be modified unless you
             know what you are doing.
            
             Activates search logging. For each solution found during the search, the
             following will be displayed: its objective value, the maximum objective
             value since the beginning of the search, the elapsed time since the
             beginning of the search, the number of branches explored in the search
             tree, the number of failures in the search tree, the depth of the search
             tree, the number of local search neighbors explored, the number of local
             search neighbors filtered by local search filters, the number of local
             search neighbors accepted, the total memory used and the percentage of the
             search done.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogCostScalingFactorFieldNumber">
            <summary>Field number for the "log_cost_scaling_factor" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogCostScalingFactor">
            <summary>
            In logs, cost values will be scaled and offset by the given values in the
            following way: log_cost_scaling_factor * (cost + log_cost_offset)
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogCostOffsetFieldNumber">
            <summary>Field number for the "log_cost_offset" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogTagFieldNumber">
            <summary>Field number for the "log_tag" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogTag">
            <summary>
            In logs, this tag will be appended to each line corresponding to a new
            solution. Useful to sort out logs when several solves are run in parallel.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseIteratedLocalSearchFieldNumber">
            <summary>Field number for the "use_iterated_local_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseIteratedLocalSearch">
            <summary>
            Whether the solver should use an Iterated Local Search approach to solve
            the problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.IteratedLocalSearchParametersFieldNumber">
            <summary>Field number for the "iterated_local_search_parameters" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.IteratedLocalSearchParameters">
            <summary>
            Iterated Local Search parameters.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types">
            <summary>Container for nested types declared in the RoutingSearchParameters message type.</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.PairInsertionStrategy">
            <summary>
            In insertion-based heuristics, describes what positions must be considered
            when inserting a pickup/delivery pair, and in what order they are
            considered.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.PairInsertionStrategy.Automatic">
            <summary>
            Let the solver decide the set of positions and its ordering.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.PairInsertionStrategy.BestPickupThenBestDelivery">
            <summary>
            Consider all positions, by increasing (cost(pickup), cost(delivery)).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.PairInsertionStrategy.BestPickupDeliveryPair">
            <summary>
            Consider all positions, by increasing by cost(pickup) + cost(delivery).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.PairInsertionStrategy.BestPickupDeliveryPairMultitour">
            <summary>
            Only consider insertion positions that are compatible with the multitour
            property, meaning a series of pickups may only start when the vehicle
            is not carrying any delivery. This setting is designed to explore much
            less possibilities than the full BEST_PICKUP_DELIVERY_PAIR.
            Order by increasing by cost(pickup) + cost(delivery).
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.SchedulingSolver">
            <summary>
            Underlying solver to use in dimension scheduling, respectively for
            continuous and mixed models.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators">
            <summary>
            Local search neighborhood operators used to build a solutions neighborhood.
            Next ID: 35
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateFieldNumber">
            <summary>Field number for the "use_relocate" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocate">
            <summary>
            --- Inter-route operators ---
            Operator which moves a single node to another position.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 -> 5
            (where (1, 5) are first and last nodes of the path and can therefore not
            be moved):
              1 ->  3  -> [2] ->  4  -> 5
              1 ->  3  ->  4  -> [2] -> 5
              1 ->  2  ->  4  -> [3] -> 5
              1 -> [4] ->  2  ->  3  -> 5
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocatePairFieldNumber">
            <summary>Field number for the "use_relocate_pair" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocatePair">
            <summary>
            Operator which moves a pair of pickup and delivery nodes to another
            position where the first node of the pair must be before the second node
            on the same path. Compared to the light_relocate_pair operator, tries all
            possible positions of insertion of a pair (not only after another pair).
            Possible neighbors for the path 1 -> A -> B -> 2 -> 3 (where (1, 3) are
            first and last nodes of the path and can therefore not be moved, and
            (A, B) is a pair of nodes):
              1 -> [A] ->  2  -> [B] -> 3
              1 ->  2  -> [A] -> [B] -> 3
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLightRelocatePairFieldNumber">
            <summary>Field number for the "use_light_relocate_pair" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLightRelocatePair">
            <summary>
            Operator which moves a pair of pickup and delivery nodes after another
            pair.
            Possible neighbors for paths 1 -> A -> B -> 2, 3 -> C -> D -> 4 (where
            (1, 2) and (3, 4) are first and last nodes of paths and can therefore not
            be moved, and (A, B) and (C, D) are pair of nodes):
              1 -> 2, 3 -> C -> [A] -> D -> [B] -> 4
              1 -> A -> [C] -> B -> [D] -> 2, 3 -> 4
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateNeighborsFieldNumber">
            <summary>Field number for the "use_relocate_neighbors" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateNeighbors">
            <summary>
            Relocate neighborhood which moves chains of neighbors.
            The operator starts by relocating a node n after a node m, then continues
            moving nodes which were after n as long as the "cost" added is less than
            the "cost" of the arc (m, n). If the new chain doesn't respect the domain
            of next variables, it will try reordering the nodes until it finds a
            valid path.
            Possible neighbors for path 1 -> A -> B -> C -> D -> E -> 2 (where (1, 2)
            are first and last nodes of the path and can therefore not be moved, A
            must be performed before B, and A, D and E are located at the same
            place):
            1 -> A -> C -> [B] -> D -> E -> 2
            1 -> A -> C -> D -> [B] -> E -> 2
            1 -> A -> C -> D -> E -> [B] -> 2
            1 -> A -> B -> D -> [C] -> E -> 2
            1 -> A -> B -> D -> E -> [C] -> 2
            1 -> A -> [D] -> [E] -> B -> C -> 2
            1 -> A -> B -> [D] -> [E] ->  C -> 2
            1 -> A -> [E] -> B -> C -> D -> 2
            1 -> A -> B -> [E] -> C -> D -> 2
            1 -> A -> B -> C -> [E] -> D -> 2
            This operator is extremely useful to move chains of nodes which are
            located at the same place (for instance nodes part of a same stop).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateSubtripFieldNumber">
            <summary>Field number for the "use_relocate_subtrip" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateSubtrip">
             <summary>
             Relocate neighborhood that moves subpaths all pickup and delivery
             pairs have both pickup and delivery inside the subpath or both outside
             the subpath. For instance, for given paths:
             0 -> A -> B -> A' -> B' -> 5 -> 6 -> 8
             7 -> 9
             Pairs (A,A') and (B,B') are interleaved, so the expected neighbors are:
             0 -> 5 -> A -> B -> A' -> B' -> 6 -> 8
             7 -> 9
            
             0 -> 5 -> 6 -> A -> B -> A' -> B' -> 8
             7 -> 9
            
             0 -> 5 -> 6 -> 8
             7 -> A -> B -> A' -> B' -> 9
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExchangeFieldNumber">
            <summary>Field number for the "use_exchange" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExchange">
            <summary>
            Operator which exchanges the positions of two nodes.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 -> 5
            (where (1, 5) are first and last nodes of the path and can therefore not
            be moved):
              1 -> [3] -> [2] ->  4  -> 5
              1 -> [4] ->  3  -> [2] -> 5
              1 ->  2  -> [4] -> [3] -> 5
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExchangePairFieldNumber">
            <summary>Field number for the "use_exchange_pair" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExchangePair">
            <summary>
            Operator which exchanges the positions of two pair of nodes. Pairs
            correspond to the pickup and delivery pairs defined in the routing model.
            Possible neighbor for the paths
            1 -> A -> B -> 2 -> 3 and 4 -> C -> D -> 5
            (where (1, 3) and (4, 5) are first and last nodes of the paths and can
            therefore not be moved, and (A, B) and (C,D) are pairs of nodes):
              1 -> [C] ->  [D] -> 2 -> 3, 4 -> [A] -> [B] -> 5
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExchangeSubtripFieldNumber">
            <summary>Field number for the "use_exchange_subtrip" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExchangeSubtrip">
            <summary>
            Operator which exchanges subtrips associated to two pairs of nodes,
            see use_relocate_subtrip for a definition of subtrips.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseCrossFieldNumber">
            <summary>Field number for the "use_cross" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseCross">
            <summary>
            Operator which cross exchanges the starting chains of 2 paths, including
            exchanging the whole paths.
            First and last nodes are not moved.
            Possible neighbors for the paths 1 -> 2 -> 3 -> 4 -> 5 and 6 -> 7 -> 8
            (where (1, 5) and (6, 8) are first and last nodes of the paths and can
            therefore not be moved):
              1 -> [7] -> 3 -> 4 -> 5  6 -> [2] -> 8
              1 -> [7] -> 4 -> 5       6 -> [2 -> 3] -> 8
              1 -> [7] -> 5            6 -> [2 -> 3 -> 4] -> 8
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseCrossExchangeFieldNumber">
            <summary>Field number for the "use_cross_exchange" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseCrossExchange">
            <summary>
            Not implemented yet. TODO(b/68128619): Implement.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateExpensiveChainFieldNumber">
            <summary>Field number for the "use_relocate_expensive_chain" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateExpensiveChain">
            <summary>
            Operator which detects the relocate_expensive_chain_num_arcs_to_consider
            most expensive arcs on a path, and moves the chain resulting from cutting
            pairs of arcs among these to another position.
            Possible neighbors for paths 1 -> 2 (empty) and
            3 -> A ------> B --> C -----> D -> 4 (where A -> B and C -> D are the 2
            most expensive arcs, and the chain resulting from breaking them is
            B -> C):
              1 -> [B -> C] -> 2     3 -> A -> D -> 4
              1 -> 2      3 -> [B -> C] -> A -> D -> 4
              1 -> 2      3 -> A -> D -> [B -> C] -> 4
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseTwoOptFieldNumber">
            <summary>Field number for the "use_two_opt" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseTwoOpt">
            <summary>
            --- Intra-route operators ---
            Operator which reverses a subchain of a path. It is called TwoOpt
            because it breaks two arcs on the path; resulting paths are called
            two-optimal.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 -> 5
            (where (1, 5) are first and last nodes of the path and can therefore not
            be moved):
              1 -> [3 -> 2] -> 4  -> 5
              1 -> [4 -> 3  -> 2] -> 5
              1 ->  2 -> [4 -> 3] -> 5
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseOrOptFieldNumber">
            <summary>Field number for the "use_or_opt" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseOrOpt">
            <summary>
            Operator which moves sub-chains of a path of length 1, 2 and 3 to another
            position in the same path.
            When the length of the sub-chain is 1, the operator simply moves a node
            to another position.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 -> 5, for a sub-chain
            length of 2 (where (1, 5) are first and last nodes of the path and can
            therefore not be moved):
              1 ->  4 -> [2 -> 3] -> 5
              1 -> [3 -> 4] -> 2  -> 5
            The OR_OPT operator is a limited version of 3-Opt (breaks 3 arcs on a
            path).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLinKernighanFieldNumber">
            <summary>Field number for the "use_lin_kernighan" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLinKernighan">
            <summary>
            Lin-Kernighan operator.
            While the accumulated local gain is positive, performs a 2-OPT or a 3-OPT
            move followed by a series of 2-OPT moves. Returns a neighbor for which
            the global gain is positive.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseTspOptFieldNumber">
            <summary>Field number for the "use_tsp_opt" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseTspOpt">
            <summary>
            Sliding TSP operator.
            Uses an exact dynamic programming algorithm to solve the TSP
            corresponding to path sub-chains.
            For a subchain 1 -> 2 -> 3 -> 4 -> 5 -> 6, solves the TSP on
            nodes A, 2, 3, 4, 5, where A is a merger of nodes 1 and 6 such that
            cost(A,i) = cost(1,i) and cost(i,A) = cost(i,6).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseMakeActiveFieldNumber">
            <summary>Field number for the "use_make_active" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseMakeActive">
            <summary>
            --- Operators on inactive nodes ---
            Operator which inserts an inactive node into a path.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 with 5 inactive
            (where 1 and 4 are first and last nodes of the path) are:
              1 -> [5] ->  2  ->  3  -> 4
              1 ->  2  -> [5] ->  3  -> 4
              1 ->  2  ->  3  -> [5] -> 4
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateAndMakeActiveFieldNumber">
            <summary>Field number for the "use_relocate_and_make_active" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateAndMakeActive">
            <summary>
            Operator which relocates a node while making an inactive one active.
            As of 3/2017, the operator is limited to two kinds of moves:
            - Relocating a node and replacing it by an inactive node.
              Possible neighbor for path 1 -> 5, 2 -> 3 -> 6 and 4 inactive
              (where 1,2 and 5,6 are first and last nodes of paths) is:
              1 -> 3 -> 5, 2 -> 4 -> 6.
            - Relocating a node and inserting an inactive node next to it.
              Possible neighbor for path 1 -> 5, 2 -> 3 -> 6 and 4 inactive
              (where 1,2 and 5,6 are first and last nodes of paths) is:
              1 -> 4 -> 3 -> 5, 2 -> 6.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseMakeInactiveFieldNumber">
            <summary>Field number for the "use_make_inactive" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseMakeInactive">
            <summary>
            Operator which makes path nodes inactive.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 (where 1 and 4 are first
            and last nodes of the path) are:
              1 -> 3 -> 4 with 2 inactive
              1 -> 2 -> 4 with 3 inactive
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseMakeChainInactiveFieldNumber">
            <summary>Field number for the "use_make_chain_inactive" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseMakeChainInactive">
            <summary>
            Operator which makes a "chain" of path nodes inactive.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 (where 1 and 4 are first
            and last nodes of the path) are:
              1 -> 3 -> 4 with 2 inactive
              1 -> 2 -> 4 with 3 inactive
              1 -> 4 with 2 and 3 inactive
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseSwapActiveFieldNumber">
            <summary>Field number for the "use_swap_active" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseSwapActive">
            <summary>
            Operator which replaces an active node by an inactive one.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 with 5 inactive
            (where 1 and 4 are first and last nodes of the path) are:
              1 -> [5] ->  3  -> 4 with 2 inactive
              1 ->  2  -> [5] -> 4 with 3 inactive
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExtendedSwapActiveFieldNumber">
            <summary>Field number for the "use_extended_swap_active" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExtendedSwapActive">
            <summary>
            Operator which makes an inactive node active and an active one inactive.
            It is similar to SwapActiveOperator excepts that it tries to insert the
            inactive node in all possible positions instead of just the position of
            the node made inactive.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 with 5 inactive
            (where 1 and 4 are first and last nodes of the path) are:
              1 -> [5] ->  3  -> 4 with 2 inactive
              1 ->  3  -> [5] -> 4 with 2 inactive
              1 -> [5] ->  2  -> 4 with 3 inactive
              1 ->  2  -> [5] -> 4 with 3 inactive
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseShortestPathSwapActiveFieldNumber">
            <summary>Field number for the "use_shortest_path_swap_active" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseShortestPathSwapActive">
            <summary>
            Swaps active nodes from node alternatives in sequence. Considers chains
            of nodes with alternatives, builds a DAG from the chain, each "layer" of
            the DAG being composed of the set of alternatives of the node at a given
            rank in the chain, fully connected to the next layer. A neighbor is built
            from the shortest path starting from the node before the chain (source),
            through the DAG to the node following the chain.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseNodePairSwapActiveFieldNumber">
            <summary>Field number for the "use_node_pair_swap_active" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseNodePairSwapActive">
            <summary>
            Operator which makes an inactive node active and an active pair of nodes
            inactive OR makes an inactive pair of nodes active and an active node
            inactive.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 with 5 inactive
            (where 1 and 4 are first and last nodes of the path and (2,3) is a pair
            of nodes) are:
              1 -> [5] -> 4 with (2,3) inactive
            Possible neighbors for the path 1 -> 2 -> 3 with (4,5) inactive
            (where 1 and 3 are first and last nodes of the path and (4,5) is a pair
            of nodes) are:
              1 -> [4] -> [5] -> 3 with 2 inactive
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UsePathLnsFieldNumber">
            <summary>Field number for the "use_path_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UsePathLns">
            <summary>
            --- Large neighborhood search operators ---
            Operator which relaxes two sub-chains of three consecutive arcs each.
            Each sub-chain is defined by a start node and the next three arcs. Those
            six arcs are relaxed to build a new neighbor.
            PATH_LNS explores all possible pairs of starting nodes and so defines
            n^2 neighbors, n being the number of nodes.
            Note that the two sub-chains can be part of the same path; they even may
            overlap.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseFullPathLnsFieldNumber">
            <summary>Field number for the "use_full_path_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseFullPathLns">
            <summary>
            Operator which relaxes one entire path and all inactive nodes.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseTspLnsFieldNumber">
            <summary>Field number for the "use_tsp_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseTspLns">
            <summary>
            TSP-base LNS.
            Randomly merges consecutive nodes until n "meta"-nodes remain and solves
            the corresponding TSP.
            This defines an "unlimited" neighborhood which must be stopped by search
            limits. To force diversification, the operator iteratively forces each
            node to serve as base of a meta-node.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseInactiveLnsFieldNumber">
            <summary>Field number for the "use_inactive_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseInactiveLns">
            <summary>
            Operator which relaxes all inactive nodes and one sub-chain of six
            consecutive arcs. That way the path can be improved by inserting inactive
            nodes or swapping arcs.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseGlobalCheapestInsertionPathLnsFieldNumber">
            <summary>Field number for the "use_global_cheapest_insertion_path_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseGlobalCheapestInsertionPathLns">
            <summary>
            --- LNS-like large neighborhood search operators using heuristics ---
            Operator which makes all nodes on a route unperformed, and reinserts them
            using the GlobalCheapestInsertion heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLocalCheapestInsertionPathLnsFieldNumber">
            <summary>Field number for the "use_local_cheapest_insertion_path_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLocalCheapestInsertionPathLns">
            <summary>
            Same as above but using LocalCheapestInsertion as a heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocatePathGlobalCheapestInsertionInsertUnperformedFieldNumber">
            <summary>Field number for the "use_relocate_path_global_cheapest_insertion_insert_unperformed" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocatePathGlobalCheapestInsertionInsertUnperformed">
            <summary>
            The following operator relocates an entire route to an empty path and
            then tries to insert the unperformed nodes using the global cheapest
            insertion heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseGlobalCheapestInsertionExpensiveChainLnsFieldNumber">
            <summary>Field number for the "use_global_cheapest_insertion_expensive_chain_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseGlobalCheapestInsertionExpensiveChainLns">
            <summary>
            This operator finds heuristic_expensive_chain_lns_num_arcs_to_consider
            most expensive arcs on a route, makes the nodes in between pairs of these
            expensive arcs unperformed, and reinserts them using the
            GlobalCheapestInsertion heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLocalCheapestInsertionExpensiveChainLnsFieldNumber">
            <summary>Field number for the "use_local_cheapest_insertion_expensive_chain_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLocalCheapestInsertionExpensiveChainLns">
            <summary>
            Same as above but using LocalCheapestInsertion as a heuristic for
            insertion.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseGlobalCheapestInsertionCloseNodesLnsFieldNumber">
            <summary>Field number for the "use_global_cheapest_insertion_close_nodes_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseGlobalCheapestInsertionCloseNodesLns">
            <summary>
            The following operator makes a node and its
            heuristic_close_nodes_lns_num_nodes closest neighbors unperformed along
            with each of their corresponding performed pickup/delivery pairs, and
            then reinserts them using the GlobalCheapestInsertion heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLocalCheapestInsertionCloseNodesLnsFieldNumber">
            <summary>Field number for the "use_local_cheapest_insertion_close_nodes_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLocalCheapestInsertionCloseNodesLns">
            <summary>
            Same as above, but insertion positions for nodes are determined by the
            LocalCheapestInsertion heuristic.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.ImprovementSearchLimitParameters">
            <summary>
            Parameters required for the improvement search limit.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.ImprovementSearchLimitParameters.ImprovementRateCoefficientFieldNumber">
            <summary>Field number for the "improvement_rate_coefficient" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.ImprovementSearchLimitParameters.ImprovementRateCoefficient">
            <summary>
            Parameter that regulates exchange rate between objective improvement and
            number of neighbors spent. The smaller the value, the sooner the limit
            stops the search. Must be positive.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.ImprovementSearchLimitParameters.ImprovementRateSolutionsDistanceFieldNumber">
            <summary>Field number for the "improvement_rate_solutions_distance" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.ImprovementSearchLimitParameters.ImprovementRateSolutionsDistance">
            <summary>
            Parameter that specifies the distance between improvements taken into
            consideration for calculating the improvement rate.
            Example: For 5 objective improvements = (10, 8, 6, 4, 2), and the
            solutions_distance parameter of 2, then the improvement_rate will be
            computed for (10, 6), (8, 4), and (6, 2).
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingModelParameters">
            <summary>
            Parameters which have to be set when creating a RoutingModel.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingModelParameters.SolverParametersFieldNumber">
            <summary>Field number for the "solver_parameters" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingModelParameters.SolverParameters">
            <summary>
            Parameters to use in the underlying constraint solver.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingModelParameters.ReduceVehicleCostModelFieldNumber">
            <summary>Field number for the "reduce_vehicle_cost_model" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingModelParameters.ReduceVehicleCostModel">
            <summary>
            Advanced settings.
            If set to true reduction of the underlying constraint model will be
            attempted when all vehicles have exactly the same cost structure. This can
            result in significant speedups.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingModelParameters.MaxCallbackCacheSizeFieldNumber">
            <summary>Field number for the "max_callback_cache_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingModelParameters.MaxCallbackCacheSize">
            <summary>
            Cache callback calls if the number of nodes in the model is less or equal
            to this value.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.SearchLimitReflection">
            <summary>Holder for reflection information generated from ortools/constraint_solver/search_limit.proto</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.SearchLimitReflection.Descriptor">
            <summary>File descriptor for ortools/constraint_solver/search_limit.proto</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RegularLimitParameters">
            <summary>
            A search limit
            The default values for int64 fields is the maxima value, i.e., 2^63-1
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RegularLimitParameters.TimeFieldNumber">
            <summary>Field number for the "time" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RegularLimitParameters.Time">
            <summary>
            TODO(user): Specify the time units or switch to google.Duration proto.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RegularLimitParameters.BranchesFieldNumber">
            <summary>Field number for the "branches" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RegularLimitParameters.FailuresFieldNumber">
            <summary>Field number for the "failures" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RegularLimitParameters.SolutionsFieldNumber">
            <summary>Field number for the "solutions" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RegularLimitParameters.SmartTimeCheckFieldNumber">
            <summary>Field number for the "smart_time_check" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RegularLimitParameters.CumulativeFieldNumber">
            <summary>Field number for the "cumulative" field.</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.SearchMonitorVector.SearchMonitorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.SearchStatsReflection">
            <summary>Holder for reflection information generated from ortools/constraint_solver/search_stats.proto</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.SearchStatsReflection.Descriptor">
            <summary>File descriptor for ortools/constraint_solver/search_stats.proto</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchStatistics">
            <summary>
            Statistics on local search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.FirstSolutionStatisticsFieldNumber">
            <summary>Field number for the "first_solution_statistics" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.FirstSolutionStatistics">
            <summary>
            Statistics for each first solution called during the search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.LocalSearchOperatorStatisticsFieldNumber">
            <summary>Field number for the "local_search_operator_statistics" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.LocalSearchOperatorStatistics">
            <summary>
            Statistics for each operator called during the search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.TotalNumNeighborsFieldNumber">
            <summary>Field number for the "total_num_neighbors" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.TotalNumNeighbors">
            <summary>
            Total number of (filtered/accepted) neighbors created during the search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.TotalNumFilteredNeighborsFieldNumber">
            <summary>Field number for the "total_num_filtered_neighbors" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.TotalNumAcceptedNeighborsFieldNumber">
            <summary>Field number for the "total_num_accepted_neighbors" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.LocalSearchFilterStatisticsFieldNumber">
            <summary>Field number for the "local_search_filter_statistics" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.LocalSearchFilterStatistics">
            <summary>
            Statistics for each filter called during the search.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types">
            <summary>Container for nested types declared in the LocalSearchStatistics message type.</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.FirstSolutionStatistics">
            <summary>
            First solution statistics collected during search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.FirstSolutionStatistics.StrategyFieldNumber">
            <summary>Field number for the "strategy" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.FirstSolutionStatistics.Strategy">
            <summary>
            Name of the strategy used.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.FirstSolutionStatistics.DurationSecondsFieldNumber">
            <summary>Field number for the "duration_seconds" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.FirstSolutionStatistics.DurationSeconds">
            <summary>
            Time spent in the decision builder.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchOperatorStatistics">
            <summary>
            Statistics on local search operators called during the search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchOperatorStatistics.LocalSearchOperatorFieldNumber">
            <summary>Field number for the "local_search_operator" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchOperatorStatistics.LocalSearchOperator">
            <summary>
            Name of the operator.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchOperatorStatistics.NumNeighborsFieldNumber">
            <summary>Field number for the "num_neighbors" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchOperatorStatistics.NumNeighbors">
            <summary>
            Number of neighbors generated by the operator.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchOperatorStatistics.NumFilteredNeighborsFieldNumber">
            <summary>Field number for the "num_filtered_neighbors" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchOperatorStatistics.NumFilteredNeighbors">
            <summary>
            Number of neighbors which were filtered.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchOperatorStatistics.NumAcceptedNeighborsFieldNumber">
            <summary>Field number for the "num_accepted_neighbors" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchOperatorStatistics.NumAcceptedNeighbors">
            <summary>
            Number of neighbors eventually accepted.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchOperatorStatistics.DurationSecondsFieldNumber">
            <summary>Field number for the "duration_seconds" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchOperatorStatistics.DurationSeconds">
            <summary>
            Time spent in the operator.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics">
            <summary>
            Statistics on local search filters called during the search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics.LocalSearchFilterFieldNumber">
            <summary>Field number for the "local_search_filter" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics.LocalSearchFilter">
            <summary>
            Name of the filter.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics.NumCallsFieldNumber">
            <summary>Field number for the "num_calls" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics.NumCalls">
            <summary>
            Number of times the filter was called.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics.NumRejectsFieldNumber">
            <summary>Field number for the "num_rejects" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics.NumRejects">
            <summary>
            Number of times the filter rejected a neighbor.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics.DurationSecondsFieldNumber">
            <summary>Field number for the "duration_seconds" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics.DurationSeconds">
            <summary>
            Time spent in the filter.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics.NumRejectsPerSecondFieldNumber">
            <summary>Field number for the "num_rejects_per_second" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics.NumRejectsPerSecond">
            <summary>
            Number of rejects per second.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics.ContextFieldNumber">
            <summary>Field number for the "context" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.LocalSearchStatistics.Types.LocalSearchFilterStatistics.Context">
            <summary>
            Context within which the filter was called.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.ConstraintSolverStatistics">
            <summary>
            Statistics on the search in the constraint solver.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverStatistics.NumBranchesFieldNumber">
            <summary>Field number for the "num_branches" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverStatistics.NumBranches">
            <summary>
            Number of branches explored.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverStatistics.NumFailuresFieldNumber">
            <summary>Field number for the "num_failures" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverStatistics.NumFailures">
            <summary>
            Number of failures/backtracks.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverStatistics.NumSolutionsFieldNumber">
            <summary>Field number for the "num_solutions" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverStatistics.NumSolutions">
            <summary>
            Number of solutions found.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverStatistics.BytesUsedFieldNumber">
            <summary>Field number for the "bytes_used" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverStatistics.BytesUsed">
            <summary>
            Memory usage of the solver.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverStatistics.DurationSecondsFieldNumber">
            <summary>Field number for the "duration_seconds" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverStatistics.DurationSeconds">
            <summary>
            Total time spent in the solver.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.SearchStatistics">
            <summary>
            Search statistics.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.SearchStatistics.LocalSearchStatisticsFieldNumber">
            <summary>Field number for the "local_search_statistics" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.SearchStatistics.LocalSearchStatistics">
            <summary>
            Local search statistics.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.SearchStatistics.ConstraintSolverStatisticsFieldNumber">
            <summary>Field number for the "constraint_solver_statistics" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.SearchStatistics.ConstraintSolverStatistics">
            <summary>
            Constraint solver statistics.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.SequenceVarVector.SequenceVarVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.SolverParametersReflection">
            <summary>Holder for reflection information generated from ortools/constraint_solver/solver_parameters.proto</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.SolverParametersReflection.Descriptor">
            <summary>File descriptor for ortools/constraint_solver/solver_parameters.proto</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.ConstraintSolverParameters">
            <summary>
            Solver parameters.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.CompressTrailFieldNumber">
            <summary>Field number for the "compress_trail" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.CompressTrail">
            <summary>
            This parameter indicates if the solver should compress the trail
            during the search. No compression means that the solver will be faster,
            but will use more memory.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.TrailBlockSizeFieldNumber">
            <summary>Field number for the "trail_block_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.TrailBlockSize">
            <summary>
            This parameter indicates the default size of a block of the trail.
            Compression applies at the block level.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ArraySplitSizeFieldNumber">
            <summary>Field number for the "array_split_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ArraySplitSize">
            <summary>
            When a sum/min/max operation is applied on a large array, this
            array is recursively split into blocks of size 'array_split_size'.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.StoreNamesFieldNumber">
            <summary>Field number for the "store_names" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.StoreNames">
            <summary>
            This parameters indicates if the solver should store the names of
            the objets it manages.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.NameCastVariablesFieldNumber">
            <summary>Field number for the "name_cast_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.NameCastVariables">
            <summary>
            Create names for cast variables.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.NameAllVariablesFieldNumber">
            <summary>Field number for the "name_all_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.NameAllVariables">
            <summary>
            Should anonymous variables be given a name.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ProfilePropagationFieldNumber">
            <summary>Field number for the "profile_propagation" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ProfilePropagation">
            <summary>
            Activate propagation profiling.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ProfileFileFieldNumber">
            <summary>Field number for the "profile_file" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ProfileFile">
            <summary>
            Export propagation profiling data to file.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ProfileLocalSearchFieldNumber">
            <summary>Field number for the "profile_local_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ProfileLocalSearch">
            <summary>
            Activate local search profiling.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintLocalSearchProfileFieldNumber">
            <summary>Field number for the "print_local_search_profile" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintLocalSearchProfile">
            <summary>
            Print local search profiling data after solving.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.TracePropagationFieldNumber">
            <summary>Field number for the "trace_propagation" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.TracePropagation">
            <summary>
            Activate propagate tracing.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.TraceSearchFieldNumber">
            <summary>Field number for the "trace_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.TraceSearch">
            <summary>
            Trace search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintModelFieldNumber">
            <summary>Field number for the "print_model" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintModel">
            <summary>
            Print the model before solving.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintModelStatsFieldNumber">
            <summary>Field number for the "print_model_stats" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintModelStats">
            <summary>
            Print model statistics before solving.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintAddedConstraintsFieldNumber">
            <summary>Field number for the "print_added_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintAddedConstraints">
            <summary>
            Print added constraints.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.DisableSolveFieldNumber">
            <summary>Field number for the "disable_solve" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseSmallTableFieldNumber">
            <summary>Field number for the "use_small_table" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseSmallTable">
             <summary>
            
             Control the implementation of the table constraint.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseCumulativeEdgeFinderFieldNumber">
            <summary>Field number for the "use_cumulative_edge_finder" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseCumulativeEdgeFinder">
             <summary>
            
             Control the propagation of the cumulative constraint.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseCumulativeTimeTableFieldNumber">
            <summary>Field number for the "use_cumulative_time_table" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseCumulativeTimeTableSyncFieldNumber">
            <summary>Field number for the "use_cumulative_time_table_sync" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseSequenceHighDemandTasksFieldNumber">
            <summary>Field number for the "use_sequence_high_demand_tasks" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseAllPossibleDisjunctionsFieldNumber">
            <summary>Field number for the "use_all_possible_disjunctions" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.MaxEdgeFinderSizeFieldNumber">
            <summary>Field number for the "max_edge_finder_size" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.DiffnUseCumulativeFieldNumber">
            <summary>Field number for the "diffn_use_cumulative" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.DiffnUseCumulative">
             <summary>
            
             Control the propagation of the diffn constraint.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseElementRmqFieldNumber">
            <summary>Field number for the "use_element_rmq" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseElementRmq">
             <summary>
            
             Control the implementation of the element constraint.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.SkipLocallyOptimalPathsFieldNumber">
            <summary>Field number for the "skip_locally_optimal_paths" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.SkipLocallyOptimalPaths">
             <summary>
            
             Skip locally optimal pairs of paths in PathOperators. Setting this
             parameter to true might skip valid neighbors if there are constraints
             linking paths together (such as precedences). In any other case this
             should only speed up the search without omitting any neighbors.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.CheckSolutionPeriodFieldNumber">
            <summary>Field number for the "check_solution_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.CheckSolutionPeriod">
             <summary>
            
             Control the behavior of local search.
             </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.Types">
            <summary>Container for nested types declared in the ConstraintSolverParameters message type.</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.Types.TrailCompression">
             <summary>
            
             Internal parameters of the solver.
             </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.SymmetryBreakerVector.SymmetryBreakerVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.NetDecisionBuilder">
             This class acts as a intermediate step between a c++ decision builder and a
             .Net one. Its main purpose is to catch the .Net application exception
             launched when a failure occurs during the Next() call, and to return
             silently a System.ApplicationException that will propagate the failure back
             to the C++ code.
            
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDecisionBuilder.NextWrapper(Google.OrTools.ConstraintSolver.Solver)">
            This methods wraps the calls to next() and catches fail exceptions.
            It currently catches all application exceptions.
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDecisionBuilder.Next(Google.OrTools.ConstraintSolver.Solver)">
            This is the new method to subclass when defining a .Net decision builder.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.NetDecision">
             This class acts as a intermediate step between a c++ decision and a
             .Net one. Its main purpose is to catch the .Net application
             exception launched when a failure occurs during the
             Apply()/Refute() calls, and to set the ShouldFail() flag on the
             solver that will propagate the failure back to the C++ code.
            
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDecision.ApplyWrapper(Google.OrTools.ConstraintSolver.Solver)">
            This methods wraps the calls to Apply() and catches fail exceptions.
            It currently catches all application exceptions.
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDecision.Apply(Google.OrTools.ConstraintSolver.Solver)">
            This is a new method to subclass when defining a .Net decision.
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDecision.Refute(Google.OrTools.ConstraintSolver.Solver)">
            This is a new method to subclass when defining a .Net decision.
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDemon.RunWrapper(Google.OrTools.ConstraintSolver.Solver)">
            This methods wraps the calls to next() and catches fail exceptions.
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDemon.Run(Google.OrTools.ConstraintSolver.Solver)">
            This is the new method to subclass when defining a .Net decision builder.
        </member>
        <member name="T:Google.OrTools.PDLP.SolveLogReflection">
            <summary>Holder for reflection information generated from ortools/pdlp/solve_log.proto</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLogReflection.Descriptor">
            <summary>File descriptor for ortools/pdlp/solve_log.proto</summary>
        </member>
        <member name="T:Google.OrTools.PDLP.RestartChoice">
            <summary>
            Specifies whether a restart was performed on a given iteration.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.RestartChoice.NoRestart">
            <summary>
            No restart on this iteration.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.RestartChoice.WeightedAverageReset">
            <summary>
            The weighted average of iterates is cleared and reset to the current point.
            Note that from a mathematical perspective this can be equivalently viewed
            as restarting the algorithm but picking the restart point to be the current
            iterate.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.RestartChoice.RestartToAverage">
            <summary>
            The algorithm is restarted at the average of iterates since the last
            restart.
            </summary>
        </member>
        <member name="T:Google.OrTools.PDLP.PointType">
            <summary>
            Identifies the type of point used to compute the fields in a given proto; see
            ConvergenceInformation and InfeasibilityInformation.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointType.CurrentIterate">
            <summary>
            Current iterate (x_k, y_k).
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointType.IterateDifference">
            <summary>
            Difference of iterates (x_{k+1} - x_k, y_{k+1} - y_k).
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointType.AverageIterate">
            <summary>
            Average of iterates since the last restart.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointType.None">
            <summary>
            There is no corresponding point.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointType.PresolverSolution">
            <summary>
            Output of presolver.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointType.FeasibilityPolishingSolution">
            <summary>
            Combined solution from primal and dual feasibility polishing.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationReason.PrimalInfeasible">
            <summary>
            Note in this situation the dual could be either unbounded or infeasible.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationReason.DualInfeasible">
            <summary>
            Note in this situation the primal could be either unbounded or infeasible.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationReason.InvalidProblem">
            <summary>
            Indicates that the solver detected invalid problem data, e.g., inconsistent
            bounds.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationReason.InvalidInitialSolution">
            <summary>
            Indicates that the solver detected that the initial solution that was
            provided was invalid, e.g., wrong size or containing NAN or inf.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationReason.InvalidParameter">
            <summary>
            Indicates that an invalid value for the parameters was detected.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationReason.PrimalOrDualInfeasible">
            <summary>
            Primal or dual infeasibility was detected (e.g. by presolve) but no
            certificate is available.
            </summary>
        </member>
        <member name="T:Google.OrTools.PDLP.QuadraticProgramStats">
            <summary>
            Easy-to-compute statistics for the quadratic program.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.NumVariablesFieldNumber">
            <summary>Field number for the "num_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasNumVariables">
            <summary>Gets whether the "num_variables" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearNumVariables">
            <summary>Clears the value of the "num_variables" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.NumConstraintsFieldNumber">
            <summary>Field number for the "num_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasNumConstraints">
            <summary>Gets whether the "num_constraints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearNumConstraints">
            <summary>Clears the value of the "num_constraints" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ConstraintMatrixColMinLInfNormFieldNumber">
            <summary>Field number for the "constraint_matrix_col_min_l_inf_norm" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.ConstraintMatrixColMinLInfNorm">
            <summary>
            Minimum row and column infinity norms of the constraint matrix. All-zero
            rows and columns are excluded. If the constraint matrix contains no nonzero
            entries, the values returned are 0.0.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasConstraintMatrixColMinLInfNorm">
            <summary>Gets whether the "constraint_matrix_col_min_l_inf_norm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearConstraintMatrixColMinLInfNorm">
            <summary>Clears the value of the "constraint_matrix_col_min_l_inf_norm" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ConstraintMatrixRowMinLInfNormFieldNumber">
            <summary>Field number for the "constraint_matrix_row_min_l_inf_norm" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasConstraintMatrixRowMinLInfNorm">
            <summary>Gets whether the "constraint_matrix_row_min_l_inf_norm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearConstraintMatrixRowMinLInfNorm">
            <summary>Clears the value of the "constraint_matrix_row_min_l_inf_norm" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ConstraintMatrixNumNonzerosFieldNumber">
            <summary>Field number for the "constraint_matrix_num_nonzeros" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.ConstraintMatrixNumNonzeros">
            <summary>
            The number of (finite) nonzero entries in the constraint matrix.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasConstraintMatrixNumNonzeros">
            <summary>Gets whether the "constraint_matrix_num_nonzeros" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearConstraintMatrixNumNonzeros">
            <summary>Clears the value of the "constraint_matrix_num_nonzeros" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ConstraintMatrixAbsMaxFieldNumber">
            <summary>Field number for the "constraint_matrix_abs_max" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.ConstraintMatrixAbsMax">
            <summary>
            Max/min/mean/l2_norm of absolute values of (finite) elements in constraint
            matrix. Explicit zeros are included in the mean, but excluded from the min.
            Note that the maximum absolute value is also equal to the maximal row and
            column infinity norms of the constraint matrix. If the constraint matrix is
            empty, the values returned are 0.0 for the maximum, minimum, and l2_norm,
            and NaN for the average.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasConstraintMatrixAbsMax">
            <summary>Gets whether the "constraint_matrix_abs_max" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearConstraintMatrixAbsMax">
            <summary>Clears the value of the "constraint_matrix_abs_max" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ConstraintMatrixAbsMinFieldNumber">
            <summary>Field number for the "constraint_matrix_abs_min" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasConstraintMatrixAbsMin">
            <summary>Gets whether the "constraint_matrix_abs_min" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearConstraintMatrixAbsMin">
            <summary>Clears the value of the "constraint_matrix_abs_min" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ConstraintMatrixAbsAvgFieldNumber">
            <summary>Field number for the "constraint_matrix_abs_avg" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasConstraintMatrixAbsAvg">
            <summary>Gets whether the "constraint_matrix_abs_avg" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearConstraintMatrixAbsAvg">
            <summary>Clears the value of the "constraint_matrix_abs_avg" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ConstraintMatrixL2NormFieldNumber">
            <summary>Field number for the "constraint_matrix_l2_norm" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasConstraintMatrixL2Norm">
            <summary>Gets whether the "constraint_matrix_l2_norm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearConstraintMatrixL2Norm">
            <summary>Clears the value of the "constraint_matrix_l2_norm" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.CombinedBoundsMaxFieldNumber">
            <summary>Field number for the "combined_bounds_max" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.CombinedBoundsMax">
            <summary>
            Statistics of the combined vector of the constraint lower and upper bounds.
            Given parallel lower and upper bounds vectors, the "combined bounds" vector
            takes the maximum absolute value of each pair of bounds, ignoring all non-
            finite values. The comment in solvers.proto:TerminationCriteria provides an
            example of the combined bounds vector. The min is over the nonzero combined
            bounds. If there are no constraints, the values returned are 0 for the
            maximum, minimum, and l2 norm and NaN for the average.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasCombinedBoundsMax">
            <summary>Gets whether the "combined_bounds_max" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearCombinedBoundsMax">
            <summary>Clears the value of the "combined_bounds_max" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.CombinedBoundsMinFieldNumber">
            <summary>Field number for the "combined_bounds_min" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasCombinedBoundsMin">
            <summary>Gets whether the "combined_bounds_min" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearCombinedBoundsMin">
            <summary>Clears the value of the "combined_bounds_min" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.CombinedBoundsAvgFieldNumber">
            <summary>Field number for the "combined_bounds_avg" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasCombinedBoundsAvg">
            <summary>Gets whether the "combined_bounds_avg" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearCombinedBoundsAvg">
            <summary>Clears the value of the "combined_bounds_avg" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.CombinedBoundsL2NormFieldNumber">
            <summary>Field number for the "combined_bounds_l2_norm" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasCombinedBoundsL2Norm">
            <summary>Gets whether the "combined_bounds_l2_norm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearCombinedBoundsL2Norm">
            <summary>Clears the value of the "combined_bounds_l2_norm" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.CombinedVariableBoundsMaxFieldNumber">
            <summary>Field number for the "combined_variable_bounds_max" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.CombinedVariableBoundsMax">
            <summary>
            Statistics of the combined vector of the variable lower and upper bounds.
            See the comment before `combined_bounds_max` for a description of the
            "combined bounds" vector. The min is over the nonzero combined bounds. If
            there are no variables, the values returned are 0 for the maximum, minimum,
            and l2 norm and NaN for the average.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasCombinedVariableBoundsMax">
            <summary>Gets whether the "combined_variable_bounds_max" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearCombinedVariableBoundsMax">
            <summary>Clears the value of the "combined_variable_bounds_max" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.CombinedVariableBoundsMinFieldNumber">
            <summary>Field number for the "combined_variable_bounds_min" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasCombinedVariableBoundsMin">
            <summary>Gets whether the "combined_variable_bounds_min" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearCombinedVariableBoundsMin">
            <summary>Clears the value of the "combined_variable_bounds_min" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.CombinedVariableBoundsAvgFieldNumber">
            <summary>Field number for the "combined_variable_bounds_avg" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasCombinedVariableBoundsAvg">
            <summary>Gets whether the "combined_variable_bounds_avg" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearCombinedVariableBoundsAvg">
            <summary>Clears the value of the "combined_variable_bounds_avg" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.CombinedVariableBoundsL2NormFieldNumber">
            <summary>Field number for the "combined_variable_bounds_l2_norm" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasCombinedVariableBoundsL2Norm">
            <summary>Gets whether the "combined_variable_bounds_l2_norm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearCombinedVariableBoundsL2Norm">
            <summary>Clears the value of the "combined_variable_bounds_l2_norm" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.VariableBoundGapsNumFiniteFieldNumber">
            <summary>Field number for the "variable_bound_gaps_num_finite" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.VariableBoundGapsNumFinite">
            <summary>
            Number of finite variable bound gaps, which are the elementwise difference
            between the upper and lower bounds on primal feasible solutions.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasVariableBoundGapsNumFinite">
            <summary>Gets whether the "variable_bound_gaps_num_finite" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearVariableBoundGapsNumFinite">
            <summary>Clears the value of the "variable_bound_gaps_num_finite" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.VariableBoundGapsMaxFieldNumber">
            <summary>Field number for the "variable_bound_gaps_max" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.VariableBoundGapsMax">
            <summary>
            Max/min/mean/l2_norm over all finite variable bound gaps. The min excludes
            zero bound gaps (i.e., fixed variables). When there are no finite gaps, the
            values returned are 0 for the maximum, minimum, and l2_norm, and NaN for
            the average.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasVariableBoundGapsMax">
            <summary>Gets whether the "variable_bound_gaps_max" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearVariableBoundGapsMax">
            <summary>Clears the value of the "variable_bound_gaps_max" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.VariableBoundGapsMinFieldNumber">
            <summary>Field number for the "variable_bound_gaps_min" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasVariableBoundGapsMin">
            <summary>Gets whether the "variable_bound_gaps_min" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearVariableBoundGapsMin">
            <summary>Clears the value of the "variable_bound_gaps_min" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.VariableBoundGapsAvgFieldNumber">
            <summary>Field number for the "variable_bound_gaps_avg" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasVariableBoundGapsAvg">
            <summary>Gets whether the "variable_bound_gaps_avg" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearVariableBoundGapsAvg">
            <summary>Clears the value of the "variable_bound_gaps_avg" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.VariableBoundGapsL2NormFieldNumber">
            <summary>Field number for the "variable_bound_gaps_l2_norm" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasVariableBoundGapsL2Norm">
            <summary>Gets whether the "variable_bound_gaps_l2_norm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearVariableBoundGapsL2Norm">
            <summary>Clears the value of the "variable_bound_gaps_l2_norm" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ObjectiveVectorAbsMaxFieldNumber">
            <summary>Field number for the "objective_vector_abs_max" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.ObjectiveVectorAbsMax">
            <summary>
            Statistics of the objective vector. The min is over the nonzero terms.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasObjectiveVectorAbsMax">
            <summary>Gets whether the "objective_vector_abs_max" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearObjectiveVectorAbsMax">
            <summary>Clears the value of the "objective_vector_abs_max" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ObjectiveVectorAbsMinFieldNumber">
            <summary>Field number for the "objective_vector_abs_min" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasObjectiveVectorAbsMin">
            <summary>Gets whether the "objective_vector_abs_min" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearObjectiveVectorAbsMin">
            <summary>Clears the value of the "objective_vector_abs_min" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ObjectiveVectorAbsAvgFieldNumber">
            <summary>Field number for the "objective_vector_abs_avg" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasObjectiveVectorAbsAvg">
            <summary>Gets whether the "objective_vector_abs_avg" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearObjectiveVectorAbsAvg">
            <summary>Clears the value of the "objective_vector_abs_avg" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ObjectiveVectorL2NormFieldNumber">
            <summary>Field number for the "objective_vector_l2_norm" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasObjectiveVectorL2Norm">
            <summary>Gets whether the "objective_vector_l2_norm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearObjectiveVectorL2Norm">
            <summary>Clears the value of the "objective_vector_l2_norm" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ObjectiveMatrixNumNonzerosFieldNumber">
            <summary>Field number for the "objective_matrix_num_nonzeros" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasObjectiveMatrixNumNonzeros">
            <summary>Gets whether the "objective_matrix_num_nonzeros" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearObjectiveMatrixNumNonzeros">
            <summary>Clears the value of the "objective_matrix_num_nonzeros" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ObjectiveMatrixAbsMaxFieldNumber">
            <summary>Field number for the "objective_matrix_abs_max" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.ObjectiveMatrixAbsMax">
            <summary>
            Max/min/mean/l2_norm of absolute values of elements of the objective
            matrix. The min is over nonzero terms. If the objective matrix is empty,
            the returned values are 0.0, 0.0, NaN, and 0.0 respectively.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasObjectiveMatrixAbsMax">
            <summary>Gets whether the "objective_matrix_abs_max" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearObjectiveMatrixAbsMax">
            <summary>Clears the value of the "objective_matrix_abs_max" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ObjectiveMatrixAbsMinFieldNumber">
            <summary>Field number for the "objective_matrix_abs_min" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasObjectiveMatrixAbsMin">
            <summary>Gets whether the "objective_matrix_abs_min" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearObjectiveMatrixAbsMin">
            <summary>Clears the value of the "objective_matrix_abs_min" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ObjectiveMatrixAbsAvgFieldNumber">
            <summary>Field number for the "objective_matrix_abs_avg" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasObjectiveMatrixAbsAvg">
            <summary>Gets whether the "objective_matrix_abs_avg" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearObjectiveMatrixAbsAvg">
            <summary>Clears the value of the "objective_matrix_abs_avg" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.QuadraticProgramStats.ObjectiveMatrixL2NormFieldNumber">
            <summary>Field number for the "objective_matrix_l2_norm" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.QuadraticProgramStats.HasObjectiveMatrixL2Norm">
            <summary>Gets whether the "objective_matrix_l2_norm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.QuadraticProgramStats.ClearObjectiveMatrixL2Norm">
            <summary>Clears the value of the "objective_matrix_l2_norm" field</summary>
        </member>
        <member name="T:Google.OrTools.PDLP.ConvergenceInformation">
            <summary>
            Information measuring how close a candidate is to establishing feasibility
            and optimality; see also TerminationCriteria.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.CandidateTypeFieldNumber">
            <summary>Field number for the "candidate_type" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.CandidateType">
            <summary>
            Type of the candidate point described by this ConvergenceInformation.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasCandidateType">
            <summary>Gets whether the "candidate_type" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearCandidateType">
            <summary>Clears the value of the "candidate_type" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.PrimalObjectiveFieldNumber">
            <summary>Field number for the "primal_objective" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.PrimalObjective">
            <summary>
            The primal objective. The primal need not be feasible.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasPrimalObjective">
            <summary>Gets whether the "primal_objective" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearPrimalObjective">
            <summary>Clears the value of the "primal_objective" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.DualObjectiveFieldNumber">
            <summary>Field number for the "dual_objective" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.DualObjective">
            <summary>
            The dual objective. The dual need not be feasible. The dual objective
            includes the contributions from reduced costs.
            NOTE: The definition of dual_objective changed in OR-tools version 9.8.
            See
            https://developers.google.com/optimization/lp/pdlp_math#reduced_costs_dual_residuals_and_the_corrected_dual_objective
            for details.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasDualObjective">
            <summary>Gets whether the "dual_objective" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearDualObjective">
            <summary>Clears the value of the "dual_objective" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.CorrectedDualObjectiveFieldNumber">
            <summary>Field number for the "corrected_dual_objective" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.CorrectedDualObjective">
            <summary>
            If possible (e.g., when all primal variables have lower and upper bounds),
            a correct dual bound. The value is negative infinity if no corrected dual
            bound is available.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasCorrectedDualObjective">
            <summary>Gets whether the "corrected_dual_objective" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearCorrectedDualObjective">
            <summary>Clears the value of the "corrected_dual_objective" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.LInfPrimalResidualFieldNumber">
            <summary>Field number for the "l_inf_primal_residual" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.LInfPrimalResidual">
            <summary>
            The maximum violation of any primal constraint, i.e., the l_ norm of the
            violations.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasLInfPrimalResidual">
            <summary>Gets whether the "l_inf_primal_residual" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearLInfPrimalResidual">
            <summary>Clears the value of the "l_inf_primal_residual" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.L2PrimalResidualFieldNumber">
            <summary>Field number for the "l2_primal_residual" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.L2PrimalResidual">
            <summary>
            The l_2 norm of the violations of primal constraints.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasL2PrimalResidual">
            <summary>Gets whether the "l2_primal_residual" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearL2PrimalResidual">
            <summary>Clears the value of the "l2_primal_residual" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.LInfComponentwisePrimalResidualFieldNumber">
            <summary>Field number for the "l_inf_componentwise_primal_residual" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.LInfComponentwisePrimalResidual">
            <summary>
            The maximum relative violation of any primal constraint, with an absolute
            offset, i.e., the l_ norm of [violation / (eps_ratio + |bound|)] where
            eps_ratio = eps_optimal_primal_residual_absolute
                      / eps_optimal_primal_residual_relative
            and bound is the violated bound.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasLInfComponentwisePrimalResidual">
            <summary>Gets whether the "l_inf_componentwise_primal_residual" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearLInfComponentwisePrimalResidual">
            <summary>Clears the value of the "l_inf_componentwise_primal_residual" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.LInfDualResidualFieldNumber">
            <summary>Field number for the "l_inf_dual_residual" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.LInfDualResidual">
            <summary>
            The maximum violation of any dual constraint, i.e., the l_ norm of the
            violations.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasLInfDualResidual">
            <summary>Gets whether the "l_inf_dual_residual" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearLInfDualResidual">
            <summary>Clears the value of the "l_inf_dual_residual" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.L2DualResidualFieldNumber">
            <summary>Field number for the "l2_dual_residual" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.L2DualResidual">
            <summary>
            The l_2 norm of the violations of dual constraints.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasL2DualResidual">
            <summary>Gets whether the "l2_dual_residual" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearL2DualResidual">
            <summary>Clears the value of the "l2_dual_residual" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.LInfComponentwiseDualResidualFieldNumber">
            <summary>Field number for the "l_inf_componentwise_dual_residual" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.LInfComponentwiseDualResidual">
            <summary>
            The maximum relative violation of any dual constraint, with an absolute
            offset, i.e., the l_ norm of [violation / (eps_ratio + |objective|)] where
            eps_ratio = eps_optimal_dual_residual_absolute
                      / eps_optimal_dual_residual_relative
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasLInfComponentwiseDualResidual">
            <summary>Gets whether the "l_inf_componentwise_dual_residual" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearLInfComponentwiseDualResidual">
            <summary>Clears the value of the "l_inf_componentwise_dual_residual" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.LInfPrimalVariableFieldNumber">
            <summary>Field number for the "l_inf_primal_variable" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.LInfPrimalVariable">
            <summary>
            The maximum absolute value of the primal variables, i.e., the l_ norm.
            This is useful to detect when the primal iterates are diverging. Divergence
            of the primal variables could be an algorithmic issue, or indicate that the
            dual is infeasible.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasLInfPrimalVariable">
            <summary>Gets whether the "l_inf_primal_variable" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearLInfPrimalVariable">
            <summary>Clears the value of the "l_inf_primal_variable" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.L2PrimalVariableFieldNumber">
            <summary>Field number for the "l2_primal_variable" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.L2PrimalVariable">
            <summary>
            The l_2 norm of the primal variables.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasL2PrimalVariable">
            <summary>Gets whether the "l2_primal_variable" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearL2PrimalVariable">
            <summary>Clears the value of the "l2_primal_variable" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.LInfDualVariableFieldNumber">
            <summary>Field number for the "l_inf_dual_variable" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.LInfDualVariable">
            <summary>
            The maximum absolute value of the dual variables, i.e., the l_ norm. This
            is useful to detect when the dual iterates are diverging. Divergence of the
            dual variables could be an algorithmic issue, or indicate the primal is
            infeasible.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasLInfDualVariable">
            <summary>Gets whether the "l_inf_dual_variable" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearLInfDualVariable">
            <summary>Clears the value of the "l_inf_dual_variable" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.ConvergenceInformation.L2DualVariableFieldNumber">
            <summary>Field number for the "l2_dual_variable" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.L2DualVariable">
            <summary>
            The l_2 norm of the dual variables.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.ConvergenceInformation.HasL2DualVariable">
            <summary>Gets whether the "l2_dual_variable" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.ConvergenceInformation.ClearL2DualVariable">
            <summary>Clears the value of the "l2_dual_variable" field</summary>
        </member>
        <member name="T:Google.OrTools.PDLP.InfeasibilityInformation">
            <summary>
            Information measuring how close a point is to establishing primal or dual
            infeasibility (i.e. has no solution); see also TerminationCriteria.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.InfeasibilityInformation.MaxPrimalRayInfeasibilityFieldNumber">
            <summary>Field number for the "max_primal_ray_infeasibility" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.InfeasibilityInformation.MaxPrimalRayInfeasibility">
            <summary>
            Let x_ray be the algorithm's estimate of the primal extreme ray where x_ray
            is a vector that satisfies the sign constraints for a ray, scaled such that
            its infinity norm is one (the sign constraints are the variable bound
            constraints, with all finite bounds mapped to zero). A simple and typical
            choice of x_ray is x_ray = x / | x |_ where x is the current primal
            iterate projected onto the primal ray sign constraints. For this value
            compute the maximum absolute error in the primal linear program with the
            right hand side set to zero.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.InfeasibilityInformation.HasMaxPrimalRayInfeasibility">
            <summary>Gets whether the "max_primal_ray_infeasibility" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.InfeasibilityInformation.ClearMaxPrimalRayInfeasibility">
            <summary>Clears the value of the "max_primal_ray_infeasibility" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.InfeasibilityInformation.PrimalRayLinearObjectiveFieldNumber">
            <summary>Field number for the "primal_ray_linear_objective" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.InfeasibilityInformation.PrimalRayLinearObjective">
            <summary>
            The value of the linear part of the primal objective (ignoring additive
            constants) evaluated at x_ray, i.e., c' * x_ray where c is the objective
            coefficient vector.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.InfeasibilityInformation.HasPrimalRayLinearObjective">
            <summary>Gets whether the "primal_ray_linear_objective" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.InfeasibilityInformation.ClearPrimalRayLinearObjective">
            <summary>Clears the value of the "primal_ray_linear_objective" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.InfeasibilityInformation.PrimalRayQuadraticNormFieldNumber">
            <summary>Field number for the "primal_ray_quadratic_norm" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.InfeasibilityInformation.PrimalRayQuadraticNorm">
            <summary>
            The l_ norm of the vector resulting from taking the quadratic matrix from
            primal objective and multiplying it by the primal variables. For linear
            programming problems this is zero.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.InfeasibilityInformation.HasPrimalRayQuadraticNorm">
            <summary>Gets whether the "primal_ray_quadratic_norm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.InfeasibilityInformation.ClearPrimalRayQuadraticNorm">
            <summary>Clears the value of the "primal_ray_quadratic_norm" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.InfeasibilityInformation.MaxDualRayInfeasibilityFieldNumber">
            <summary>Field number for the "max_dual_ray_infeasibility" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.InfeasibilityInformation.MaxDualRayInfeasibility">
            <summary>
            Let (y_ray, r_ray) be the algorithm's estimate of the dual and reduced cost
            extreme ray where (y_ray, r_ray) is a vector (satisfying the dual variable
            constraints) scaled such that its infinity norm is one. A simple and
            typical choice of y_ray is (y_ray, r_ray) = (y, r) / max(| y |_, | r |_)
            where y is the current dual iterate and r is the current dual reduced
            costs. Consider the quadratic program we are solving but with the objective
            (both quadratic and linear terms) set to zero. This forms a linear program
            (label this linear program (1)) with no objective. Take the dual of (1) and
            compute the maximum absolute value of the constraint error for
            (y_ray, r_ray) to obtain the value of max_dual_ray_infeasibility.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.InfeasibilityInformation.HasMaxDualRayInfeasibility">
            <summary>Gets whether the "max_dual_ray_infeasibility" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.InfeasibilityInformation.ClearMaxDualRayInfeasibility">
            <summary>Clears the value of the "max_dual_ray_infeasibility" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.InfeasibilityInformation.DualRayObjectiveFieldNumber">
            <summary>Field number for the "dual_ray_objective" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.InfeasibilityInformation.DualRayObjective">
            <summary>
            The objective of the linear program labeled (1) in the previous paragraph.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.InfeasibilityInformation.HasDualRayObjective">
            <summary>Gets whether the "dual_ray_objective" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.InfeasibilityInformation.ClearDualRayObjective">
            <summary>Clears the value of the "dual_ray_objective" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.InfeasibilityInformation.CandidateTypeFieldNumber">
            <summary>Field number for the "candidate_type" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.InfeasibilityInformation.CandidateType">
            <summary>
            Type of the point used to compute the InfeasibilityInformation.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.InfeasibilityInformation.HasCandidateType">
            <summary>Gets whether the "candidate_type" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.InfeasibilityInformation.ClearCandidateType">
            <summary>Clears the value of the "candidate_type" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointMetadata.PointTypeFieldNumber">
            <summary>Field number for the "point_type" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PointMetadata.PointType">
            <summary>
            Type of the point that this metadata corresponds to.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PointMetadata.HasPointType">
            <summary>Gets whether the "point_type" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PointMetadata.ClearPointType">
            <summary>Clears the value of the "point_type" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointMetadata.RandomPrimalProjectionsFieldNumber">
            <summary>Field number for the "random_primal_projections" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PointMetadata.RandomPrimalProjections">
            <summary>
            Projections of the primal solution onto random planes.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointMetadata.RandomDualProjectionsFieldNumber">
            <summary>Field number for the "random_dual_projections" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PointMetadata.RandomDualProjections">
            <summary>
            Projections of the dual solution onto random planes.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointMetadata.ActivePrimalVariableCountFieldNumber">
            <summary>Field number for the "active_primal_variable_count" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PointMetadata.ActivePrimalVariableCount">
            <summary>
            The number of primal variables that are not at their bounds.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PointMetadata.HasActivePrimalVariableCount">
            <summary>Gets whether the "active_primal_variable_count" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PointMetadata.ClearActivePrimalVariableCount">
            <summary>Clears the value of the "active_primal_variable_count" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointMetadata.ActiveDualVariableCountFieldNumber">
            <summary>Field number for the "active_dual_variable_count" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PointMetadata.ActiveDualVariableCount">
            <summary>
            The number of dual variables that are not at their bounds.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PointMetadata.HasActiveDualVariableCount">
            <summary>Gets whether the "active_dual_variable_count" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PointMetadata.ClearActiveDualVariableCount">
            <summary>Clears the value of the "active_dual_variable_count" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointMetadata.ActivePrimalVariableChangeFieldNumber">
            <summary>Field number for the "active_primal_variable_change" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PointMetadata.ActivePrimalVariableChange">
            <summary>
            The number of primal variables that have a different bound status than they
            did at the last restart.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PointMetadata.HasActivePrimalVariableChange">
            <summary>Gets whether the "active_primal_variable_change" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PointMetadata.ClearActivePrimalVariableChange">
            <summary>Clears the value of the "active_primal_variable_change" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PointMetadata.ActiveDualVariableChangeFieldNumber">
            <summary>Field number for the "active_dual_variable_change" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PointMetadata.ActiveDualVariableChange">
            <summary>
            The number of dual variables that have a different bound status than they
            did at the last restart.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PointMetadata.HasActiveDualVariableChange">
            <summary>Gets whether the "active_dual_variable_change" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PointMetadata.ClearActiveDualVariableChange">
            <summary>Clears the value of the "active_dual_variable_change" field</summary>
        </member>
        <member name="T:Google.OrTools.PDLP.IterationStats">
            <summary>
            All values in IterationStats assume that the primal quadratic program is a
            minimization problem and the dual is a maximization problem. Problems should
            be transformed to this form if they are not already in this form. The dual
            vector is defined to be the vector of multipliers on the linear constraints,
            that is, excluding dual multipliers on variable bounds (reduced costs).
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.IterationStats.IterationNumberFieldNumber">
            <summary>Field number for the "iteration_number" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.IterationNumber">
            <summary>
            The iteration number at which these stats were recorded. By convention,
            iteration counts start at 1, and the stats correspond to the solution
            *after* the iteration. Therefore stats from iteration 0 are the stats at
            the starting point.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.HasIterationNumber">
            <summary>Gets whether the "iteration_number" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.IterationStats.ClearIterationNumber">
            <summary>Clears the value of the "iteration_number" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.IterationStats.ConvergenceInformationFieldNumber">
            <summary>Field number for the "convergence_information" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.ConvergenceInformation">
            <summary>
            A set of statistics measuring how close a point is to establishing primal
            and dual feasibility and optimality. This field is repeated since there
            might be several different points that are considered.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.IterationStats.InfeasibilityInformationFieldNumber">
            <summary>Field number for the "infeasibility_information" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.InfeasibilityInformation">
            <summary>
            A set of statistics measuring how close a point is to establishing primal
            or dual infeasibility (i.e., has no solution). This field is repeated since
            there might be several different points that could establish infeasibility.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.IterationStats.PointMetadataFieldNumber">
            <summary>Field number for the "point_metadata" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.PointMetadata">
            <summary>
            Auxiliary statistics for each type of point.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.IterationStats.CumulativeKktMatrixPassesFieldNumber">
            <summary>Field number for the "cumulative_kkt_matrix_passes" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.CumulativeKktMatrixPasses">
             <summary>
             The cumulative number of passes through the KKT matrix since the start of
             the solve. One pass is a multply by the constraint matrix, its transpose
             and the matrix that defines the quadratic part of the objective.
            
             For example, each iteration of mirror saddle prox contributes 2.0 to this
             sum. This is a float because it can include fractional passes through the
             data. For example, in an active set method we may only use a submatrix with
             20% of the nonzeros of the KKT matrix at each iteration in which case 0.2
             would be added to the total.
             </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.HasCumulativeKktMatrixPasses">
            <summary>Gets whether the "cumulative_kkt_matrix_passes" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.IterationStats.ClearCumulativeKktMatrixPasses">
            <summary>Clears the value of the "cumulative_kkt_matrix_passes" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.IterationStats.CumulativeRejectedStepsFieldNumber">
            <summary>Field number for the "cumulative_rejected_steps" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.CumulativeRejectedSteps">
            <summary>
            The total number of rejected steps (e.g., within a line search procedure)
            since the start of the solve.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.HasCumulativeRejectedSteps">
            <summary>Gets whether the "cumulative_rejected_steps" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.IterationStats.ClearCumulativeRejectedSteps">
            <summary>Clears the value of the "cumulative_rejected_steps" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.IterationStats.CumulativeTimeSecFieldNumber">
            <summary>Field number for the "cumulative_time_sec" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.CumulativeTimeSec">
            <summary>
            The amount of time passed since we started solving the problem (see solver
            log `solve_time_sec` which records total time).
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.HasCumulativeTimeSec">
            <summary>Gets whether the "cumulative_time_sec" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.IterationStats.ClearCumulativeTimeSec">
            <summary>Clears the value of the "cumulative_time_sec" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.IterationStats.RestartUsedFieldNumber">
            <summary>Field number for the "restart_used" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.RestartUsed">
            <summary>
            The kind of restart that occurred at this iteration, or NO_RESTART if a
            restart did not occur.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.HasRestartUsed">
            <summary>Gets whether the "restart_used" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.IterationStats.ClearRestartUsed">
            <summary>Clears the value of the "restart_used" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.IterationStats.StepSizeFieldNumber">
            <summary>Field number for the "step_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.StepSize">
            <summary>
            Step size used at this iteration. Note that the step size used for the
            primal update is step_size / primal_weight, while the one used for the dual
            update is step_size * primal_weight.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.HasStepSize">
            <summary>Gets whether the "step_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.IterationStats.ClearStepSize">
            <summary>Clears the value of the "step_size" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.IterationStats.PrimalWeightFieldNumber">
            <summary>Field number for the "primal_weight" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.PrimalWeight">
            <summary>
            Primal weight controlling the relation between primal and dual step sizes.
            See field 'step_size' for a detailed description.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.IterationStats.HasPrimalWeight">
            <summary>Gets whether the "primal_weight" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.IterationStats.ClearPrimalWeight">
            <summary>Clears the value of the "primal_weight" field</summary>
        </member>
        <member name="T:Google.OrTools.PDLP.FeasibilityPolishingDetails">
            <summary>
            Details about one primal feasibility or dual feasibility polishing phase
            within a solve with `use_feasibility_polishing`. See `SolveLog` for
            descriptions of the fields with the same name.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.FeasibilityPolishingDetails.PolishingPhaseTypeFieldNumber">
            <summary>Field number for the "polishing_phase_type" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.FeasibilityPolishingDetails.HasPolishingPhaseType">
            <summary>Gets whether the "polishing_phase_type" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.FeasibilityPolishingDetails.ClearPolishingPhaseType">
            <summary>Clears the value of the "polishing_phase_type" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.FeasibilityPolishingDetails.MainIterationCountFieldNumber">
            <summary>Field number for the "main_iteration_count" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.FeasibilityPolishingDetails.MainIterationCount">
            <summary>
            The iteration count for the main iteration when this feasibility polishing
            phase was triggered.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.FeasibilityPolishingDetails.HasMainIterationCount">
            <summary>Gets whether the "main_iteration_count" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.FeasibilityPolishingDetails.ClearMainIterationCount">
            <summary>Clears the value of the "main_iteration_count" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.FeasibilityPolishingDetails.ParamsFieldNumber">
            <summary>Field number for the "params" field.</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.FeasibilityPolishingDetails.TerminationReasonFieldNumber">
            <summary>Field number for the "termination_reason" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.FeasibilityPolishingDetails.HasTerminationReason">
            <summary>Gets whether the "termination_reason" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.FeasibilityPolishingDetails.ClearTerminationReason">
            <summary>Clears the value of the "termination_reason" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.FeasibilityPolishingDetails.IterationCountFieldNumber">
            <summary>Field number for the "iteration_count" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.FeasibilityPolishingDetails.HasIterationCount">
            <summary>Gets whether the "iteration_count" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.FeasibilityPolishingDetails.ClearIterationCount">
            <summary>Clears the value of the "iteration_count" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.FeasibilityPolishingDetails.SolveTimeSecFieldNumber">
            <summary>Field number for the "solve_time_sec" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.FeasibilityPolishingDetails.HasSolveTimeSec">
            <summary>Gets whether the "solve_time_sec" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.FeasibilityPolishingDetails.ClearSolveTimeSec">
            <summary>Clears the value of the "solve_time_sec" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.FeasibilityPolishingDetails.SolutionStatsFieldNumber">
            <summary>Field number for the "solution_stats" field.</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.FeasibilityPolishingDetails.SolutionTypeFieldNumber">
            <summary>Field number for the "solution_type" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.FeasibilityPolishingDetails.HasSolutionType">
            <summary>Gets whether the "solution_type" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.FeasibilityPolishingDetails.ClearSolutionType">
            <summary>Clears the value of the "solution_type" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.FeasibilityPolishingDetails.IterationStatsFieldNumber">
            <summary>Field number for the "iteration_stats" field.</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.InstanceNameFieldNumber">
            <summary>Field number for the "instance_name" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.InstanceName">
            <summary>
            The name of the optimization problem.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.HasInstanceName">
            <summary>Gets whether the "instance_name" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.SolveLog.ClearInstanceName">
            <summary>Clears the value of the "instance_name" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.ParamsFieldNumber">
            <summary>Field number for the "params" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.Params">
            <summary>
            If solved with PDLP, the parameters for this solve.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.TerminationReasonFieldNumber">
            <summary>Field number for the "termination_reason" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.TerminationReason">
            <summary>
            The reason that the solve terminated.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.HasTerminationReason">
            <summary>Gets whether the "termination_reason" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.SolveLog.ClearTerminationReason">
            <summary>Clears the value of the "termination_reason" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.TerminationStringFieldNumber">
            <summary>Field number for the "termination_string" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.TerminationString">
            <summary>
            Optional extra information about the termination reason.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.HasTerminationString">
            <summary>Gets whether the "termination_string" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.SolveLog.ClearTerminationString">
            <summary>Clears the value of the "termination_string" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.IterationCountFieldNumber">
            <summary>Field number for the "iteration_count" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.IterationCount">
            <summary>
            The total number of iterations during the solve. For a solve with
            `use_feasibility_polishing` this count includes the iterations from
            the feasibility polishing phases.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.HasIterationCount">
            <summary>Gets whether the "iteration_count" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.SolveLog.ClearIterationCount">
            <summary>Clears the value of the "iteration_count" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.PreprocessingTimeSecFieldNumber">
            <summary>Field number for the "preprocessing_time_sec" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.PreprocessingTimeSec">
            <summary>
            Time for preprocessing (everything before iteration 0). This is also
            included in `solve_time_sec`.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.HasPreprocessingTimeSec">
            <summary>Gets whether the "preprocessing_time_sec" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.SolveLog.ClearPreprocessingTimeSec">
            <summary>Clears the value of the "preprocessing_time_sec" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.SolveTimeSecFieldNumber">
            <summary>Field number for the "solve_time_sec" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.SolveTimeSec">
            <summary>
            The runtime of the solve. Note: This should not be used for comparing
            methods unless care is taken to control for noise in runtime measurement.
            For a solve with `use_feasibility_polishing` this count includes the
            iterations from the feasibility polishing phases.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.HasSolveTimeSec">
            <summary>Gets whether the "solve_time_sec" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.SolveLog.ClearSolveTimeSec">
            <summary>Clears the value of the "solve_time_sec" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.SolutionStatsFieldNumber">
            <summary>Field number for the "solution_stats" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.SolutionStats">
            <summary>
            The `IterationStats` for the final iteration of the solver. For a solve
            with `use_feasibility_polishing`, the work metrics (iteration_count,
            cumulative_kkt_matrix_passes, etc.) will include the work done in the
            feasibility polishing phases.
            NOTE: Regardless of preprocessing (i.e. scaling or presolve) the optimality
            or infeasibility information is evaluated with respect to the original
            problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.SolutionTypeFieldNumber">
            <summary>Field number for the "solution_type" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.SolutionType">
            <summary>
            The type of the output point that the solver returned. The quality of the
            point is reported in the corresponding entry of
            solution_stats.convergence_information and/or
            solution_stats.infeasibility_information. If termination_reason is
            TERMINATION_REASON_OPTIMAL, it's guaranteed that the corresponding entry of
            solution_stats.convergence_information satisfies the optimality conditions.
            Similarly, if termination_reason is either
            TERMINATION_REASON_PRIMAL_INFEASIBLE or TERMINATION_REASON_DUAL_INFEASIBLE
            the corresponding entry of solution_stats.infeasibility_information
            satisifes conditions for declaring primal or dual infeasibility,
            respectively.
            If termination_reason is anything else, e.g. TERMINATION_REASON_TIME_LIMIT
            or TERMINATION_REASON_PRIMAL_OR_DUAL_INFEASIBLE, the solution may not
            satisfy the optimality or infeasibility conditions.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.HasSolutionType">
            <summary>Gets whether the "solution_type" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.SolveLog.ClearSolutionType">
            <summary>Clears the value of the "solution_type" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.IterationStatsFieldNumber">
            <summary>Field number for the "iteration_stats" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.IterationStats">
            <summary>
            A history of iteration stats for the solve. The iteration_number fields
            should be in increasing order. The frequency at which these stats should be
            recorded is not specified. This field is "more" optional than the others
            because it often significantly increases the size of the message, and
            because the information may not be available for third-party solvers.
            For a solve with `use_feasibility_polishing`, these iteration stats will
            only reflect the work done in the main iterations (not the feasibility
            polishing phases).
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.OriginalProblemStatsFieldNumber">
            <summary>Field number for the "original_problem_stats" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.OriginalProblemStats">
            <summary>
            Statistics of the original problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.PreprocessedProblemStatsFieldNumber">
            <summary>Field number for the "preprocessed_problem_stats" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.PreprocessedProblemStats">
            <summary>
            Statistics of the problem after preprocessing.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.SolveLog.FeasibilityPolishingDetailsFieldNumber">
            <summary>Field number for the "feasibility_polishing_details" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolveLog.FeasibilityPolishingDetails">
            <summary>
            If solving with `use_feasibility_polishing`, details about the primal and
            dual feasibility polishing phases.
            </summary>
        </member>
        <member name="T:Google.OrTools.PDLP.SolversReflection">
            <summary>Holder for reflection information generated from ortools/pdlp/solvers.proto</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.SolversReflection.Descriptor">
            <summary>File descriptor for ortools/pdlp/solvers.proto</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.OptimalityNorm.LInf">
            <summary>
            The infinity norm.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.OptimalityNorm.L2">
            <summary>
            The Euclidean norm.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.OptimalityNorm.LInfComponentwise">
            <summary>
            The infinity norm of component-wise relative errors offset by the ratio of
            the absolute and relative error tolerances, i.e., the l_ norm of
            [residual / (eps_ratio + |bound|)], where eps_ratio =
            eps_optimal_{X}_residual_absolute / eps_optimal_{X}_residual_relative
            where {X} is either primal or dual, and bound is the corresponding primal
            or dual bound (that is, the violated constraint bound for primal residuals,
            and the objective coefficient for dual residuals).
            Using eps_ratio in this norm means that if the norm is &lt;=
            eps_optimal_{X}_residual_relative, then the residuals satisfy
            residual &lt;= eps_optimal_{X}_residual_absolute
                      + eps_optimal_{X}_residual_relative * |bound|
            </summary>
        </member>
        <member name="T:Google.OrTools.PDLP.TerminationCriteria">
            <summary>
            Relevant readings on infeasibility certificates:
            (1) https://docs.mosek.com/modeling-cookbook/qcqo.html provides references
            explaining why the primal rays imply dual infeasibility and dual rays imply
            primal infeasibility.
            (2) The termination criteria for Mosek's linear programming optimizer
            https://docs.mosek.com/9.0/pythonfusion/solving-linear.html.
            (3) The termination criteria for OSQP is in section 3.3 of
            https://web.stanford.edu/~boyd/papers/pdf/osqp.pdf.
            (4) The termination criteria for SCS is in section 3.5 of
            https://arxiv.org/pdf/1312.3039.pdf.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.OptimalityNormFieldNumber">
            <summary>Field number for the "optimality_norm" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.OptimalityNorm">
            <summary>
            The norm that we are measuring the optimality criteria in.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.HasOptimalityNorm">
            <summary>Gets whether the "optimality_norm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.ClearOptimalityNorm">
            <summary>Clears the value of the "optimality_norm" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.SimpleOptimalityCriteriaFieldNumber">
            <summary>Field number for the "simple_optimality_criteria" field.</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.DetailedOptimalityCriteriaFieldNumber">
            <summary>Field number for the "detailed_optimality_criteria" field.</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.EpsOptimalAbsoluteFieldNumber">
            <summary>Field number for the "eps_optimal_absolute" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.EpsOptimalAbsolute">
            <summary>
            Absolute tolerance on primal residual, dual residual, and the objective
            gap.
            Deprecated, use simple_optimality_criteria instead.
            TODO(b/241462829) delete this deprecated field.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.HasEpsOptimalAbsolute">
            <summary>Gets whether the "eps_optimal_absolute" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.ClearEpsOptimalAbsolute">
            <summary>Clears the value of the "eps_optimal_absolute" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.EpsOptimalRelativeFieldNumber">
            <summary>Field number for the "eps_optimal_relative" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.EpsOptimalRelative">
            <summary>
            Relative tolerance on primal residual, dual residual, and the objective
            gap.
            Deprecated, use simple_optimality_criteria instead.
            TODO(b/241462829) delete this deprecated field.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.HasEpsOptimalRelative">
            <summary>Gets whether the "eps_optimal_relative" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.ClearEpsOptimalRelative">
            <summary>Clears the value of the "eps_optimal_relative" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.EpsPrimalInfeasibleFieldNumber">
            <summary>Field number for the "eps_primal_infeasible" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.EpsPrimalInfeasible">
            <summary>
            If the following two conditions hold we say that we have obtained an
            approximate dual ray, which is an approximate certificate of primal
            infeasibility.
            (1) dual_ray_objective > 0,
            (2) max_dual_ray_infeasibility / dual_ray_objective &lt;=
            eps_primal_infeasible.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.HasEpsPrimalInfeasible">
            <summary>Gets whether the "eps_primal_infeasible" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.ClearEpsPrimalInfeasible">
            <summary>Clears the value of the "eps_primal_infeasible" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.EpsDualInfeasibleFieldNumber">
            <summary>Field number for the "eps_dual_infeasible" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.EpsDualInfeasible">
            <summary>
            If the following three conditions hold we say we have obtained an
            approximate primal ray, which is an approximate certificate of dual
            infeasibility.
            (1) primal_ray_linear_objective &lt; 0,
            (2) max_primal_ray_infeasibility / (-primal_ray_linear_objective) &lt;=
            eps_dual_infeasible
            (3) primal_ray_quadratic_norm / (-primal_ray_linear_objective) &lt;=
            eps_dual_infeasible.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.HasEpsDualInfeasible">
            <summary>Gets whether the "eps_dual_infeasible" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.ClearEpsDualInfeasible">
            <summary>Clears the value of the "eps_dual_infeasible" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.TimeSecLimitFieldNumber">
            <summary>Field number for the "time_sec_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.TimeSecLimit">
            <summary>
            If termination_reason = TERMINATION_REASON_TIME_LIMIT then the solver has
            taken at least time_sec_limit time.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.HasTimeSecLimit">
            <summary>Gets whether the "time_sec_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.ClearTimeSecLimit">
            <summary>Clears the value of the "time_sec_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.IterationLimitFieldNumber">
            <summary>Field number for the "iteration_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.IterationLimit">
            <summary>
            If termination_reason = TERMINATION_REASON_ITERATION_LIMIT then the solver
            has taken at least iterations_limit iterations.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.HasIterationLimit">
            <summary>Gets whether the "iteration_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.ClearIterationLimit">
            <summary>Clears the value of the "iteration_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.KktMatrixPassLimitFieldNumber">
            <summary>Field number for the "kkt_matrix_pass_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.KktMatrixPassLimit">
            <summary>
            If termination_reason = TERMINATION_REASON_KKT_MATRIX_PASS_LIMIT then
            cumulative_kkt_matrix_passes is at least kkt_pass_limit.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.HasKktMatrixPassLimit">
            <summary>Gets whether the "kkt_matrix_pass_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.ClearKktMatrixPassLimit">
            <summary>Clears the value of the "kkt_matrix_pass_limit" field</summary>
        </member>
        <member name="T:Google.OrTools.PDLP.TerminationCriteria.OptimalityCriteriaOneofCase">
            <summary>Enum of possible cases for the "optimality_criteria" oneof.</summary>
        </member>
        <member name="T:Google.OrTools.PDLP.TerminationCriteria.Types">
            <summary>Container for nested types declared in the TerminationCriteria message type.</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.Types.SimpleOptimalityCriteria.EpsOptimalAbsoluteFieldNumber">
            <summary>Field number for the "eps_optimal_absolute" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.SimpleOptimalityCriteria.EpsOptimalAbsolute">
            <summary>
            Absolute tolerance on the primal residual, dual residual, and objective
            gap.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.SimpleOptimalityCriteria.HasEpsOptimalAbsolute">
            <summary>Gets whether the "eps_optimal_absolute" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.Types.SimpleOptimalityCriteria.ClearEpsOptimalAbsolute">
            <summary>Clears the value of the "eps_optimal_absolute" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.Types.SimpleOptimalityCriteria.EpsOptimalRelativeFieldNumber">
            <summary>Field number for the "eps_optimal_relative" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.SimpleOptimalityCriteria.EpsOptimalRelative">
            <summary>
            Relative tolerance on the primal residual, dual residual, and objective
            gap.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.SimpleOptimalityCriteria.HasEpsOptimalRelative">
            <summary>Gets whether the "eps_optimal_relative" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.Types.SimpleOptimalityCriteria.ClearEpsOptimalRelative">
            <summary>Clears the value of the "eps_optimal_relative" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.EpsOptimalPrimalResidualAbsoluteFieldNumber">
            <summary>Field number for the "eps_optimal_primal_residual_absolute" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.EpsOptimalPrimalResidualAbsolute">
            <summary>
            Absolute tolerance on the primal residual.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.HasEpsOptimalPrimalResidualAbsolute">
            <summary>Gets whether the "eps_optimal_primal_residual_absolute" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.ClearEpsOptimalPrimalResidualAbsolute">
            <summary>Clears the value of the "eps_optimal_primal_residual_absolute" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.EpsOptimalPrimalResidualRelativeFieldNumber">
            <summary>Field number for the "eps_optimal_primal_residual_relative" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.EpsOptimalPrimalResidualRelative">
            <summary>
            Relative tolerance on the primal residual.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.HasEpsOptimalPrimalResidualRelative">
            <summary>Gets whether the "eps_optimal_primal_residual_relative" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.ClearEpsOptimalPrimalResidualRelative">
            <summary>Clears the value of the "eps_optimal_primal_residual_relative" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.EpsOptimalDualResidualAbsoluteFieldNumber">
            <summary>Field number for the "eps_optimal_dual_residual_absolute" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.EpsOptimalDualResidualAbsolute">
            <summary>
            Absolute tolerance on the dual residual.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.HasEpsOptimalDualResidualAbsolute">
            <summary>Gets whether the "eps_optimal_dual_residual_absolute" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.ClearEpsOptimalDualResidualAbsolute">
            <summary>Clears the value of the "eps_optimal_dual_residual_absolute" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.EpsOptimalDualResidualRelativeFieldNumber">
            <summary>Field number for the "eps_optimal_dual_residual_relative" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.EpsOptimalDualResidualRelative">
            <summary>
            Relative tolerance on the dual residual.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.HasEpsOptimalDualResidualRelative">
            <summary>Gets whether the "eps_optimal_dual_residual_relative" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.ClearEpsOptimalDualResidualRelative">
            <summary>Clears the value of the "eps_optimal_dual_residual_relative" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.EpsOptimalObjectiveGapAbsoluteFieldNumber">
            <summary>Field number for the "eps_optimal_objective_gap_absolute" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.EpsOptimalObjectiveGapAbsolute">
            <summary>
            Absolute tolerance on the objective gap.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.HasEpsOptimalObjectiveGapAbsolute">
            <summary>Gets whether the "eps_optimal_objective_gap_absolute" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.ClearEpsOptimalObjectiveGapAbsolute">
            <summary>Clears the value of the "eps_optimal_objective_gap_absolute" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.EpsOptimalObjectiveGapRelativeFieldNumber">
            <summary>Field number for the "eps_optimal_objective_gap_relative" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.EpsOptimalObjectiveGapRelative">
            <summary>
            Relative tolerance on the objective gap.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.HasEpsOptimalObjectiveGapRelative">
            <summary>Gets whether the "eps_optimal_objective_gap_relative" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.TerminationCriteria.Types.DetailedOptimalityCriteria.ClearEpsOptimalObjectiveGapRelative">
            <summary>Clears the value of the "eps_optimal_objective_gap_relative" field</summary>
        </member>
        <member name="T:Google.OrTools.PDLP.AdaptiveLinesearchParams">
            <summary>
            At the end of each iteration, regardless of whether the step was accepted
            or not, the adaptive rule updates the step_size as the minimum of two
            potential step sizes defined by the following two exponents.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.AdaptiveLinesearchParams.StepSizeReductionExponentFieldNumber">
            <summary>Field number for the "step_size_reduction_exponent" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.AdaptiveLinesearchParams.StepSizeReductionExponent">
            <summary>
            The step size reduction exponent defines a step size given by
            (1 - (total_steps_attempted + 1)^(-step_size_reduction_exponent)) *
            step_size_limit where step_size_limit is the maximum allowed step size at
            the current iteration. This should be between 0.1 and 1.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.AdaptiveLinesearchParams.HasStepSizeReductionExponent">
            <summary>Gets whether the "step_size_reduction_exponent" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.AdaptiveLinesearchParams.ClearStepSizeReductionExponent">
            <summary>Clears the value of the "step_size_reduction_exponent" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.AdaptiveLinesearchParams.StepSizeGrowthExponentFieldNumber">
            <summary>Field number for the "step_size_growth_exponent" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.AdaptiveLinesearchParams.StepSizeGrowthExponent">
            <summary>
            The step size growth exponent defines a step size given by (1 +
            (total_steps_attempted + 1)^(-step_size_growth_exponent)) * step_size_.
            This should be between 0.1 and 1.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.AdaptiveLinesearchParams.HasStepSizeGrowthExponent">
            <summary>Gets whether the "step_size_growth_exponent" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.AdaptiveLinesearchParams.ClearStepSizeGrowthExponent">
            <summary>Clears the value of the "step_size_growth_exponent" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.MalitskyPockParams.StepSizeDownscalingFactorFieldNumber">
            <summary>Field number for the "step_size_downscaling_factor" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.MalitskyPockParams.StepSizeDownscalingFactor">
            <summary>
            At every inner iteration the algorithm can decide to accept the step size
            or to update it to step_size = step_size_downscaling_factor * step_size.
            This parameter should lie between 0 and 1. The default is the value used in
            Malitsky and Pock (2016).
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.MalitskyPockParams.HasStepSizeDownscalingFactor">
            <summary>Gets whether the "step_size_downscaling_factor" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.MalitskyPockParams.ClearStepSizeDownscalingFactor">
            <summary>Clears the value of the "step_size_downscaling_factor" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.MalitskyPockParams.LinesearchContractionFactorFieldNumber">
            <summary>Field number for the "linesearch_contraction_factor" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.MalitskyPockParams.LinesearchContractionFactor">
            <summary>
            Contraction factor used in the linesearch condition of Malitsky and Pock.
            A step size is accepted if primal_weight * primal_stepsize *
            norm(constraint_matrix' * (next_dual - current_dual)) is less
            than linesearch_contraction_factor * norm(next_dual - current_dual).
            The default is the value used in Malitsky and Pock (2016).
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.MalitskyPockParams.HasLinesearchContractionFactor">
            <summary>Gets whether the "linesearch_contraction_factor" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.MalitskyPockParams.ClearLinesearchContractionFactor">
            <summary>Clears the value of the "linesearch_contraction_factor" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.MalitskyPockParams.StepSizeInterpolationFieldNumber">
            <summary>Field number for the "step_size_interpolation" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.MalitskyPockParams.StepSizeInterpolation">
            <summary>
            Malitsky and Pock linesearch rule permits an arbitrary choice of the first
            step size guess within an interval [m, M]. This parameter determines where
            in that interval to pick the step size. In particular, the next stepsize is
            given by m + step_size_interpolation*(M - m). The default is the value used
            in Malitsky and Pock (2016).
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.MalitskyPockParams.HasStepSizeInterpolation">
            <summary>Gets whether the "step_size_interpolation" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.MalitskyPockParams.ClearStepSizeInterpolation">
            <summary>Clears the value of the "step_size_interpolation" field</summary>
        </member>
        <member name="T:Google.OrTools.PDLP.PrimalDualHybridGradientParams">
            <summary>
            Parameters for PrimalDualHybridGradient() in primal_dual_hybrid_gradient.h.
            While the defaults are generally good, it is usually worthwhile to perform a
            parameter sweep to find good settings for a particular family of problems.
            The following parameters should be considered for tuning:
            - restart_strategy (jointly with major_iteration_frequency)
            - primal_weight_update_smoothing (jointly with initial_primal_weight)
            - presolve_options.use_glop
            - l_inf_ruiz_iterations
            - l2_norm_rescaling
            In addition, tune num_threads to speed up the solve.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.TerminationCriteriaFieldNumber">
            <summary>Field number for the "termination_criteria" field.</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.NumThreadsFieldNumber">
            <summary>Field number for the "num_threads" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.NumThreads">
            <summary>
            The number of threads to use. Must be positive.
            Try various values of num_threads, up to the number of physical cores.
            Performance may not be monotonically increasing with the number of threads
            because of memory bandwidth limitations.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasNumThreads">
            <summary>Gets whether the "num_threads" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearNumThreads">
            <summary>Clears the value of the "num_threads" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.NumShardsFieldNumber">
            <summary>Field number for the "num_shards" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.NumShards">
            <summary>
            For more efficient parallel computation, the matrices and vectors are
            divided (virtually) into num_shards shards. Results are computed
            independently for each shard and then combined. As a consequence, the order
            of computation, and hence floating point roundoff, depends on the number of
            shards so reproducible results require using the same value for num_shards.
            However, for efficiency num_shards should a be at least num_threads, and
            preferably at least 4*num_threads to allow better load balancing. If
            num_shards is positive, the computation will use that many shards.
            Otherwise a default that depends on num_threads will be used.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasNumShards">
            <summary>Gets whether the "num_shards" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearNumShards">
            <summary>Clears the value of the "num_shards" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.RecordIterationStatsFieldNumber">
            <summary>Field number for the "record_iteration_stats" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.RecordIterationStats">
            <summary>
            If true, the iteration_stats field of the SolveLog output will be populated
            at every iteration. Note that we only compute solution statistics at
            termination checks. Setting this parameter to true may substantially
            increase the size of the output.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasRecordIterationStats">
            <summary>Gets whether the "record_iteration_stats" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearRecordIterationStats">
            <summary>Clears the value of the "record_iteration_stats" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.VerbosityLevelFieldNumber">
            <summary>Field number for the "verbosity_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.VerbosityLevel">
            <summary>
            The verbosity of logging.
            0: No informational logging. (Errors are logged.)
            1: Summary statistics only. No iteration-level details.
            2: A table of iteration-level statistics is logged.
               (See ToShortString() in primal_dual_hybrid_gradient.cc).
            3: A more detailed table of iteration-level statistics is logged.
               (See ToString() in primal_dual_hybrid_gradient.cc).
            4: For iteration-level details, prints the statistics of both the average
               (prefixed with A) and the current iterate (prefixed with C). Also prints
               internal algorithmic state and details.
            Logging at levels 2-4 also includes messages from level 1.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasVerbosityLevel">
            <summary>Gets whether the "verbosity_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearVerbosityLevel">
            <summary>Clears the value of the "verbosity_level" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.LogIntervalSecondsFieldNumber">
            <summary>Field number for the "log_interval_seconds" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.LogIntervalSeconds">
            <summary>
            Time between iteration-level statistics logging (if `verbosity_level > 1`).
            Since iteration-level statistics are only generated when performing
            termination checks, logs will be generated from next termination check
            after `log_interval_seconds` have elapsed. Should be >= 0.0. 0.0 (the
            default) means log statistics at every termination check.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasLogIntervalSeconds">
            <summary>Gets whether the "log_interval_seconds" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearLogIntervalSeconds">
            <summary>Clears the value of the "log_interval_seconds" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.MajorIterationFrequencyFieldNumber">
            <summary>Field number for the "major_iteration_frequency" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.MajorIterationFrequency">
            <summary>
            The frequency at which extra work is performed to make major algorithmic
            decisions, e.g., performing restarts and updating the primal weight. Major
            iterations also trigger a termination check. For best performance using the
            NO_RESTARTS or EVERY_MAJOR_ITERATION rule, one should perform a log-scale
            grid search over this parameter, for example, over powers of two.
            ADAPTIVE_HEURISTIC is mostly insensitive to this value.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasMajorIterationFrequency">
            <summary>Gets whether the "major_iteration_frequency" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearMajorIterationFrequency">
            <summary>Clears the value of the "major_iteration_frequency" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.TerminationCheckFrequencyFieldNumber">
            <summary>Field number for the "termination_check_frequency" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.TerminationCheckFrequency">
            <summary>
            The frequency (based on a counter reset every major iteration) to check for
            termination (involves extra work) and log iteration stats. Termination
            checks do not affect algorithmic progress unless termination is triggered.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasTerminationCheckFrequency">
            <summary>Gets whether the "termination_check_frequency" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearTerminationCheckFrequency">
            <summary>Clears the value of the "termination_check_frequency" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.RestartStrategyFieldNumber">
            <summary>Field number for the "restart_strategy" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.RestartStrategy">
            <summary>
            NO_RESTARTS and EVERY_MAJOR_ITERATION occasionally outperform the default.
            If using a strategy other than ADAPTIVE_HEURISTIC, you must also tune
            major_iteration_frequency.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasRestartStrategy">
            <summary>Gets whether the "restart_strategy" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearRestartStrategy">
            <summary>Clears the value of the "restart_strategy" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.PrimalWeightUpdateSmoothingFieldNumber">
            <summary>Field number for the "primal_weight_update_smoothing" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.PrimalWeightUpdateSmoothing">
            <summary>
            This parameter controls exponential smoothing of log(primal_weight) when a
            primal weight update occurs (i.e., when the ratio of primal and dual step
            sizes is adjusted). At 0.0, the primal weight will be frozen at its initial
            value and there will be no dynamic updates in the algorithm. At 1.0, there
            is no smoothing in the updates. The default of 0.5 generally performs well,
            but has been observed on occasion to trigger unstable swings in the primal
            weight. We recommend also trying 0.0 (disabling primal weight updates), in
            which case you must also tune initial_primal_weight.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasPrimalWeightUpdateSmoothing">
            <summary>Gets whether the "primal_weight_update_smoothing" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearPrimalWeightUpdateSmoothing">
            <summary>Clears the value of the "primal_weight_update_smoothing" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.InitialPrimalWeightFieldNumber">
            <summary>Field number for the "initial_primal_weight" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.InitialPrimalWeight">
            <summary>
            The initial value of the primal weight (i.e., the ratio of primal and dual
            step sizes). The primal weight remains fixed throughout the solve if
            primal_weight_update_smoothing = 0.0. If unset, the default is the ratio of
            the norm of the objective vector to the L2 norm of the combined constraint
            bounds vector (as defined above). If this ratio is not finite and positive,
            then the default is 1.0 instead. For tuning, try powers of 10, for example,
            from 10^{-6} to 10^6.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasInitialPrimalWeight">
            <summary>Gets whether the "initial_primal_weight" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearInitialPrimalWeight">
            <summary>Clears the value of the "initial_primal_weight" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.PresolveOptionsFieldNumber">
            <summary>Field number for the "presolve_options" field.</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.LInfRuizIterationsFieldNumber">
            <summary>Field number for the "l_inf_ruiz_iterations" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.LInfRuizIterations">
            <summary>
            Number of L_infinity Ruiz rescaling iterations to apply to the constraint
            matrix. Zero disables this rescaling pass. Recommended values to try when
            tuning are 0, 5, and 10.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasLInfRuizIterations">
            <summary>Gets whether the "l_inf_ruiz_iterations" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearLInfRuizIterations">
            <summary>Clears the value of the "l_inf_ruiz_iterations" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.L2NormRescalingFieldNumber">
            <summary>Field number for the "l2_norm_rescaling" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.L2NormRescaling">
            <summary>
            If true, applies L_2 norm rescaling after the Ruiz rescaling. Heuristically
            this has been found to help convergence.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasL2NormRescaling">
            <summary>Gets whether the "l2_norm_rescaling" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearL2NormRescaling">
            <summary>Clears the value of the "l2_norm_rescaling" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.SufficientReductionForRestartFieldNumber">
            <summary>Field number for the "sufficient_reduction_for_restart" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.SufficientReductionForRestart">
            <summary>
            For ADAPTIVE_HEURISTIC and ADAPTIVE_DISTANCE_BASED only: A relative
            reduction in the potential function by this amount always triggers a
            restart. Must be between 0.0 and 1.0.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasSufficientReductionForRestart">
            <summary>Gets whether the "sufficient_reduction_for_restart" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearSufficientReductionForRestart">
            <summary>Clears the value of the "sufficient_reduction_for_restart" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.NecessaryReductionForRestartFieldNumber">
            <summary>Field number for the "necessary_reduction_for_restart" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.NecessaryReductionForRestart">
            <summary>
            For ADAPTIVE_HEURISTIC only: A relative reduction in the potential function
            by this amount triggers a restart if, additionally, the quality of the
            iterates appears to be getting worse. The value must be in the interval
            [sufficient_reduction_for_restart, 1). Smaller values make restarts less
            frequent, and larger values make them more frequent.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasNecessaryReductionForRestart">
            <summary>Gets whether the "necessary_reduction_for_restart" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearNecessaryReductionForRestart">
            <summary>Clears the value of the "necessary_reduction_for_restart" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.LinesearchRuleFieldNumber">
            <summary>Field number for the "linesearch_rule" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.LinesearchRule">
            <summary>
            Linesearch rule applied at each major iteration.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasLinesearchRule">
            <summary>Gets whether the "linesearch_rule" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearLinesearchRule">
            <summary>Clears the value of the "linesearch_rule" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.AdaptiveLinesearchParametersFieldNumber">
            <summary>Field number for the "adaptive_linesearch_parameters" field.</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.MalitskyPockParametersFieldNumber">
            <summary>Field number for the "malitsky_pock_parameters" field.</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.InitialStepSizeScalingFieldNumber">
            <summary>Field number for the "initial_step_size_scaling" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.InitialStepSizeScaling">
            <summary>
            Scaling factor applied to the initial step size (all step sizes if
            linesearch_rule == CONSTANT_STEP_SIZE_RULE).
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasInitialStepSizeScaling">
            <summary>Gets whether the "initial_step_size_scaling" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearInitialStepSizeScaling">
            <summary>Clears the value of the "initial_step_size_scaling" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.RandomProjectionSeedsFieldNumber">
            <summary>Field number for the "random_projection_seeds" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.RandomProjectionSeeds">
            <summary>
            Seeds for generating (pseudo-)random projections of iterates during
            termination checks. For each seed, the projection of the primal and dual
            solutions onto random planes in primal and dual space will be computed and
            added the IterationStats if record_iteration_stats is true. The random
            planes generated will be determined by the seeds, the primal and dual
            dimensions, and num_threads.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.InfiniteConstraintBoundThresholdFieldNumber">
            <summary>Field number for the "infinite_constraint_bound_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.InfiniteConstraintBoundThreshold">
            <summary>
            Constraint bounds with absolute value at least this threshold are replaced
            with infinities.
            NOTE: This primarily affects the relative convergence criteria. A smaller
            value makes the relative convergence criteria stronger. It also affects the
            problem statistics LOG()ed at the start of the run, and the default initial
            primal weight, since that is based on the norm of the bounds.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasInfiniteConstraintBoundThreshold">
            <summary>Gets whether the "infinite_constraint_bound_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearInfiniteConstraintBoundThreshold">
            <summary>Clears the value of the "infinite_constraint_bound_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HandleSomePrimalGradientsOnFiniteBoundsAsResidualsFieldNumber">
            <summary>Field number for the "handle_some_primal_gradients_on_finite_bounds_as_residuals" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HandleSomePrimalGradientsOnFiniteBoundsAsResiduals">
            <summary>
            See
            https://developers.google.com/optimization/lp/pdlp_math#treating_some_variable_bounds_as_infinite
            for a description of this flag.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasHandleSomePrimalGradientsOnFiniteBoundsAsResiduals">
            <summary>Gets whether the "handle_some_primal_gradients_on_finite_bounds_as_residuals" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearHandleSomePrimalGradientsOnFiniteBoundsAsResiduals">
            <summary>Clears the value of the "handle_some_primal_gradients_on_finite_bounds_as_residuals" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.UseDiagonalQpTrustRegionSolverFieldNumber">
            <summary>Field number for the "use_diagonal_qp_trust_region_solver" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.UseDiagonalQpTrustRegionSolver">
            <summary>
            When solving QPs with diagonal objective matrices, this option can be
            turned on to enable an experimental solver that avoids linearization of the
            quadratic term. The `diagonal_qp_solver_accuracy` parameter controls the
            solve accuracy.
            TODO(user): Turn this option on by default for quadratic
            programs after numerical evaluation.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasUseDiagonalQpTrustRegionSolver">
            <summary>Gets whether the "use_diagonal_qp_trust_region_solver" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearUseDiagonalQpTrustRegionSolver">
            <summary>Clears the value of the "use_diagonal_qp_trust_region_solver" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.DiagonalQpTrustRegionSolverToleranceFieldNumber">
            <summary>Field number for the "diagonal_qp_trust_region_solver_tolerance" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.DiagonalQpTrustRegionSolverTolerance">
            <summary>
            The solve tolerance of the experimental trust region solver for diagonal
            QPs, controlling the accuracy of binary search over a one-dimensional
            scaling parameter. Smaller values imply smaller relative error of the final
            solution vector.
            TODO(user): Find an expression for the final relative error.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasDiagonalQpTrustRegionSolverTolerance">
            <summary>Gets whether the "diagonal_qp_trust_region_solver_tolerance" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearDiagonalQpTrustRegionSolverTolerance">
            <summary>Clears the value of the "diagonal_qp_trust_region_solver_tolerance" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.UseFeasibilityPolishingFieldNumber">
            <summary>Field number for the "use_feasibility_polishing" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.UseFeasibilityPolishing">
             <summary>
             If true, periodically runs feasibility polishing, which attempts to move
             from latest average iterate to one that is closer to feasibility (i.e., has
             smaller primal and dual residuals) while probably increasing the objective
             gap. This is useful primarily when the feasibility tolerances are fairly
             tight and the objective gap tolerance is somewhat looser. Note that this
             does not change the termination criteria, but rather can help achieve the
             termination criteria more quickly when the objective gap is not as
             important as feasibility.
            
             `use_feasibility_polishing` cannot be used with glop presolve, and requires
             `handle_some_primal_gradients_on_finite_bounds_as_residuals == false`.
             `use_feasibility_polishing` can only be used with linear programs.
            
             Feasibility polishing runs two separate phases, primal feasibility and dual
             feasibility. The primal feasibility phase runs PDHG on the primal
             feasibility problem (obtained by changing the objective vector to all
             zeros), using the average primal iterate and zero dual (which is optimal
             for the primal feasibility problem) as the initial solution. The dual
             feasibility phase runs PDHG on the dual feasibility problem (obtained by
             changing all finite variable and constraint bounds to zero), using the
             average dual iterate and zero primal (which is optimal for the dual
             feasibility problem) as the initial solution. The primal solution from the
             primal feasibility phase and dual solution from the dual feasibility phase
             are then combined (forming a solution of type
             `POINT_TYPE_FEASIBILITY_POLISHING_SOLUTION`) and checked against the
             termination criteria.
             </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.HasUseFeasibilityPolishing">
            <summary>Gets whether the "use_feasibility_polishing" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.ClearUseFeasibilityPolishing">
            <summary>Clears the value of the "use_feasibility_polishing" field</summary>
        </member>
        <member name="T:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types">
            <summary>Container for nested types declared in the PrimalDualHybridGradientParams message type.</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.RestartStrategy.NoRestarts">
            <summary>
            No restarts are performed. The average solution is cleared every major
            iteration, but the current solution is not changed.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.RestartStrategy.EveryMajorIteration">
            <summary>
            On every major iteration, the current solution is reset to the average
            since the last major iteration.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.RestartStrategy.AdaptiveHeuristic">
            <summary>
            A heuristic that adaptively decides on every major iteration whether to
            restart (this is forced approximately on increasing powers-of-two
            iterations), and if so to the current or to the average, based on
            reduction in a potential function. The rule more or less follows the
            description of the adaptive restart scheme in
            https://arxiv.org/pdf/2106.04756.pdf.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.RestartStrategy.AdaptiveDistanceBased">
            <summary>
            A distance-based restarting scheme that restarts the algorithm whenever
            an appropriate potential function is reduced sufficiently. This check
            happens at every major iteration.
            TODO(user): Cite paper for the restart strategy and definition of the
            potential function, when available.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.LinesearchRule.AdaptiveLinesearchRule">
            <summary>
            Applies the heuristic rule presented in Section 3.1 of
            https://arxiv.org/pdf/2106.04756.pdf (further generalized to QP). There
            is not a proof of convergence for it. It is usually the fastest in
            practice but sometimes behaves poorly.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.LinesearchRule.MalitskyPockLinesearchRule">
            <summary>
            Applies Malitsky &amp; Pock linesearch rule. This guarantees an
            ergodic O(1/N) convergence rate https://arxiv.org/pdf/1608.08883.pdf.
            This is provably convergent but doesn't usually work as well in practice
            as ADAPTIVE_LINESEARCH_RULE.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.LinesearchRule.ConstantStepSizeRule">
            <summary>
            Uses a constant step size corresponding to an estimate of the maximum
            singular value of the constraint matrix.
            </summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.PresolveOptions.UseGlopFieldNumber">
            <summary>Field number for the "use_glop" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.PresolveOptions.UseGlop">
            <summary>
            If true runs Glop's presolver on the given instance prior to solving.
            Note that convergence criteria are still interpreted with respect to the
            original problem. Certificates may not be available if presolve detects
            infeasibility. Glop's presolver cannot apply to problems with quadratic
            objectives or problems with more than 2^31 variables or constraints. It's
            often beneficial to enable the presolver, especially on medium-sized
            problems. At some larger scales, the presolver can become a serial
            bottleneck.
            </summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.PresolveOptions.HasUseGlop">
            <summary>Gets whether the "use_glop" field is set</summary>
        </member>
        <member name="M:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.PresolveOptions.ClearUseGlop">
            <summary>Clears the value of the "use_glop" field</summary>
        </member>
        <member name="F:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.PresolveOptions.GlopParametersFieldNumber">
            <summary>Field number for the "glop_parameters" field.</summary>
        </member>
        <member name="P:Google.OrTools.PDLP.PrimalDualHybridGradientParams.Types.PresolveOptions.GlopParameters">
            <summary>
            Parameters to control glop's presolver. Only used when use_glop is true.
            These are merged with and override PDLP's defaults.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.BooleanProblemReflection">
            <summary>Holder for reflection information generated from ortools/sat/boolean_problem.proto</summary>
        </member>
        <member name="P:Google.OrTools.Sat.BooleanProblemReflection.Descriptor">
            <summary>File descriptor for ortools/sat/boolean_problem.proto</summary>
        </member>
        <member name="T:Google.OrTools.Sat.LinearBooleanConstraint">
            <summary>
            A linear Boolean constraint which is a bounded sum of linear terms. Each term
            beeing a literal times an integer coefficient. If we assume that a literal
            takes the value 1 if it is true and 0 otherwise, the constraint is:
              lower_bound &lt;= ... + coefficients[i] * literals[i] + ... &lt;= upper_bound
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearBooleanConstraint.LiteralsFieldNumber">
            <summary>Field number for the "literals" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanConstraint.Literals">
             <summary>
             Linear terms involved in this constraint.
            
             literals[i] is the signed representation of the i-th literal of the
             constraint and coefficients[i] its coefficients. The signed representation
             is as follow: for a 0-based variable index x, (x + 1) represents the
             variable x and -(x + 1) represents its negation.
            
             Note that the same variable shouldn't appear twice and that zero
             coefficients are not allowed.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearBooleanConstraint.CoefficientsFieldNumber">
            <summary>Field number for the "coefficients" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearBooleanConstraint.LowerBoundFieldNumber">
            <summary>Field number for the "lower_bound" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanConstraint.LowerBound">
            <summary>
            Optional lower (resp. upper) bound of the constraint. If not present, it
            means that the constraint is not bounded in this direction. The bounds
            are INCLUSIVE.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanConstraint.HasLowerBound">
            <summary>Gets whether the "lower_bound" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.LinearBooleanConstraint.ClearLowerBound">
            <summary>Clears the value of the "lower_bound" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearBooleanConstraint.UpperBoundFieldNumber">
            <summary>Field number for the "upper_bound" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanConstraint.HasUpperBound">
            <summary>Gets whether the "upper_bound" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.LinearBooleanConstraint.ClearUpperBound">
            <summary>Clears the value of the "upper_bound" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearBooleanConstraint.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanConstraint.Name">
            <summary>
            The name of this constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanConstraint.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.LinearBooleanConstraint.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="T:Google.OrTools.Sat.LinearObjective">
            <summary>
            The objective of an optimization problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearObjective.LiteralsFieldNumber">
            <summary>Field number for the "literals" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearObjective.Literals">
             <summary>
             The goal is always to minimize the linear Boolean formula defined by these
             two fields: sum_i literal_i * coefficient_i where literal_i is 1 iff
             literal_i is true in a given assignment.
            
             Note that the same variable shouldn't appear twice and that zero
             coefficients are not allowed.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearObjective.CoefficientsFieldNumber">
            <summary>Field number for the "coefficients" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearObjective.OffsetFieldNumber">
            <summary>Field number for the "offset" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearObjective.Offset">
             <summary>
             For a given variable assignment, the "real" problem objective value is
             'scaling_factor * (minimization_objective + offset)' where
             'minimization_objective is the one defined just above.
            
             Note that this is not what we minimize, but it is what we display.
             In particular if scaling_factor is negative, then the "real" problem is
             a maximization problem, even if the "internal" objective is minimized.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearObjective.HasOffset">
            <summary>Gets whether the "offset" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.LinearObjective.ClearOffset">
            <summary>Clears the value of the "offset" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearObjective.ScalingFactorFieldNumber">
            <summary>Field number for the "scaling_factor" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearObjective.HasScalingFactor">
            <summary>Gets whether the "scaling_factor" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.LinearObjective.ClearScalingFactor">
            <summary>Clears the value of the "scaling_factor" field</summary>
        </member>
        <member name="T:Google.OrTools.Sat.BooleanAssignment">
            <summary>
            Stores an assignment of variables as a list of true literals using their
            signed representation. There will be at most one literal per variable. The
            literals will be sorted by increasing variable index. The assignment may be
            partial in the sense that some variables may not appear and thus not be
            assigned.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.BooleanAssignment.LiteralsFieldNumber">
            <summary>Field number for the "literals" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.LinearBooleanProblem">
            <summary>
            A linear Boolean problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearBooleanProblem.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanProblem.Name">
            <summary>
            The name of the problem.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanProblem.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.LinearBooleanProblem.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearBooleanProblem.NumVariablesFieldNumber">
            <summary>Field number for the "num_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanProblem.NumVariables">
            <summary>
            The number of variables in the problem.
            All the signed representation of the problem literals must be in
            [-num_variables, num_variables], excluding 0.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanProblem.HasNumVariables">
            <summary>Gets whether the "num_variables" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.LinearBooleanProblem.ClearNumVariables">
            <summary>Clears the value of the "num_variables" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearBooleanProblem.ConstraintsFieldNumber">
            <summary>Field number for the "constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanProblem.Constraints">
            <summary>
            The constraints of the problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearBooleanProblem.ObjectiveFieldNumber">
            <summary>Field number for the "objective" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanProblem.Objective">
            <summary>
            The objective of the problem.
            If left empty, we just have a satisfiability problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearBooleanProblem.VarNamesFieldNumber">
            <summary>Field number for the "var_names" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanProblem.VarNames">
            <summary>
            The names of the problem variables. The variables index are 0-based and
            var_names[i] will be the name of the i-th variable which correspond to
            literals +(i + 1) or -(i + 1). This is optional and can be left empty.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearBooleanProblem.AssignmentFieldNumber">
            <summary>Field number for the "assignment" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanProblem.Assignment">
            <summary>
            Stores an assignment of the problem variables. That may be an initial
            feasible solution, just a partial assignment or the optimal solution.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearBooleanProblem.OriginalNumVariablesFieldNumber">
            <summary>Field number for the "original_num_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanProblem.OriginalNumVariables">
            <summary>
            Hack: When converting a wcnf formulat to a LinearBooleanProblem, extra
            variables need to be created. This stores the number of variables in the
            original problem (which are in one to one correspondence with the first
            variables of this problem).
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearBooleanProblem.HasOriginalNumVariables">
            <summary>Gets whether the "original_num_variables" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.LinearBooleanProblem.ClearOriginalNumVariables">
            <summary>Clears the value of the "original_num_variables" field</summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpModelReflection">
            <summary>Holder for reflection information generated from ortools/sat/cp_model.proto</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelReflection.Descriptor">
            <summary>File descriptor for ortools/sat/cp_model.proto</summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpSolverStatus">
            <summary>
            The status returned by a solver trying to solve a CpModelProto.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverStatus.Unknown">
            <summary>
            The status of the model is still unknown. A search limit has been reached
            before any of the statuses below could be determined.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverStatus.ModelInvalid">
            <summary>
            The given CpModelProto didn't pass the validation step. You can get a
            detailed error by calling ValidateCpModel(model_proto).
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverStatus.Feasible">
            <summary>
            A feasible solution has been found. But the search was stopped before we
            could prove optimality or before we enumerated all solutions of a
            feasibility problem (if asked).
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverStatus.Infeasible">
            <summary>
            The problem has been proven infeasible.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverStatus.Optimal">
             <summary>
             An optimal feasible solution has been found.
            
             More generally, this status represent a success. So we also return OPTIMAL
             if we find a solution for a pure feasibility problem or if a gap limit has
             been specified and we return a solution within this limit. In the case
             where we need to return all the feasible solution, this status will only be
             returned if we enumerated all of them; If we stopped before, we will return
             FEASIBLE.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.IntegerVariableProto">
             <summary>
             An integer variable.
            
             It will be referred to by an int32 corresponding to its index in a
             CpModelProto variables field.
            
             Depending on the context, a reference to a variable whose domain is in [0, 1]
             can also be seen as a Boolean that will be true if the variable value is 1
             and false if it is 0. When used in this context, the field name will always
             contain the word "literal".
            
             Negative reference (advanced usage): to simplify the creation of a model and
             for efficiency reasons, all the "literal" or "variable" fields can also
             contain a negative index. A negative index i will refer to the negation of
             the integer variable at index -i -1 or to NOT the literal at the same index.
            
             Ex: A variable index 4 will refer to the integer variable model.variables(4)
             and an index of -5 will refer to the negation of the same variable. A literal
             index 4 will refer to the logical fact that model.variable(4) == 1 and a
             literal index of -5 will refer to the logical fact model.variable(4) == 0.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntegerVariableProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.IntegerVariableProto.Name">
            <summary>
            For debug/logging only. Can be empty.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntegerVariableProto.DomainFieldNumber">
            <summary>Field number for the "domain" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.IntegerVariableProto.Domain">
             <summary>
             The variable domain given as a sorted list of n disjoint intervals
             [min, max] and encoded as [min_0, max_0,  ..., min_{n-1}, max_{n-1}].
            
             The most common example being just [min, max].
             If min == max, then this is a constant variable.
            
             We have:
              - domain_size() is always even.
              - min == domain.front();
              - max == domain.back();
              - for all i &lt; n   :      min_i &lt;= max_i
              - for all i &lt; n-1 :  max_i + 1 &lt; min_{i+1}.
            
             Note that we check at validation that a variable domain is small enough so
             that we don't run into integer overflow in our algorithms. Because of that,
             you cannot just have "unbounded" variable like [0, kint64max] and should
             try to specify tighter domains.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.BoolArgumentProto">
            <summary>
            Argument of the constraints of the form OP(literals).
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.BoolArgumentProto.LiteralsFieldNumber">
            <summary>Field number for the "literals" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.LinearExpressionProto">
            <summary>
            Some constraints supports linear expression instead of just using a reference
            to a variable. This is especially useful during presolve to reduce the model
            size.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearExpressionProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearExpressionProto.CoeffsFieldNumber">
            <summary>Field number for the "coeffs" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearExpressionProto.OffsetFieldNumber">
            <summary>Field number for the "offset" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearArgumentProto.TargetFieldNumber">
            <summary>Field number for the "target" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearArgumentProto.ExprsFieldNumber">
            <summary>Field number for the "exprs" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.AllDifferentConstraintProto">
            <summary>
            All affine expressions must take different values.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.AllDifferentConstraintProto.ExprsFieldNumber">
            <summary>Field number for the "exprs" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.LinearConstraintProto">
             <summary>
             The linear sum vars[i] * coeffs[i] must fall in the given domain. The domain
             has the same format as the one in IntegerVariableProto.
            
             Note that the validation code currently checks using the domain of the
             involved variables that the sum can always be computed without integer
             overflow and throws an error otherwise.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearConstraintProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearConstraintProto.CoeffsFieldNumber">
            <summary>Field number for the "coeffs" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearConstraintProto.Coeffs">
            <summary>
            Same size as vars.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearConstraintProto.DomainFieldNumber">
            <summary>Field number for the "domain" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.ElementConstraintProto">
            <summary>
            The constraint target = vars[index].
            This enforces that index takes one of the value in [0, vars_size()).
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ElementConstraintProto.IndexFieldNumber">
            <summary>Field number for the "index" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.ElementConstraintProto.TargetFieldNumber">
            <summary>Field number for the "target" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.ElementConstraintProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.IntervalConstraintProto">
             <summary>
             This is not really a constraint. It is there so it can be referred by other
             constraints using this "interval" concept.
            
             IMPORTANT: For now, this constraint do not enforce any relations on the
             components, and it is up to the client to add in the model:
             - enforcement => start + size == end.
             - enforcement => size >= 0  // Only needed if size is not already >= 0.
            
             IMPORTANT: For now, we just support affine relation. We could easily
             create an intermediate variable to support full linear expression, but this
             isn't done currently.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntervalConstraintProto.StartFieldNumber">
            <summary>Field number for the "start" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntervalConstraintProto.EndFieldNumber">
            <summary>Field number for the "end" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntervalConstraintProto.SizeFieldNumber">
            <summary>Field number for the "size" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.NoOverlapConstraintProto">
            <summary>
            All the intervals (index of IntervalConstraintProto) must be disjoint. More
            formally, there must exist a sequence so that for each consecutive intervals,
            we have end_i &lt;= start_{i+1}. In particular, intervals of size zero do matter
            for this constraint. This is also known as a disjunctive constraint in
            scheduling.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.NoOverlapConstraintProto.IntervalsFieldNumber">
            <summary>Field number for the "intervals" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.NoOverlap2DConstraintProto">
             <summary>
             The boxes defined by [start_x, end_x) * [start_y, end_y) cannot overlap.
             Furthermore, one box is optional if at least one of the x or y interval is
             optional.
            
             Note that the case of boxes of size zero is special. The following cases
             violate the constraint:
               - a point box inside a box with a non zero area
               - a line box overlapping a box with a non zero area
               - one vertical line box crossing an horizontal line box.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.NoOverlap2DConstraintProto.XIntervalsFieldNumber">
            <summary>Field number for the "x_intervals" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.NoOverlap2DConstraintProto.YIntervalsFieldNumber">
            <summary>Field number for the "y_intervals" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.NoOverlap2DConstraintProto.YIntervals">
            <summary>
            Same size as x_intervals.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.CumulativeConstraintProto">
             <summary>
             The sum of the demands of the intervals at each interval point cannot exceed
             a capacity. Note that intervals are interpreted as [start, end) and as
             such intervals like [2,3) and [3,4) do not overlap for the point of view of
             this constraint. Moreover, intervals of size zero are ignored.
            
             All demands must not contain any negative value in their domains. This is
             checked at validation. The capacity can currently contains negative values,
             but it will be propagated to >= 0 right away.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CumulativeConstraintProto.CapacityFieldNumber">
            <summary>Field number for the "capacity" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CumulativeConstraintProto.IntervalsFieldNumber">
            <summary>Field number for the "intervals" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CumulativeConstraintProto.DemandsFieldNumber">
            <summary>Field number for the "demands" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CumulativeConstraintProto.Demands">
            <summary>
            Same size as intervals.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.ReservoirConstraintProto">
             <summary>
             Maintain a reservoir level within bounds. The water level starts at 0, and at
             any time, it must be within [min_level, max_level].
            
             If the variable active_literals[i] is true, and if the expression
             time_exprs[i] is assigned a value t, then the current level changes by
             level_changes[i] at the time t. Therefore, at any time t:
            
             sum(level_changes[i] * active_literals[i] if time_exprs[i] &lt;= t)
               in [min_level, max_level]
            
             Note that min level must be &lt;= 0, and the max level must be >= 0. Please use
             fixed level_changes to simulate initial state.
            
             The array of boolean variables 'actives', if defined, indicates which actions
             are actually performed. If this array is not defined, then it is assumed that
             all actions will be performed.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ReservoirConstraintProto.MinLevelFieldNumber">
            <summary>Field number for the "min_level" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.ReservoirConstraintProto.MaxLevelFieldNumber">
            <summary>Field number for the "max_level" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.ReservoirConstraintProto.TimeExprsFieldNumber">
            <summary>Field number for the "time_exprs" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ReservoirConstraintProto.TimeExprs">
            <summary>
            affine expressions.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ReservoirConstraintProto.LevelChangesFieldNumber">
            <summary>Field number for the "level_changes" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ReservoirConstraintProto.LevelChanges">
            <summary>
            Currently, we only support constant level changes.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ReservoirConstraintProto.ActiveLiteralsFieldNumber">
            <summary>Field number for the "active_literals" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.CircuitConstraintProto">
             <summary>
             The circuit constraint is defined on a graph where the arc presence are
             controlled by literals. Each arc is given by an index in the
             tails/heads/literals lists that must have the same size.
            
             For now, we ignore node indices with no incident arc. All the other nodes
             must have exactly one incoming and one outgoing selected arc (i.e. literal at
             true). All the selected arcs that are not self-loops must form a single
             circuit. Note that multi-arcs are allowed, but only one of them will be true
             at the same time. Multi-self loop are disallowed though.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CircuitConstraintProto.TailsFieldNumber">
            <summary>Field number for the "tails" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CircuitConstraintProto.HeadsFieldNumber">
            <summary>Field number for the "heads" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CircuitConstraintProto.LiteralsFieldNumber">
            <summary>Field number for the "literals" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.RoutesConstraintProto">
             <summary>
             The "VRP" (Vehicle Routing Problem) constraint.
            
             The direct graph where arc #i (from tails[i] to head[i]) is present iff
             literals[i] is true must satisfy this set of properties:
             - #incoming arcs == 1 except for node 0.
             - #outgoing arcs == 1 except for node 0.
             - for node zero, #incoming arcs == #outgoing arcs.
             - There are no duplicate arcs.
             - Self-arcs are allowed except for node 0.
             - There is no cycle in this graph, except through node 0.
            
             Note: Currently this constraint expect all the nodes in [0, num_nodes) to
             have at least one incident arc. The model will be considered invalid if it
             is not the case. You can add self-arc fixed to one to ignore some nodes if
             needed.
            
             TODO(user): It is probably possible to generalize this constraint to a
             no-cycle in a general graph, or a no-cycle with sum incoming &lt;= 1 and sum
             outgoing &lt;= 1 (more efficient implementation). On the other hand, having this
             specific constraint allow us to add specific "cuts" to a VRP problem.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.RoutesConstraintProto.TailsFieldNumber">
            <summary>Field number for the "tails" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.RoutesConstraintProto.HeadsFieldNumber">
            <summary>Field number for the "heads" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.RoutesConstraintProto.LiteralsFieldNumber">
            <summary>Field number for the "literals" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.RoutesConstraintProto.DemandsFieldNumber">
            <summary>Field number for the "demands" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.RoutesConstraintProto.Demands">
             <summary>
             EXPERIMENTAL. The demands for each node, and the maximum capacity for each
             route. Note that this is currently only used for the LP relaxation and one
             need to add the corresponding constraint to enforce this outside of the LP.
            
             TODO(user): Ideally, we should be able to extract any dimension like these
             (i.e. capacity, route_length, etc..) automatically from the encoding. The
             classical way to encode that is to have "current_capacity" variables along
             the route and linear equations of the form:
               arc_literal => (current_capacity_tail + demand &lt;= current_capacity_head)
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.RoutesConstraintProto.CapacityFieldNumber">
            <summary>Field number for the "capacity" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.TableConstraintProto">
            <summary>
            The values of the n-tuple formed by the given variables can only be one of
            the listed n-tuples in values. The n-tuples are encoded in a flattened way:
                [tuple0_v0, tuple0_v1, ..., tuple0_v{n-1}, tuple1_v0, ...].
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.TableConstraintProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.TableConstraintProto.ValuesFieldNumber">
            <summary>Field number for the "values" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.TableConstraintProto.NegatedFieldNumber">
            <summary>Field number for the "negated" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.TableConstraintProto.Negated">
            <summary>
            If true, the meaning is "negated", that is we forbid any of the given
            tuple from a feasible assignment.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.InverseConstraintProto">
            <summary>
            The two arrays of variable each represent a function, the second is the
            inverse of the first: f_direct[i] == j &lt;=> f_inverse[j] == i.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.InverseConstraintProto.FDirectFieldNumber">
            <summary>Field number for the "f_direct" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.InverseConstraintProto.FInverseFieldNumber">
            <summary>Field number for the "f_inverse" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.AutomatonConstraintProto">
            <summary>
            This constraint forces a sequence of variables to be accepted by an
            automaton.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.AutomatonConstraintProto.StartingStateFieldNumber">
            <summary>Field number for the "starting_state" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.AutomatonConstraintProto.StartingState">
            <summary>
            A state is identified by a non-negative number. It is preferable to keep
            all the states dense in says [0, num_states). The automaton starts at
            starting_state and must finish in any of the final states.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.AutomatonConstraintProto.FinalStatesFieldNumber">
            <summary>Field number for the "final_states" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.AutomatonConstraintProto.TransitionTailFieldNumber">
            <summary>Field number for the "transition_tail" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.AutomatonConstraintProto.TransitionTail">
            <summary>
            List of transitions (all 3 vectors have the same size). Both tail and head
            are states, label is any variable value. No two outgoing transitions from
            the same state can have the same label.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.AutomatonConstraintProto.TransitionHeadFieldNumber">
            <summary>Field number for the "transition_head" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.AutomatonConstraintProto.TransitionLabelFieldNumber">
            <summary>Field number for the "transition_label" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.AutomatonConstraintProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.AutomatonConstraintProto.Vars">
            <summary>
            The sequence of variables. The automaton is ran for vars_size() "steps" and
            the value of vars[i] corresponds to the transition label at step i.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.ListOfVariablesProto">
            <summary>
            A list of variables, without any semantics.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ListOfVariablesProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.ConstraintProto">
            <summary>
            Next id: 31
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Name">
            <summary>
            For debug/logging only. Can be empty.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.EnforcementLiteralFieldNumber">
            <summary>Field number for the "enforcement_literal" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.EnforcementLiteral">
             <summary>
             The constraint will be enforced iff all literals listed here are true. If
             this is empty, then the constraint will always be enforced. An enforced
             constraint must be satisfied, and an un-enforced one will simply be
             ignored.
            
             This is also called half-reification. To have an equivalence between a
             literal and a constraint (full reification), one must add both a constraint
             (controlled by a literal l) and its negation (controlled by the negation of
             l).
            
             Important: as of September 2018, only a few constraint support enforcement:
             - bool_or, bool_and, linear: fully supported.
             - interval: only support a single enforcement literal.
             - other: no support (but can be added on a per-demand basis).
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.BoolOrFieldNumber">
            <summary>Field number for the "bool_or" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.BoolOr">
            <summary>
            The bool_or constraint forces at least one literal to be true.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.BoolAndFieldNumber">
            <summary>Field number for the "bool_and" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.BoolAnd">
             <summary>
             The bool_and constraint forces all of the literals to be true.
            
             This is a "redundant" constraint in the sense that this can easily be
             encoded with many bool_or or at_most_one. It is just more space efficient
             and handled slightly differently internally.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.AtMostOneFieldNumber">
            <summary>Field number for the "at_most_one" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.AtMostOne">
             <summary>
             The at_most_one constraint enforces that no more than one literal is
             true at the same time.
            
             Note that an at most one constraint of length n could be encoded with n
             bool_and constraint with n-1 term on the right hand side. So in a sense,
             this constraint contribute directly to the "implication-graph" or the
             2-SAT part of the model.
            
             This constraint does not support enforcement_literal. Just use a linear
             constraint if you need to enforce it. You also do not need to use it
             directly, we will extract it from the model in most situations.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.ExactlyOneFieldNumber">
            <summary>Field number for the "exactly_one" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.ExactlyOne">
             <summary>
             The exactly_one constraint force exactly one literal to true and no more.
            
             Anytime a bool_or (it could have been called at_least_one) is included
             into an at_most_one, then the bool_or is actually an exactly one
             constraint, and the extra literal in the at_most_one can be set to false.
             So in this sense, this constraint is not really needed. it is just here
             for a better description of the problem structure and to facilitate some
             algorithm.
            
             This constraint does not support enforcement_literal. Just use a linear
             constraint if you need to enforce it. You also do not need to use it
             directly, we will extract it from the model in most situations.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.BoolXorFieldNumber">
            <summary>Field number for the "bool_xor" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.BoolXor">
            <summary>
            The bool_xor constraint forces an odd number of the literals to be true.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.IntDivFieldNumber">
            <summary>Field number for the "int_div" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.IntDiv">
             <summary>
             The int_div constraint forces the target to equal exprs[0] / exprs[1].
             The division is "rounded" towards zero, so we can have for instance
             (2 = 12 / 5) or (-3 = -10 / 3). If you only want exact integer division,
             then you should use instead of t = a / b, the int_prod constraint
             a = b * t.
            
             If 0 belongs to the domain of exprs[1], then the model is deemed invalid.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.IntModFieldNumber">
            <summary>Field number for the "int_mod" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.IntMod">
            <summary>
            The int_mod constraint forces the target to equal exprs[0] % exprs[1].
            The domain of exprs[1] must be strictly positive. The sign of the target
            is the same as the sign of exprs[0].
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.IntProdFieldNumber">
            <summary>Field number for the "int_prod" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.IntProd">
             <summary>
             The int_prod constraint forces the target to equal the product of all
             variables. By convention, because we can just remove term equal to one,
             the empty product forces the target to be one.
            
             Note that the solver checks for potential integer overflow. So the
             product of the maximum absolute value of all the terms (using the initial
             domain) should fit on an int64. Otherwise the model will be declared
             invalid.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.LinMaxFieldNumber">
            <summary>Field number for the "lin_max" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.LinMax">
            <summary>
            The lin_max constraint forces the target to equal the maximum of all
            linear expressions.
            Note that this can model a minimum simply by negating all expressions.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.LinearFieldNumber">
            <summary>Field number for the "linear" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Linear">
            <summary>
            The linear constraint enforces a linear inequality among the variables,
            such as 0 &lt;= x + 2y &lt;= 10.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.AllDiffFieldNumber">
            <summary>Field number for the "all_diff" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.AllDiff">
            <summary>
            The all_diff constraint forces all variables to take different values.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.ElementFieldNumber">
            <summary>Field number for the "element" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Element">
            <summary>
            The element constraint forces the variable with the given index
            to be equal to the target.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.CircuitFieldNumber">
            <summary>Field number for the "circuit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Circuit">
            <summary>
            The circuit constraint takes a graph and forces the arcs present
            (with arc presence indicated by a literal) to form a unique cycle.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.RoutesFieldNumber">
            <summary>Field number for the "routes" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Routes">
            <summary>
            The routes constraint implements the vehicle routing problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.TableFieldNumber">
            <summary>Field number for the "table" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Table">
            <summary>
            The table constraint enforces what values a tuple of variables may
            take.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.AutomatonFieldNumber">
            <summary>Field number for the "automaton" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Automaton">
            <summary>
            The automaton constraint forces a sequence of variables to be accepted
            by an automaton.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.InverseFieldNumber">
            <summary>Field number for the "inverse" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Inverse">
            <summary>
            The inverse constraint forces two arrays to be inverses of each other:
            the values of one are the indices of the other, and vice versa.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.ReservoirFieldNumber">
            <summary>Field number for the "reservoir" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Reservoir">
            <summary>
            The reservoir constraint forces the sum of a set of active demands
            to always be between a specified minimum and maximum value during
            specific times.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.IntervalFieldNumber">
            <summary>Field number for the "interval" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Interval">
            <summary>
            The interval constraint takes a start, end, and size, and forces
            start + size == end.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.NoOverlapFieldNumber">
            <summary>Field number for the "no_overlap" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.NoOverlap">
            <summary>
            The no_overlap constraint prevents a set of intervals from
            overlapping; in scheduling, this is called a disjunctive
            constraint.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.NoOverlap2DFieldNumber">
            <summary>Field number for the "no_overlap_2d" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.NoOverlap2D">
            <summary>
            The no_overlap_2d constraint prevents a set of boxes from overlapping.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.CumulativeFieldNumber">
            <summary>Field number for the "cumulative" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Cumulative">
            <summary>
            The cumulative constraint ensures that for any integer point, the sum
            of the demands of the intervals containing that point does not exceed
            the capacity.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.DummyConstraintFieldNumber">
            <summary>Field number for the "dummy_constraint" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.DummyConstraint">
            <summary>
            This constraint is not meant to be used and will be rejected by the
            solver. It is meant to mark variable when testing the presolve code.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.ConstraintProto.ConstraintOneofCase">
            <summary>Enum of possible cases for the "constraint" oneof.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpObjectiveProto">
            <summary>
            Optimization objective.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpObjectiveProto.Vars">
            <summary>
            The linear terms of the objective to minimize.
            For a maximization problem, one can negate all coefficients in the
            objective and set scaling_factor to -1.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.CoeffsFieldNumber">
            <summary>Field number for the "coeffs" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.OffsetFieldNumber">
            <summary>Field number for the "offset" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpObjectiveProto.Offset">
             <summary>
             The displayed objective is always:
               scaling_factor * (sum(coefficients[i] * objective_vars[i]) + offset).
             This is needed to have a consistent objective after presolve or when
             scaling a double problem to express it with integers.
            
             Note that if scaling_factor is zero, then it is assumed to be 1, so that by
             default these fields have no effect.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.ScalingFactorFieldNumber">
            <summary>Field number for the "scaling_factor" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.DomainFieldNumber">
            <summary>Field number for the "domain" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpObjectiveProto.Domain">
            <summary>
            If non-empty, only look for an objective value in the given domain.
            Note that this does not depend on the offset or scaling factor, it is a
            domain on the sum of the objective terms only.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.ScalingWasExactFieldNumber">
            <summary>Field number for the "scaling_was_exact" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpObjectiveProto.ScalingWasExact">
             <summary>
             Internal field. Do not set. When we scale a FloatObjectiveProto to a
             integer version, we set this to true if the scaling was exact (i.e. all
             original coeff were integer for instance).
            
             TODO(user): Put the error bounds we computed instead?
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.IntegerBeforeOffsetFieldNumber">
            <summary>Field number for the "integer_before_offset" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpObjectiveProto.IntegerBeforeOffset">
             <summary>
             Internal fields to recover a bound on the original integer objective from
             the presolved one. Basically, initially the integer objective fit on an
             int64 and is in [Initial_lb, Initial_ub]. During presolve, we might change
             the linear expression to have a new domain [Presolved_lb, Presolved_ub]
             that will also always fit on an int64.
            
             The two domain will always be linked with an affine transformation between
             the two of the form:
               old = (new + before_offset) * integer_scaling_factor + after_offset.
             Note that we use both offsets to always be able to do the computation while
             staying in the int64 domain. In particular, the after_offset will always
             be in (-integer_scaling_factor, integer_scaling_factor).
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.IntegerAfterOffsetFieldNumber">
            <summary>Field number for the "integer_after_offset" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.IntegerScalingFactorFieldNumber">
            <summary>Field number for the "integer_scaling_factor" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.FloatObjectiveProto">
            <summary>
            A linear floating point objective: sum coeffs[i] * vars[i] + offset.
            Note that the variable can only still take integer value.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.FloatObjectiveProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.FloatObjectiveProto.CoeffsFieldNumber">
            <summary>Field number for the "coeffs" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.FloatObjectiveProto.OffsetFieldNumber">
            <summary>Field number for the "offset" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.FloatObjectiveProto.MaximizeFieldNumber">
            <summary>Field number for the "maximize" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.FloatObjectiveProto.Maximize">
            <summary>
            The optimization direction. The default is to minimize
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.DecisionStrategyProto">
            <summary>
            Define the strategy to follow when the solver needs to take a new decision.
            Note that this strategy is only defined on a subset of variables.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.DecisionStrategyProto.VariablesFieldNumber">
            <summary>Field number for the "variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.DecisionStrategyProto.Variables">
            <summary>
            The variables to be considered for the next decision. The order matter and
            is always used as a tie-breaker after the variable selection strategy
            criteria defined below.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.DecisionStrategyProto.ExprsFieldNumber">
            <summary>Field number for the "exprs" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.DecisionStrategyProto.Exprs">
             <summary>
             If this is set, then the variables field must be empty.
             We currently only support affine expression.
            
             Note that this is needed so that if a variable has an affine
             representative, we can properly transform a DecisionStrategyProto through
             presolve.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.DecisionStrategyProto.VariableSelectionStrategyFieldNumber">
            <summary>Field number for the "variable_selection_strategy" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.DecisionStrategyProto.DomainReductionStrategyFieldNumber">
            <summary>Field number for the "domain_reduction_strategy" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.DecisionStrategyProto.Types">
            <summary>Container for nested types declared in the DecisionStrategyProto message type.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.DecisionStrategyProto.Types.VariableSelectionStrategy">
             <summary>
             The order in which the variables (resp. affine expression) above should be
             considered. Note that only variables that are not already fixed are
             considered.
            
             TODO(user): extend as needed.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.DecisionStrategyProto.Types.DomainReductionStrategy">
             <summary>
             Once a variable (resp. affine expression) has been chosen, this enum
             describe what decision is taken on its domain.
            
             TODO(user): extend as needed.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.PartialVariableAssignment">
            <summary>
            This message encodes a partial (or full) assignment of the variables of a
            CpModelProto. The variable indices should be unique and valid variable
            indices.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.PartialVariableAssignment.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.PartialVariableAssignment.ValuesFieldNumber">
            <summary>Field number for the "values" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.SparsePermutationProto">
            <summary>
            A permutation of integers encoded as a list of cycles, hence the "sparse"
            format. The image of an element cycle[i] is cycle[(i + 1) % cycle_length].
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SparsePermutationProto.SupportFieldNumber">
            <summary>Field number for the "support" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SparsePermutationProto.Support">
            <summary>
            Each cycle is listed one after the other in the support field.
            The size of each cycle is given (in order) in the cycle_sizes field.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SparsePermutationProto.CycleSizesFieldNumber">
            <summary>Field number for the "cycle_sizes" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.DenseMatrixProto">
            <summary>
            A dense matrix of numbers encoded in a flat way, row by row.
            That is matrix[i][j] = entries[i * num_cols + j];
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.DenseMatrixProto.NumRowsFieldNumber">
            <summary>Field number for the "num_rows" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.DenseMatrixProto.NumColsFieldNumber">
            <summary>Field number for the "num_cols" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.DenseMatrixProto.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.SymmetryProto">
             <summary>
             EXPERIMENTAL. For now, this is meant to be used by the solver and not filled
             by clients.
            
             Hold symmetry information about the set of feasible solutions. If we permute
             the variable values of any feasible solution using one of the permutation
             described here, we should always get another feasible solution.
            
             We usually also enforce that the objective of the new solution is the same.
            
             The group of permutations encoded here is usually computed from the encoding
             of the model, so it is not meant to be a complete representation of the
             feasible solution symmetries, just a valid subgroup.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SymmetryProto.PermutationsFieldNumber">
            <summary>Field number for the "permutations" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SymmetryProto.Permutations">
            <summary>
            A list of variable indices permutations that leave the feasible space of
            solution invariant. Usually, we only encode a set of generators of the
            group.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SymmetryProto.OrbitopesFieldNumber">
            <summary>Field number for the "orbitopes" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SymmetryProto.Orbitopes">
             <summary>
             An orbitope is a special symmetry structure of the solution space. If the
             variable indices are arranged in a matrix (with no duplicates), then any
             permutation of the columns will be a valid permutation of the feasible
             space.
            
             This arise quite often. The typical example is a graph coloring problem
             where for each node i, you have j booleans to indicate its color. If the
             variables color_of_i_is_j are arranged in a matrix[i][j], then any columns
             permutations leave the problem invariant.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpModelProto">
            <summary>
            A constraint programming problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.Name">
            <summary>
            For debug/logging only. Can be empty.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.VariablesFieldNumber">
            <summary>Field number for the "variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.Variables">
            <summary>
            The associated Protos should be referred by their index in these fields.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.ConstraintsFieldNumber">
            <summary>Field number for the "constraints" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.ObjectiveFieldNumber">
            <summary>Field number for the "objective" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.Objective">
            <summary>
            The objective to minimize. Can be empty for pure decision problems.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.FloatingPointObjectiveFieldNumber">
            <summary>Field number for the "floating_point_objective" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.FloatingPointObjective">
             <summary>
             Advanced usage.
             It is invalid to have both an objective and a floating point objective.
            
             The objective of the model, in floating point format. The solver will
             automatically scale this to integer during expansion and thus convert it to
             a normal CpObjectiveProto. See the mip* parameters to control how this is
             scaled. In most situation the precision will be good enough, but you can
             see the logs to see what are the precision guaranteed when this is
             converted to a fixed point representation.
            
             Note that even if the precision is bad, the returned objective_value and
             best_objective_bound will be computed correctly. So at the end of the solve
             you can check the gap if you only want precise optimal.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.SearchStrategyFieldNumber">
            <summary>Field number for the "search_strategy" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.SearchStrategy">
             <summary>
             Defines the strategy that the solver should follow when the
             search_branching parameter is set to FIXED_SEARCH. Note that this strategy
             is also used as a heuristic when we are not in fixed search.
            
             Advanced Usage: if not all variables appears and the parameter
             "instantiate_all_variables" is set to false, then the solver will not try
             to instantiate the variables that do not appear. Thus, at the end of the
             search, not all variables may be fixed. Currently, we will set them to
             their lower bound in the solution.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.SolutionHintFieldNumber">
            <summary>Field number for the "solution_hint" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.SolutionHint">
             <summary>
             Solution hint.
            
             If a feasible or almost-feasible solution to the problem is already known,
             it may be helpful to pass it to the solver so that it can be used. The
             solver will try to use this information to create its initial feasible
             solution.
            
             Note that it may not always be faster to give a hint like this to the
             solver. There is also no guarantee that the solver will use this hint or
             try to return a solution "close" to this assignment in case of multiple
             optimal solutions.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.AssumptionsFieldNumber">
            <summary>Field number for the "assumptions" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.Assumptions">
             <summary>
             A list of literals. The model will be solved assuming all these literals
             are true. Compared to just fixing the domain of these literals, using this
             mechanism is slower but allows in case the model is INFEASIBLE to get a
             potentially small subset of them that can be used to explain the
             infeasibility.
            
             Think (IIS), except when you are only concerned by the provided
             assumptions. This is powerful as it allows to group a set of logically
             related constraint under only one enforcement literal which can potentially
             give you a good and interpretable explanation for infeasiblity.
            
             Such infeasibility explanation will be available in the
             sufficient_assumptions_for_infeasibility response field.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.SymmetryFieldNumber">
            <summary>Field number for the "symmetry" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.Symmetry">
             <summary>
             For now, this is not meant to be filled by a client writing a model, but
             by our preprocessing step.
            
             Information about the symmetries of the feasible solution space.
             These usually leaves the objective invariant.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpSolverSolution">
            <summary>
            Just a message used to store dense solution.
            This is used by the additional_solutions field.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverSolution.ValuesFieldNumber">
            <summary>Field number for the "values" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpSolverResponse">
             <summary>
             The response returned by a solver trying to solve a CpModelProto.
            
             Next id: 31
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.StatusFieldNumber">
            <summary>Field number for the "status" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.Status">
            <summary>
            The status of the solve.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.SolutionFieldNumber">
            <summary>Field number for the "solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.Solution">
            <summary>
            A feasible solution to the given problem. Depending on the returned status
            it may be optimal or just feasible. This is in one-to-one correspondence
            with a CpModelProto::variables repeated field and list the values of all
            the variables.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.ObjectiveValueFieldNumber">
            <summary>Field number for the "objective_value" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.ObjectiveValue">
            <summary>
            Only make sense for an optimization problem. The objective value of the
            returned solution if it is non-empty. If there is no solution, then for a
            minimization problem, this will be an upper-bound of the objective of any
            feasible solution, and a lower-bound for a maximization problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.BestObjectiveBoundFieldNumber">
            <summary>Field number for the "best_objective_bound" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.BestObjectiveBound">
            <summary>
            Only make sense for an optimization problem. A proven lower-bound on the
            objective for a minimization problem, or a proven upper-bound for a
            maximization problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.AdditionalSolutionsFieldNumber">
            <summary>Field number for the "additional_solutions" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.AdditionalSolutions">
             <summary>
             If the parameter fill_additional_solutions_in_response is set, then we
             copy all the solutions from our internal solution pool here.
            
             Note that the one returned in the solution field will likely appear here
             too. Do not rely on the solutions order as it depends on our internal
             representation (after postsolve).
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.TightenedVariablesFieldNumber">
            <summary>Field number for the "tightened_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.TightenedVariables">
             <summary>
             Advanced usage.
            
             If the option fill_tightened_domains_in_response is set, then this field
             will be a copy of the CpModelProto.variables where each domain has been
             reduced using the information the solver was able to derive. Note that this
             is only filled with the info derived during a normal search and we do not
             have any dedicated algorithm to improve it.
            
             Warning: if you didn't set keep_all_feasible_solutions_in_presolve, then
             these domains might exclude valid feasible solution. Otherwise for a
             feasibility problem, all feasible solution should be there.
            
             Warning: For an optimization problem, these will correspond to valid bounds
             for the problem of finding an improving solution to the best one found so
             far. It might be better to solve a feasibility version if one just want to
             explore the feasible region.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.SufficientAssumptionsForInfeasibilityFieldNumber">
            <summary>Field number for the "sufficient_assumptions_for_infeasibility" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.SufficientAssumptionsForInfeasibility">
             <summary>
             A subset of the model "assumptions" field. This will only be filled if the
             status is INFEASIBLE. This subset of assumption will be enough to still get
             an infeasible problem.
            
             This is related to what is called the irreducible inconsistent subsystem or
             IIS. Except one is only concerned by the provided assumptions. There is
             also no guarantee that we return an irreducible (aka minimal subset).
             However, this is based on SAT explanation and there is a good chance it is
             not too large.
            
             If you really want a minimal subset, a possible way to get one is by
             changing your model to minimize the number of assumptions at false, but
             this is likely an harder problem to solve.
            
             Important: Currently, this is minimized only in single-thread and if the
             problem is not an optimization problem, otherwise, it will always include
             all the assumptions.
            
             TODO(user): Allows for returning multiple core at once.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.IntegerObjectiveFieldNumber">
            <summary>Field number for the "integer_objective" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.IntegerObjective">
            <summary>
            Contains the integer objective optimized internally. This is only filled if
            the problem had a floating point objective, and on the final response, not
            the ones given to callbacks.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.InnerObjectiveLowerBoundFieldNumber">
            <summary>Field number for the "inner_objective_lower_bound" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.InnerObjectiveLowerBound">
             <summary>
             Advanced usage.
            
             A lower bound on the inner integer expression of the objective. This is
             either a bound on the expression in the returned integer_objective or on
             the integer expression of the original objective if the problem already has
             an integer objective.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumIntegersFieldNumber">
            <summary>Field number for the "num_integers" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.NumIntegers">
             <summary>
             Some statistics about the solve.
            
             Important: in multithread, this correspond the statistics of the first
             subsolver. Which is usually the one with the user defined parameters. Or
             the default-search if none are specified.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumBooleansFieldNumber">
            <summary>Field number for the "num_booleans" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumConflictsFieldNumber">
            <summary>Field number for the "num_conflicts" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumBranchesFieldNumber">
            <summary>Field number for the "num_branches" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumBinaryPropagationsFieldNumber">
            <summary>Field number for the "num_binary_propagations" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumIntegerPropagationsFieldNumber">
            <summary>Field number for the "num_integer_propagations" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumRestartsFieldNumber">
            <summary>Field number for the "num_restarts" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumLpIterationsFieldNumber">
            <summary>Field number for the "num_lp_iterations" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.WallTimeFieldNumber">
            <summary>Field number for the "wall_time" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.WallTime">
            <summary>
            The time counted from the beginning of the Solve() call.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.UserTimeFieldNumber">
            <summary>Field number for the "user_time" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.DeterministicTimeFieldNumber">
            <summary>Field number for the "deterministic_time" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.GapIntegralFieldNumber">
            <summary>Field number for the "gap_integral" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.GapIntegral">
            <summary>
            The integral of log(1 + absolute_objective_gap) over time.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.SolutionInfoFieldNumber">
            <summary>Field number for the "solution_info" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.SolutionInfo">
            <summary>
            Additional information about how the solution was found. It also stores
            model or parameters errors that caused the model to be invalid.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.SolveLogFieldNumber">
            <summary>Field number for the "solve_log" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.SolveLog">
            <summary>
            The solve log will be filled if the parameter log_to_response is set to
            true.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpModelServiceReflection">
            <summary>Holder for reflection information generated from ortools/sat/cp_model_service.proto</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelServiceReflection.Descriptor">
            <summary>File descriptor for ortools/sat/cp_model_service.proto</summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpSolverRequest">
            <summary>
            The request sent to the remote solve service.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverRequest.ModelFieldNumber">
            <summary>Field number for the "model" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverRequest.Model">
            <summary>
            The model to solve.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverRequest.ParametersFieldNumber">
            <summary>Field number for the "parameters" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverRequest.Parameters">
            <summary>
            Solver parameters.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParametersReflection">
            <summary>Holder for reflection information generated from ortools/sat/sat_parameters.proto</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParametersReflection.Descriptor">
            <summary>File descriptor for ortools/sat/sat_parameters.proto</summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters">
             <summary>
             Contains the definitions for all the sat algorithm parameters and their
             default values.
            
             NEXT TAG: 296
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.Name">
            <summary>
            In some context, like in a portfolio of search, it makes sense to name a
            given parameters set for logging purpose.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PreferredVariableOrderFieldNumber">
            <summary>Field number for the "preferred_variable_order" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPreferredVariableOrder">
            <summary>Gets whether the "preferred_variable_order" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPreferredVariableOrder">
            <summary>Clears the value of the "preferred_variable_order" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InitialPolarityFieldNumber">
            <summary>Field number for the "initial_polarity" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInitialPolarity">
            <summary>Gets whether the "initial_polarity" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInitialPolarity">
            <summary>Clears the value of the "initial_polarity" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UsePhaseSavingFieldNumber">
            <summary>Field number for the "use_phase_saving" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UsePhaseSaving">
             <summary>
             If this is true, then the polarity of a variable will be the last value it
             was assigned to, or its default polarity if it was never assigned since the
             call to ResetDecisionHeuristic().
            
             Actually, we use a newer version where we follow the last value in the
             longest non-conflicting partial assignment in the current phase.
            
             This is called 'literal phase saving'. For details see 'A Lightweight
             Component Caching Scheme for Satisfiability Solvers' K. Pipatsrisawat and
             A.Darwiche, In 10th International Conference on Theory and Applications of
             Satisfiability Testing, 2007.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUsePhaseSaving">
            <summary>Gets whether the "use_phase_saving" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUsePhaseSaving">
            <summary>Clears the value of the "use_phase_saving" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PolarityRephaseIncrementFieldNumber">
            <summary>Field number for the "polarity_rephase_increment" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PolarityRephaseIncrement">
            <summary>
            If non-zero, then we change the polarity heuristic after that many number
            of conflicts in an arithmetically increasing fashion. So x the first time,
            2 * x the second time, etc...
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPolarityRephaseIncrement">
            <summary>Gets whether the "polarity_rephase_increment" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPolarityRephaseIncrement">
            <summary>Clears the value of the "polarity_rephase_increment" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RandomPolarityRatioFieldNumber">
            <summary>Field number for the "random_polarity_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RandomPolarityRatio">
            <summary>
            The proportion of polarity chosen at random. Note that this take
            precedence over the phase saving heuristic. This is different from
            initial_polarity:POLARITY_RANDOM because it will select a new random
            polarity each time the variable is branched upon instead of selecting one
            initially and then always taking this choice.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRandomPolarityRatio">
            <summary>Gets whether the "random_polarity_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRandomPolarityRatio">
            <summary>Clears the value of the "random_polarity_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RandomBranchesRatioFieldNumber">
            <summary>Field number for the "random_branches_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RandomBranchesRatio">
            <summary>
            A number between 0 and 1 that indicates the proportion of branching
            variables that are selected randomly instead of choosing the first variable
            from the given variable_ordering strategy.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRandomBranchesRatio">
            <summary>Gets whether the "random_branches_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRandomBranchesRatio">
            <summary>Clears the value of the "random_branches_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseErwaHeuristicFieldNumber">
            <summary>Field number for the "use_erwa_heuristic" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseErwaHeuristic">
            <summary>
            Whether we use the ERWA (Exponential Recency Weighted Average) heuristic as
            described in "Learning Rate Based Branching Heuristic for SAT solvers",
            J.H.Liang, V. Ganesh, P. Poupart, K.Czarnecki, SAT 2016.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseErwaHeuristic">
            <summary>Gets whether the "use_erwa_heuristic" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseErwaHeuristic">
            <summary>Clears the value of the "use_erwa_heuristic" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InitialVariablesActivityFieldNumber">
            <summary>Field number for the "initial_variables_activity" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.InitialVariablesActivity">
            <summary>
            The initial value of the variables activity. A non-zero value only make
            sense when use_erwa_heuristic is true. Experiments with a value of 1e-2
            together with the ERWA heuristic showed slighthly better result than simply
            using zero. The idea is that when the "learning rate" of a variable becomes
            lower than this value, then we prefer to branch on never explored before
            variables. This is not in the ERWA paper.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInitialVariablesActivity">
            <summary>Gets whether the "initial_variables_activity" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInitialVariablesActivity">
            <summary>Clears the value of the "initial_variables_activity" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AlsoBumpVariablesInConflictReasonsFieldNumber">
            <summary>Field number for the "also_bump_variables_in_conflict_reasons" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AlsoBumpVariablesInConflictReasons">
            <summary>
            When this is true, then the variables that appear in any of the reason of
            the variables in a conflict have their activity bumped. This is addition to
            the variables in the conflict, and the one that were used during conflict
            resolution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAlsoBumpVariablesInConflictReasons">
            <summary>Gets whether the "also_bump_variables_in_conflict_reasons" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAlsoBumpVariablesInConflictReasons">
            <summary>Clears the value of the "also_bump_variables_in_conflict_reasons" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MinimizationAlgorithmFieldNumber">
            <summary>Field number for the "minimization_algorithm" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMinimizationAlgorithm">
            <summary>Gets whether the "minimization_algorithm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMinimizationAlgorithm">
            <summary>Clears the value of the "minimization_algorithm" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.BinaryMinimizationAlgorithmFieldNumber">
            <summary>Field number for the "binary_minimization_algorithm" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasBinaryMinimizationAlgorithm">
            <summary>Gets whether the "binary_minimization_algorithm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearBinaryMinimizationAlgorithm">
            <summary>Clears the value of the "binary_minimization_algorithm" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SubsumptionDuringConflictAnalysisFieldNumber">
            <summary>Field number for the "subsumption_during_conflict_analysis" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SubsumptionDuringConflictAnalysis">
            <summary>
            At a really low cost, during the 1-UIP conflict computation, it is easy to
            detect if some of the involved reasons are subsumed by the current
            conflict. When this is true, such clauses are detached and later removed
            from the problem.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSubsumptionDuringConflictAnalysis">
            <summary>Gets whether the "subsumption_during_conflict_analysis" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSubsumptionDuringConflictAnalysis">
            <summary>Clears the value of the "subsumption_during_conflict_analysis" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseCleanupPeriodFieldNumber">
            <summary>Field number for the "clause_cleanup_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ClauseCleanupPeriod">
            <summary>
            Trigger a cleanup when this number of "deletable" clauses is learned.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseCleanupPeriod">
            <summary>Gets whether the "clause_cleanup_period" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseCleanupPeriod">
            <summary>Clears the value of the "clause_cleanup_period" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseCleanupTargetFieldNumber">
            <summary>Field number for the "clause_cleanup_target" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ClauseCleanupTarget">
            <summary>
            During a cleanup, we will always keep that number of "deletable" clauses.
            Note that this doesn't include the "protected" clauses.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseCleanupTarget">
            <summary>Gets whether the "clause_cleanup_target" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseCleanupTarget">
            <summary>Clears the value of the "clause_cleanup_target" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseCleanupRatioFieldNumber">
            <summary>Field number for the "clause_cleanup_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ClauseCleanupRatio">
            <summary>
            During a cleanup, if clause_cleanup_target is 0, we will delete the
            clause_cleanup_ratio of "deletable" clauses instead of aiming for a fixed
            target of clauses to keep.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseCleanupRatio">
            <summary>Gets whether the "clause_cleanup_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseCleanupRatio">
            <summary>Clears the value of the "clause_cleanup_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseCleanupProtectionFieldNumber">
            <summary>Field number for the "clause_cleanup_protection" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseCleanupProtection">
            <summary>Gets whether the "clause_cleanup_protection" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseCleanupProtection">
            <summary>Clears the value of the "clause_cleanup_protection" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseCleanupLbdBoundFieldNumber">
            <summary>Field number for the "clause_cleanup_lbd_bound" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ClauseCleanupLbdBound">
            <summary>
            All the clauses with a LBD (literal blocks distance) lower or equal to this
            parameters will always be kept.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseCleanupLbdBound">
            <summary>Gets whether the "clause_cleanup_lbd_bound" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseCleanupLbdBound">
            <summary>Clears the value of the "clause_cleanup_lbd_bound" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseCleanupOrderingFieldNumber">
            <summary>Field number for the "clause_cleanup_ordering" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseCleanupOrdering">
            <summary>Gets whether the "clause_cleanup_ordering" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseCleanupOrdering">
            <summary>Clears the value of the "clause_cleanup_ordering" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PbCleanupIncrementFieldNumber">
            <summary>Field number for the "pb_cleanup_increment" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PbCleanupIncrement">
            <summary>
            Same as for the clauses, but for the learned pseudo-Boolean constraints.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPbCleanupIncrement">
            <summary>Gets whether the "pb_cleanup_increment" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPbCleanupIncrement">
            <summary>Clears the value of the "pb_cleanup_increment" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PbCleanupRatioFieldNumber">
            <summary>Field number for the "pb_cleanup_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPbCleanupRatio">
            <summary>Gets whether the "pb_cleanup_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPbCleanupRatio">
            <summary>Clears the value of the "pb_cleanup_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.VariableActivityDecayFieldNumber">
            <summary>Field number for the "variable_activity_decay" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.VariableActivityDecay">
             <summary>
             Each time a conflict is found, the activities of some variables are
             increased by one. Then, the activity of all variables are multiplied by
             variable_activity_decay.
            
             To implement this efficiently, the activity of all the variables is not
             decayed at each conflict. Instead, the activity increment is multiplied by
             1 / decay. When an activity reach max_variable_activity_value, all the
             activity are multiplied by 1 / max_variable_activity_value.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasVariableActivityDecay">
            <summary>Gets whether the "variable_activity_decay" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearVariableActivityDecay">
            <summary>Clears the value of the "variable_activity_decay" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxVariableActivityValueFieldNumber">
            <summary>Field number for the "max_variable_activity_value" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxVariableActivityValue">
            <summary>Gets whether the "max_variable_activity_value" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxVariableActivityValue">
            <summary>Clears the value of the "max_variable_activity_value" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.GlucoseMaxDecayFieldNumber">
            <summary>Field number for the "glucose_max_decay" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.GlucoseMaxDecay">
             <summary>
             The activity starts at 0.8 and increment by 0.01 every 5000 conflicts until
             0.95. This "hack" seems to work well and comes from:
            
             Glucose 2.3 in the SAT 2013 Competition - SAT Competition 2013
             http://edacc4.informatik.uni-ulm.de/SC13/solver-description-download/136
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasGlucoseMaxDecay">
            <summary>Gets whether the "glucose_max_decay" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearGlucoseMaxDecay">
            <summary>Clears the value of the "glucose_max_decay" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.GlucoseDecayIncrementFieldNumber">
            <summary>Field number for the "glucose_decay_increment" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasGlucoseDecayIncrement">
            <summary>Gets whether the "glucose_decay_increment" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearGlucoseDecayIncrement">
            <summary>Clears the value of the "glucose_decay_increment" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.GlucoseDecayIncrementPeriodFieldNumber">
            <summary>Field number for the "glucose_decay_increment_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasGlucoseDecayIncrementPeriod">
            <summary>Gets whether the "glucose_decay_increment_period" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearGlucoseDecayIncrementPeriod">
            <summary>Clears the value of the "glucose_decay_increment_period" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseActivityDecayFieldNumber">
            <summary>Field number for the "clause_activity_decay" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ClauseActivityDecay">
            <summary>
            Clause activity parameters (same effect as the one on the variables).
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseActivityDecay">
            <summary>Gets whether the "clause_activity_decay" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseActivityDecay">
            <summary>Clears the value of the "clause_activity_decay" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxClauseActivityValueFieldNumber">
            <summary>Field number for the "max_clause_activity_value" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxClauseActivityValue">
            <summary>Gets whether the "max_clause_activity_value" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxClauseActivityValue">
            <summary>Clears the value of the "max_clause_activity_value" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RestartAlgorithmsFieldNumber">
            <summary>Field number for the "restart_algorithms" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RestartAlgorithms">
             <summary>
             The restart strategies will change each time the strategy_counter is
             increased. The current strategy will simply be the one at index
             strategy_counter modulo the number of strategy. Note that if this list
             includes a NO_RESTART, nothing will change when it is reached because the
             strategy_counter will only increment after a restart.
            
             The idea of switching of search strategy tailored for SAT/UNSAT comes from
             Chanseok Oh with his COMiniSatPS solver, see http://cs.nyu.edu/~chanseok/.
             But more generally, it seems REALLY beneficial to try different strategy.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.DefaultRestartAlgorithmsFieldNumber">
            <summary>Field number for the "default_restart_algorithms" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasDefaultRestartAlgorithms">
            <summary>Gets whether the "default_restart_algorithms" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearDefaultRestartAlgorithms">
            <summary>Clears the value of the "default_restart_algorithms" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RestartPeriodFieldNumber">
            <summary>Field number for the "restart_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RestartPeriod">
            <summary>
            Restart period for the FIXED_RESTART strategy. This is also the multiplier
            used by the LUBY_RESTART strategy.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRestartPeriod">
            <summary>Gets whether the "restart_period" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRestartPeriod">
            <summary>Clears the value of the "restart_period" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RestartRunningWindowSizeFieldNumber">
            <summary>Field number for the "restart_running_window_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RestartRunningWindowSize">
            <summary>
            Size of the window for the moving average restarts.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRestartRunningWindowSize">
            <summary>Gets whether the "restart_running_window_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRestartRunningWindowSize">
            <summary>Clears the value of the "restart_running_window_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RestartDlAverageRatioFieldNumber">
            <summary>Field number for the "restart_dl_average_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RestartDlAverageRatio">
            <summary>
            In the moving average restart algorithms, a restart is triggered if the
            window average times this ratio is greater that the global average.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRestartDlAverageRatio">
            <summary>Gets whether the "restart_dl_average_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRestartDlAverageRatio">
            <summary>Clears the value of the "restart_dl_average_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RestartLbdAverageRatioFieldNumber">
            <summary>Field number for the "restart_lbd_average_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRestartLbdAverageRatio">
            <summary>Gets whether the "restart_lbd_average_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRestartLbdAverageRatio">
            <summary>Clears the value of the "restart_lbd_average_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseBlockingRestartFieldNumber">
            <summary>Field number for the "use_blocking_restart" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseBlockingRestart">
            <summary>
            Block a moving restart algorithm if the trail size of the current conflict
            is greater than the multiplier times the moving average of the trail size
            at the previous conflicts.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseBlockingRestart">
            <summary>Gets whether the "use_blocking_restart" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseBlockingRestart">
            <summary>Clears the value of the "use_blocking_restart" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.BlockingRestartWindowSizeFieldNumber">
            <summary>Field number for the "blocking_restart_window_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasBlockingRestartWindowSize">
            <summary>Gets whether the "blocking_restart_window_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearBlockingRestartWindowSize">
            <summary>Clears the value of the "blocking_restart_window_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.BlockingRestartMultiplierFieldNumber">
            <summary>Field number for the "blocking_restart_multiplier" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasBlockingRestartMultiplier">
            <summary>Gets whether the "blocking_restart_multiplier" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearBlockingRestartMultiplier">
            <summary>Clears the value of the "blocking_restart_multiplier" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.NumConflictsBeforeStrategyChangesFieldNumber">
            <summary>Field number for the "num_conflicts_before_strategy_changes" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.NumConflictsBeforeStrategyChanges">
            <summary>
            After each restart, if the number of conflict since the last strategy
            change is greater that this, then we increment a "strategy_counter" that
            can be use to change the search strategy used by the following restarts.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasNumConflictsBeforeStrategyChanges">
            <summary>Gets whether the "num_conflicts_before_strategy_changes" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearNumConflictsBeforeStrategyChanges">
            <summary>Clears the value of the "num_conflicts_before_strategy_changes" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.StrategyChangeIncreaseRatioFieldNumber">
            <summary>Field number for the "strategy_change_increase_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.StrategyChangeIncreaseRatio">
            <summary>
            The parameter num_conflicts_before_strategy_changes is increased by that
            much after each strategy change.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasStrategyChangeIncreaseRatio">
            <summary>Gets whether the "strategy_change_increase_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearStrategyChangeIncreaseRatio">
            <summary>Clears the value of the "strategy_change_increase_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxTimeInSecondsFieldNumber">
            <summary>Field number for the "max_time_in_seconds" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxTimeInSeconds">
            <summary>
            Maximum time allowed in seconds to solve a problem.
            The counter will starts at the beginning of the Solve() call.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxTimeInSeconds">
            <summary>Gets whether the "max_time_in_seconds" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxTimeInSeconds">
            <summary>Clears the value of the "max_time_in_seconds" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxDeterministicTimeFieldNumber">
            <summary>Field number for the "max_deterministic_time" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxDeterministicTime">
            <summary>
            Maximum time allowed in deterministic time to solve a problem.
            The deterministic time should be correlated with the real time used by the
            solver, the time unit being as close as possible to a second.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxDeterministicTime">
            <summary>Gets whether the "max_deterministic_time" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxDeterministicTime">
            <summary>Clears the value of the "max_deterministic_time" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxNumDeterministicBatchesFieldNumber">
            <summary>Field number for the "max_num_deterministic_batches" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxNumDeterministicBatches">
            <summary>
            Stops after that number of batches has been scheduled. This only make sense
            when interleave_search is true.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxNumDeterministicBatches">
            <summary>Gets whether the "max_num_deterministic_batches" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxNumDeterministicBatches">
            <summary>Clears the value of the "max_num_deterministic_batches" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxNumberOfConflictsFieldNumber">
            <summary>Field number for the "max_number_of_conflicts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxNumberOfConflicts">
             <summary>
             Maximum number of conflicts allowed to solve a problem.
            
             TODO(user): Maybe change the way the conflict limit is enforced?
             currently it is enforced on each independent internal SAT solve, rather
             than on the overall number of conflicts across all solves. So in the
             context of an optimization problem, this is not really usable directly by a
             client.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxNumberOfConflicts">
            <summary>Gets whether the "max_number_of_conflicts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxNumberOfConflicts">
            <summary>Clears the value of the "max_number_of_conflicts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxMemoryInMbFieldNumber">
            <summary>Field number for the "max_memory_in_mb" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxMemoryInMb">
             <summary>
             Maximum memory allowed for the whole thread containing the solver. The
             solver will abort as soon as it detects that this limit is crossed. As a
             result, this limit is approximative, but usually the solver will not go too
             much over.
            
             TODO(user): This is only used by the pure SAT solver, generalize to CP-SAT.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxMemoryInMb">
            <summary>Gets whether the "max_memory_in_mb" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxMemoryInMb">
            <summary>Clears the value of the "max_memory_in_mb" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AbsoluteGapLimitFieldNumber">
            <summary>Field number for the "absolute_gap_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AbsoluteGapLimit">
             <summary>
             Stop the search when the gap between the best feasible objective (O) and
             our best objective bound (B) is smaller than a limit.
             The exact definition is:
             - Absolute: abs(O - B)
             - Relative: abs(O - B) / max(1, abs(O)).
            
             Important: The relative gap depends on the objective offset! If you
             artificially shift the objective, you will get widely different value of
             the relative gap.
            
             Note that if the gap is reached, the search status will be OPTIMAL. But
             one can check the best objective bound to see the actual gap.
            
             If the objective is integer, then any absolute gap &lt; 1 will lead to a true
             optimal. If the objective is floating point, a gap of zero make little
             sense so is is why we use a non-zero default value. At the end of the
             search, we will display a warning if OPTIMAL is reported yet the gap is
             greater than this absolute gap.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAbsoluteGapLimit">
            <summary>Gets whether the "absolute_gap_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAbsoluteGapLimit">
            <summary>Clears the value of the "absolute_gap_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RelativeGapLimitFieldNumber">
            <summary>Field number for the "relative_gap_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRelativeGapLimit">
            <summary>Gets whether the "relative_gap_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRelativeGapLimit">
            <summary>Clears the value of the "relative_gap_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RandomSeedFieldNumber">
            <summary>Field number for the "random_seed" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RandomSeed">
             <summary>
             At the beginning of each solve, the random number generator used in some
             part of the solver is reinitialized to this seed. If you change the random
             seed, the solver may make different choices during the solving process.
            
             For some problems, the running time may vary a lot depending on small
             change in the solving algorithm. Running the solver with different seeds
             enables to have more robust benchmarks when evaluating new features.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRandomSeed">
            <summary>Gets whether the "random_seed" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRandomSeed">
            <summary>Clears the value of the "random_seed" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PermuteVariableRandomlyFieldNumber">
            <summary>Field number for the "permute_variable_randomly" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PermuteVariableRandomly">
            <summary>
            This is mainly here to test the solver variability. Note that in tests, if
            not explicitly set to false, all 3 options will be set to true so that
            clients do not rely on the solver returning a specific solution if they are
            many equivalent optimal solutions.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPermuteVariableRandomly">
            <summary>Gets whether the "permute_variable_randomly" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPermuteVariableRandomly">
            <summary>Clears the value of the "permute_variable_randomly" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PermutePresolveConstraintOrderFieldNumber">
            <summary>Field number for the "permute_presolve_constraint_order" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPermutePresolveConstraintOrder">
            <summary>Gets whether the "permute_presolve_constraint_order" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPermutePresolveConstraintOrder">
            <summary>Clears the value of the "permute_presolve_constraint_order" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseAbslRandomFieldNumber">
            <summary>Field number for the "use_absl_random" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseAbslRandom">
            <summary>Gets whether the "use_absl_random" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseAbslRandom">
            <summary>Clears the value of the "use_absl_random" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LogSearchProgressFieldNumber">
            <summary>Field number for the "log_search_progress" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LogSearchProgress">
            <summary>
            Whether the solver should log the search progress. This is the maing
            logging parameter and if this is false, none of the logging (callbacks,
            log_to_stdout, log_to_response, ...) will do anything.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLogSearchProgress">
            <summary>Gets whether the "log_search_progress" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLogSearchProgress">
            <summary>Clears the value of the "log_search_progress" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LogSubsolverStatisticsFieldNumber">
            <summary>Field number for the "log_subsolver_statistics" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LogSubsolverStatistics">
            <summary>
            Whether the solver should display per sub-solver search statistics.
            This is only useful is log_search_progress is set to true, and if the
            number of search workers is > 1. Note that in all case we display a bit
            of stats with one line per subsolver.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLogSubsolverStatistics">
            <summary>Gets whether the "log_subsolver_statistics" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLogSubsolverStatistics">
            <summary>Clears the value of the "log_subsolver_statistics" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LogPrefixFieldNumber">
            <summary>Field number for the "log_prefix" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LogPrefix">
            <summary>
            Add a prefix to all logs.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLogPrefix">
            <summary>Gets whether the "log_prefix" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLogPrefix">
            <summary>Clears the value of the "log_prefix" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LogToStdoutFieldNumber">
            <summary>Field number for the "log_to_stdout" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LogToStdout">
            <summary>
            Log to stdout.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLogToStdout">
            <summary>Gets whether the "log_to_stdout" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLogToStdout">
            <summary>Clears the value of the "log_to_stdout" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LogToResponseFieldNumber">
            <summary>Field number for the "log_to_response" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LogToResponse">
            <summary>
            Log to response proto.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLogToResponse">
            <summary>Gets whether the "log_to_response" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLogToResponse">
            <summary>Clears the value of the "log_to_response" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UsePbResolutionFieldNumber">
            <summary>Field number for the "use_pb_resolution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UsePbResolution">
            <summary>
            Whether to use pseudo-Boolean resolution to analyze a conflict. Note that
            this option only make sense if your problem is modelized using
            pseudo-Boolean constraints. If you only have clauses, this shouldn't change
            anything (except slow the solver down).
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUsePbResolution">
            <summary>Gets whether the "use_pb_resolution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUsePbResolution">
            <summary>Clears the value of the "use_pb_resolution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MinimizeReductionDuringPbResolutionFieldNumber">
            <summary>Field number for the "minimize_reduction_during_pb_resolution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MinimizeReductionDuringPbResolution">
            <summary>
            A different algorithm during PB resolution. It minimizes the number of
            calls to ReduceCoefficients() which can be time consuming. However, the
            search space will be different and if the coefficients are large, this may
            lead to integer overflows that could otherwise be prevented.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMinimizeReductionDuringPbResolution">
            <summary>Gets whether the "minimize_reduction_during_pb_resolution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMinimizeReductionDuringPbResolution">
            <summary>Clears the value of the "minimize_reduction_during_pb_resolution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CountAssumptionLevelsInLbdFieldNumber">
            <summary>Field number for the "count_assumption_levels_in_lbd" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CountAssumptionLevelsInLbd">
             <summary>
             Whether or not the assumption levels are taken into account during the LBD
             computation. According to the reference below, not counting them improves
             the solver in some situation. Note that this only impact solves under
             assumptions.
            
             Gilles Audemard, Jean-Marie Lagniez, Laurent Simon, "Improving Glucose for
             Incremental SAT Solving with Assumptions: Application to MUS Extraction"
             Theory and Applications of Satisfiability Testing - SAT 2013, Lecture Notes
             in Computer Science Volume 7962, 2013, pp 309-317.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCountAssumptionLevelsInLbd">
            <summary>Gets whether the "count_assumption_levels_in_lbd" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCountAssumptionLevelsInLbd">
            <summary>Clears the value of the "count_assumption_levels_in_lbd" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveBveThresholdFieldNumber">
            <summary>Field number for the "presolve_bve_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveBveThreshold">
            <summary>
            During presolve, only try to perform the bounded variable elimination (BVE)
            of a variable x if the number of occurrences of x times the number of
            occurrences of not(x) is not greater than this parameter.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveBveThreshold">
            <summary>Gets whether the "presolve_bve_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveBveThreshold">
            <summary>Clears the value of the "presolve_bve_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveBveClauseWeightFieldNumber">
            <summary>Field number for the "presolve_bve_clause_weight" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveBveClauseWeight">
            <summary>
            During presolve, we apply BVE only if this weight times the number of
            clauses plus the number of clause literals is not increased.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveBveClauseWeight">
            <summary>Gets whether the "presolve_bve_clause_weight" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveBveClauseWeight">
            <summary>Clears the value of the "presolve_bve_clause_weight" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ProbingDeterministicTimeLimitFieldNumber">
            <summary>Field number for the "probing_deterministic_time_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ProbingDeterministicTimeLimit">
             <summary>
             The maximum "deterministic" time limit to spend in probing. A value of
             zero will disable the probing.
            
             TODO(user): Clean up. The first one is used in CP-SAT, the other in pure
             SAT presolve.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasProbingDeterministicTimeLimit">
            <summary>Gets whether the "probing_deterministic_time_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearProbingDeterministicTimeLimit">
            <summary>Clears the value of the "probing_deterministic_time_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveProbingDeterministicTimeLimitFieldNumber">
            <summary>Field number for the "presolve_probing_deterministic_time_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveProbingDeterministicTimeLimit">
            <summary>Gets whether the "presolve_probing_deterministic_time_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveProbingDeterministicTimeLimit">
            <summary>Clears the value of the "presolve_probing_deterministic_time_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveBlockedClauseFieldNumber">
            <summary>Field number for the "presolve_blocked_clause" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveBlockedClause">
            <summary>
            Whether we use an heuristic to detect some basic case of blocked clause
            in the SAT presolve.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveBlockedClause">
            <summary>Gets whether the "presolve_blocked_clause" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveBlockedClause">
            <summary>Clears the value of the "presolve_blocked_clause" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveUseBvaFieldNumber">
            <summary>Field number for the "presolve_use_bva" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveUseBva">
            <summary>
            Whether or not we use Bounded Variable Addition (BVA) in the presolve.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveUseBva">
            <summary>Gets whether the "presolve_use_bva" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveUseBva">
            <summary>Clears the value of the "presolve_use_bva" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveBvaThresholdFieldNumber">
            <summary>Field number for the "presolve_bva_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveBvaThreshold">
            <summary>
            Apply Bounded Variable Addition (BVA) if the number of clauses is reduced
            by stricly more than this threshold. The algorithm described in the paper
            uses 0, but quick experiments showed that 1 is a good value. It may not be
            worth it to add a new variable just to remove one clause.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveBvaThreshold">
            <summary>Gets whether the "presolve_bva_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveBvaThreshold">
            <summary>Clears the value of the "presolve_bva_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxPresolveIterationsFieldNumber">
            <summary>Field number for the "max_presolve_iterations" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxPresolveIterations">
            <summary>
            In case of large reduction in a presolve iteration, we perform multiple
            presolve iterations. This parameter controls the maximum number of such
            presolve iterations.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxPresolveIterations">
            <summary>Gets whether the "max_presolve_iterations" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxPresolveIterations">
            <summary>Clears the value of the "max_presolve_iterations" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CpModelPresolveFieldNumber">
            <summary>Field number for the "cp_model_presolve" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CpModelPresolve">
            <summary>
            Whether we presolve the cp_model before solving it.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCpModelPresolve">
            <summary>Gets whether the "cp_model_presolve" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCpModelPresolve">
            <summary>Clears the value of the "cp_model_presolve" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CpModelProbingLevelFieldNumber">
            <summary>Field number for the "cp_model_probing_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CpModelProbingLevel">
            <summary>
            How much effort do we spend on probing. 0 disables it completely.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCpModelProbingLevel">
            <summary>Gets whether the "cp_model_probing_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCpModelProbingLevel">
            <summary>Clears the value of the "cp_model_probing_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CpModelUseSatPresolveFieldNumber">
            <summary>Field number for the "cp_model_use_sat_presolve" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CpModelUseSatPresolve">
            <summary>
            Whether we also use the sat presolve when cp_model_presolve is true.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCpModelUseSatPresolve">
            <summary>Gets whether the "cp_model_use_sat_presolve" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCpModelUseSatPresolve">
            <summary>Clears the value of the "cp_model_use_sat_presolve" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.DetectTableWithCostFieldNumber">
            <summary>Field number for the "detect_table_with_cost" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.DetectTableWithCost">
             <summary>
             If true, we detect variable that are unique to a table constraint and only
             there to encode a cost on each tuple. This is usually the case when a WCSP
             (weighted constraint program) is encoded into CP-SAT format.
            
             This can lead to a dramatic speed-up for such problems but is still
             experimental at this point.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasDetectTableWithCost">
            <summary>Gets whether the "detect_table_with_cost" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearDetectTableWithCost">
            <summary>Clears the value of the "detect_table_with_cost" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.TableCompressionLevelFieldNumber">
            <summary>Field number for the "table_compression_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.TableCompressionLevel">
            <summary>
            How much we try to "compress" a table constraint. Compressing more leads to
            less Booleans and faster propagation but can reduced the quality of the lp
            relaxation. Values goes from 0 to 3 where we always try to fully compress a
            table. At 2, we try to automatically decide if it is worth it.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasTableCompressionLevel">
            <summary>Gets whether the "table_compression_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearTableCompressionLevel">
            <summary>Clears the value of the "table_compression_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExpandAlldiffConstraintsFieldNumber">
            <summary>Field number for the "expand_alldiff_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExpandAlldiffConstraints">
            <summary>
            If true, expand all_different constraints that are not permutations.
            Permutations (#Variables = #Values) are always expanded.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExpandAlldiffConstraints">
            <summary>Gets whether the "expand_alldiff_constraints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExpandAlldiffConstraints">
            <summary>Clears the value of the "expand_alldiff_constraints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExpandReservoirConstraintsFieldNumber">
            <summary>Field number for the "expand_reservoir_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExpandReservoirConstraints">
            <summary>
            If true, expand the reservoir constraints by creating booleans for all
            possible precedences between event and encoding the constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExpandReservoirConstraints">
            <summary>Gets whether the "expand_reservoir_constraints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExpandReservoirConstraints">
            <summary>Clears the value of the "expand_reservoir_constraints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExpandReservoirUsingCircuitFieldNumber">
            <summary>Field number for the "expand_reservoir_using_circuit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExpandReservoirUsingCircuit">
             <summary>
             Mainly useful for testing.
            
             If this and expand_reservoir_constraints is true, we use a different
             encoding of the reservoir constraint using circuit instead of precedences.
             Note that this is usually slower, but can exercise different part of the
             solver. Note that contrary to the precedence encoding, this easily support
             variable demands.
            
             WARNING: with this encoding, the constraint take a slighlty different
             meaning. The level must be within the reservoir for any permutation of the
             events. So we cannot have +100 and -100 at the same time if the maximum
             level is 10 (as autorized by the reservoir constraint).
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExpandReservoirUsingCircuit">
            <summary>Gets whether the "expand_reservoir_using_circuit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExpandReservoirUsingCircuit">
            <summary>Clears the value of the "expand_reservoir_using_circuit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.EncodeCumulativeAsReservoirFieldNumber">
            <summary>Field number for the "encode_cumulative_as_reservoir" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.EncodeCumulativeAsReservoir">
            <summary>
            Encore cumulative with fixed demands and capacity as a reservoir
            constraint. The only reason you might want to do that is to test the
            reservoir propagation code!
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasEncodeCumulativeAsReservoir">
            <summary>Gets whether the "encode_cumulative_as_reservoir" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearEncodeCumulativeAsReservoir">
            <summary>Clears the value of the "encode_cumulative_as_reservoir" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxLinMaxSizeForExpansionFieldNumber">
            <summary>Field number for the "max_lin_max_size_for_expansion" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxLinMaxSizeForExpansion">
             <summary>
             If the number of expressions in the lin_max is less that the max size
             parameter, model expansion replaces target = max(xi) by linear constraint
             with the introduction of new booleans bi such that bi => target == xi.
            
             This is mainly for experimenting compared to a custom lin_max propagator.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxLinMaxSizeForExpansion">
            <summary>Gets whether the "max_lin_max_size_for_expansion" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxLinMaxSizeForExpansion">
            <summary>Clears the value of the "max_lin_max_size_for_expansion" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.DisableConstraintExpansionFieldNumber">
            <summary>Field number for the "disable_constraint_expansion" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.DisableConstraintExpansion">
            <summary>
            If true, it disable all constraint expansion.
            This should only be used to test the presolve of expanded constraints.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasDisableConstraintExpansion">
            <summary>Gets whether the "disable_constraint_expansion" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearDisableConstraintExpansion">
            <summary>Clears the value of the "disable_constraint_expansion" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.EncodeComplexLinearConstraintWithIntegerFieldNumber">
            <summary>Field number for the "encode_complex_linear_constraint_with_integer" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.EncodeComplexLinearConstraintWithInteger">
            <summary>
            Linear constraint with a complex right hand side (more than a single
            interval) need to be expanded, there is a couple of way to do that.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasEncodeComplexLinearConstraintWithInteger">
            <summary>Gets whether the "encode_complex_linear_constraint_with_integer" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearEncodeComplexLinearConstraintWithInteger">
            <summary>Clears the value of the "encode_complex_linear_constraint_with_integer" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MergeNoOverlapWorkLimitFieldNumber">
            <summary>Field number for the "merge_no_overlap_work_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MergeNoOverlapWorkLimit">
            <summary>
            During presolve, we use a maximum clique heuristic to merge together
            no-overlap constraints or at most one constraints. This code can be slow,
            so we have a limit in place on the number of explored nodes in the
            underlying graph. The internal limit is an int64, but we use double here to
            simplify manual input.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMergeNoOverlapWorkLimit">
            <summary>Gets whether the "merge_no_overlap_work_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMergeNoOverlapWorkLimit">
            <summary>Clears the value of the "merge_no_overlap_work_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MergeAtMostOneWorkLimitFieldNumber">
            <summary>Field number for the "merge_at_most_one_work_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMergeAtMostOneWorkLimit">
            <summary>Gets whether the "merge_at_most_one_work_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMergeAtMostOneWorkLimit">
            <summary>Clears the value of the "merge_at_most_one_work_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveSubstitutionLevelFieldNumber">
            <summary>Field number for the "presolve_substitution_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveSubstitutionLevel">
            <summary>
            How much substitution (also called free variable aggregation in MIP
            litterature) should we perform at presolve. This currently only concerns
            variable appearing only in linear constraints. For now the value 0 turns it
            off and any positive value performs substitution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveSubstitutionLevel">
            <summary>Gets whether the "presolve_substitution_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveSubstitutionLevel">
            <summary>Clears the value of the "presolve_substitution_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveExtractIntegerEnforcementFieldNumber">
            <summary>Field number for the "presolve_extract_integer_enforcement" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveExtractIntegerEnforcement">
            <summary>
            If true, we will extract from linear constraints, enforcement literals of
            the form "integer variable at bound => simplified constraint". This should
            always be beneficial except that we don't always handle them as efficiently
            as we could for now. This causes problem on manna81.mps (LP relaxation not
            as tight it seems) and on neos-3354841-apure.mps.gz (too many literals
            created this way).
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveExtractIntegerEnforcement">
            <summary>Gets whether the "presolve_extract_integer_enforcement" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveExtractIntegerEnforcement">
            <summary>Clears the value of the "presolve_extract_integer_enforcement" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveInclusionWorkLimitFieldNumber">
            <summary>Field number for the "presolve_inclusion_work_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveInclusionWorkLimit">
             <summary>
             A few presolve operations involve detecting constraints included in other
             constraint. Since there can be a quadratic number of such pairs, and
             processing them usually involve scanning them, the complexity of these
             operations can be big. This enforce a local deterministic limit on the
             number of entries scanned. Default is 1e8.
            
             A value of zero will disable these presolve rules completely.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveInclusionWorkLimit">
            <summary>Gets whether the "presolve_inclusion_work_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveInclusionWorkLimit">
            <summary>Clears the value of the "presolve_inclusion_work_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.IgnoreNamesFieldNumber">
            <summary>Field number for the "ignore_names" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.IgnoreNames">
            <summary>
            If true, we don't keep names in our internal copy of the user given model.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasIgnoreNames">
            <summary>Gets whether the "ignore_names" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearIgnoreNames">
            <summary>Clears the value of the "ignore_names" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InferAllDiffsFieldNumber">
            <summary>Field number for the "infer_all_diffs" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.InferAllDiffs">
             <summary>
             Run a max-clique code amongst all the x != y we can find and try to infer
             set of variables that are all different. This allows to close neos16.mps
             for instance. Note that we only run this code if there is no all_diff
             already in the model so that if a user want to add some all_diff, we assume
             it is well done and do not try to add more.
            
             This will also detect and add no_overlap constraints, if all the relations
             x != y have "offsets" between them. I.e. x > y + offset.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInferAllDiffs">
            <summary>Gets whether the "infer_all_diffs" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInferAllDiffs">
            <summary>Clears the value of the "infer_all_diffs" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FindBigLinearOverlapFieldNumber">
            <summary>Field number for the "find_big_linear_overlap" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FindBigLinearOverlap">
            <summary>
            Try to find large "rectangle" in the linear constraint matrix with
            identical lines. If such rectangle is big enough, we can introduce a new
            integer variable corresponding to the common expression and greatly reduce
            the number of non-zero.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFindBigLinearOverlap">
            <summary>Gets whether the "find_big_linear_overlap" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFindBigLinearOverlap">
            <summary>Clears the value of the "find_big_linear_overlap" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseSatInprocessingFieldNumber">
            <summary>Field number for the "use_sat_inprocessing" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseSatInprocessing">
            <summary>
            Enable or disable "inprocessing" which is some SAT presolving done at
            each restart to the root level.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseSatInprocessing">
            <summary>Gets whether the "use_sat_inprocessing" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseSatInprocessing">
            <summary>Clears the value of the "use_sat_inprocessing" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InprocessingDtimeRatioFieldNumber">
            <summary>Field number for the "inprocessing_dtime_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.InprocessingDtimeRatio">
            <summary>
            Proportion of deterministic time we should spend on inprocessing.
            At each "restart", if the proportion is below this ratio, we will do some
            inprocessing, otherwise, we skip it for this restart.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInprocessingDtimeRatio">
            <summary>Gets whether the "inprocessing_dtime_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInprocessingDtimeRatio">
            <summary>Clears the value of the "inprocessing_dtime_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InprocessingProbingDtimeFieldNumber">
            <summary>Field number for the "inprocessing_probing_dtime" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.InprocessingProbingDtime">
            <summary>
            The amount of dtime we should spend on probing for each inprocessing round.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInprocessingProbingDtime">
            <summary>Gets whether the "inprocessing_probing_dtime" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInprocessingProbingDtime">
            <summary>Clears the value of the "inprocessing_probing_dtime" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InprocessingMinimizationDtimeFieldNumber">
            <summary>Field number for the "inprocessing_minimization_dtime" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.InprocessingMinimizationDtime">
             <summary>
             Parameters for an heuristic similar to the one described in "An effective
             learnt clause minimization approach for CDCL Sat Solvers",
             https://www.ijcai.org/proceedings/2017/0098.pdf
            
             This is the amount of dtime we should spend on this technique during each
             inprocessing phase.
            
             The minimization technique is the same as the one used to minimize core in
             max-sat. We also minimize problem clauses and not just the learned clause
             that we keep forever like in the paper.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInprocessingMinimizationDtime">
            <summary>Gets whether the "inprocessing_minimization_dtime" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInprocessingMinimizationDtime">
            <summary>Clears the value of the "inprocessing_minimization_dtime" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.NumWorkersFieldNumber">
            <summary>Field number for the "num_workers" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.NumWorkers">
             <summary>
             Specify the number of parallel workers (i.e. threads) to use during search.
             This should usually be lower than your number of available cpus +
             hyperthread in your machine.
            
             A value of 0 means the solver will try to use all cores on the machine.
             A number of 1 means no parallelism.
            
             Note that 'num_workers' is the preferred name, but if it is set to zero,
             we will still read the deprecated 'num_search_workers'.
            
             As of 2020-04-10, if you're using SAT via MPSolver (to solve integer
             programs) this field is overridden with a value of 8, if the field is not
             set *explicitly*. Thus, always set this field explicitly or via
             MPSolver::SetNumThreads().
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasNumWorkers">
            <summary>Gets whether the "num_workers" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearNumWorkers">
            <summary>Clears the value of the "num_workers" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.NumSearchWorkersFieldNumber">
            <summary>Field number for the "num_search_workers" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasNumSearchWorkers">
            <summary>Gets whether the "num_search_workers" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearNumSearchWorkers">
            <summary>Clears the value of the "num_search_workers" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.NumFullSubsolversFieldNumber">
            <summary>Field number for the "num_full_subsolvers" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.NumFullSubsolvers">
            <summary>
            We distinguish subsolvers that consume a full thread, and the ones that are
            always interleaved. If left at zero, we will fix this with a default
            formula that depends on num_workers. But if you start modifying what runs,
            you might want to fix that to a given value depending on the num_workers
            you use.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasNumFullSubsolvers">
            <summary>Gets whether the "num_full_subsolvers" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearNumFullSubsolvers">
            <summary>Clears the value of the "num_full_subsolvers" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SubsolversFieldNumber">
            <summary>Field number for the "subsolvers" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.Subsolvers">
             <summary>
             In multi-thread, the solver can be mainly seen as a portfolio of solvers
             with different parameters. This field indicates the names of the parameters
             that are used in multithread. This only applies to "full" subsolvers.
            
             See cp_model_search.cc to see a list of the names and the default value (if
             left empty) that looks like:
             - default_lp           (linearization_level:1)
             - fixed                (only if fixed search specified or scheduling)
             - no_lp                (linearization_level:0)
             - max_lp               (linearization_level:2)
             - pseudo_costs         (only if objective, change search heuristic)
             - reduced_costs        (only if objective, change search heuristic)
             - quick_restart        (kind of probing)
             - quick_restart_no_lp  (kind of probing with linearization_level:0)
             - lb_tree_search       (to improve lower bound, MIP like tree search)
             - probing              (continuous probing and shaving)
            
             Also, note that some set of parameters will be ignored if they do not make
             sense. For instance if there is no objective, pseudo_cost or reduced_cost
             search will be ignored. Core based search will only work if the objective
             has many terms. If there is no fixed strategy fixed will be ignored. And so
             on.
            
             The order is important, as only the first num_full_subsolvers will be
             scheduled. You can see in the log which one are selected for a given run.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExtraSubsolversFieldNumber">
            <summary>Field number for the "extra_subsolvers" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExtraSubsolvers">
            <summary>
            A convenient way to add more workers types.
            These will be added at the beginning of the list.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.IgnoreSubsolversFieldNumber">
            <summary>Field number for the "ignore_subsolvers" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.IgnoreSubsolvers">
             <summary>
             Rather than fully specifying subsolvers, it is often convenient to just
             remove the ones that are not useful on a given problem or only keep
             specific ones for testing. Each string is interpreted as a "glob", so we
             support '*' and '?'.
            
             The way this work is that we will only accept a name that match a filter
             pattern (if non-empty) and do not match an ignore pattern. Note also that
             these fields work on LNS or LS names even if these are currently not
             specified via the subsolvers field.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FilterSubsolversFieldNumber">
            <summary>Field number for the "filter_subsolvers" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SubsolverParamsFieldNumber">
            <summary>Field number for the "subsolver_params" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SubsolverParams">
            <summary>
            It is possible to specify additional subsolver configuration. These can be
            referred by their params.name() in the fields above. Note that only the
            specified field will "overwrite" the ones of the base parameter. If a
            subsolver_params has the name of an existing subsolver configuration, the
            named parameters will be merged into the subsolver configuration.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InterleaveSearchFieldNumber">
            <summary>Field number for the "interleave_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.InterleaveSearch">
             <summary>
             Experimental. If this is true, then we interleave all our major search
             strategy and distribute the work amongst num_workers.
            
             The search is deterministic (independently of num_workers!), and we
             schedule and wait for interleave_batch_size task to be completed before
             synchronizing and scheduling the next batch of tasks.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInterleaveSearch">
            <summary>Gets whether the "interleave_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInterleaveSearch">
            <summary>Clears the value of the "interleave_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InterleaveBatchSizeFieldNumber">
            <summary>Field number for the "interleave_batch_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInterleaveBatchSize">
            <summary>Gets whether the "interleave_batch_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInterleaveBatchSize">
            <summary>Clears the value of the "interleave_batch_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ShareObjectiveBoundsFieldNumber">
            <summary>Field number for the "share_objective_bounds" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ShareObjectiveBounds">
            <summary>
            Allows objective sharing between workers.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasShareObjectiveBounds">
            <summary>Gets whether the "share_objective_bounds" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearShareObjectiveBounds">
            <summary>Clears the value of the "share_objective_bounds" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ShareLevelZeroBoundsFieldNumber">
            <summary>Field number for the "share_level_zero_bounds" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ShareLevelZeroBounds">
            <summary>
            Allows sharing of the bounds of modified variables at level 0.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasShareLevelZeroBounds">
            <summary>Gets whether the "share_level_zero_bounds" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearShareLevelZeroBounds">
            <summary>Clears the value of the "share_level_zero_bounds" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ShareBinaryClausesFieldNumber">
            <summary>Field number for the "share_binary_clauses" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ShareBinaryClauses">
            <summary>
            Allows sharing of new learned binary clause between workers.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasShareBinaryClauses">
            <summary>Gets whether the "share_binary_clauses" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearShareBinaryClauses">
            <summary>Clears the value of the "share_binary_clauses" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ShareGlueClausesFieldNumber">
            <summary>Field number for the "share_glue_clauses" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ShareGlueClauses">
            <summary>
            Allows sharing of short glue clauses between workers.
            Implicitly disabled if share_binary_clauses is false.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasShareGlueClauses">
            <summary>Gets whether the "share_glue_clauses" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearShareGlueClauses">
            <summary>Clears the value of the "share_glue_clauses" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.DebugPostsolveWithFullSolverFieldNumber">
            <summary>Field number for the "debug_postsolve_with_full_solver" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.DebugPostsolveWithFullSolver">
            <summary>
            We have two different postsolve code. The default one should be better and
            it allows for a more powerful presolve, but it can be useful to postsolve
            using the full solver instead.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasDebugPostsolveWithFullSolver">
            <summary>Gets whether the "debug_postsolve_with_full_solver" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearDebugPostsolveWithFullSolver">
            <summary>Clears the value of the "debug_postsolve_with_full_solver" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.DebugMaxNumPresolveOperationsFieldNumber">
            <summary>Field number for the "debug_max_num_presolve_operations" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.DebugMaxNumPresolveOperations">
            <summary>
            If positive, try to stop just after that many presolve rules have been
            applied. This is mainly useful for debugging presolve.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasDebugMaxNumPresolveOperations">
            <summary>Gets whether the "debug_max_num_presolve_operations" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearDebugMaxNumPresolveOperations">
            <summary>Clears the value of the "debug_max_num_presolve_operations" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.DebugCrashOnBadHintFieldNumber">
            <summary>Field number for the "debug_crash_on_bad_hint" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.DebugCrashOnBadHint">
            <summary>
            Crash if we do not manage to complete the hint into a full solution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasDebugCrashOnBadHint">
            <summary>Gets whether the "debug_crash_on_bad_hint" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearDebugCrashOnBadHint">
            <summary>Clears the value of the "debug_crash_on_bad_hint" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseOptimizationHintsFieldNumber">
            <summary>Field number for the "use_optimization_hints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseOptimizationHints">
            <summary>
            For an optimization problem, whether we follow some hints in order to find
            a better first solution. For a variable with hint, the solver will always
            try to follow the hint. It will revert to the variable_branching default
            otherwise.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseOptimizationHints">
            <summary>Gets whether the "use_optimization_hints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseOptimizationHints">
            <summary>Clears the value of the "use_optimization_hints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CoreMinimizationLevelFieldNumber">
            <summary>Field number for the "core_minimization_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CoreMinimizationLevel">
            <summary>
            If positive, we spend some effort on each core:
            - At level 1, we use a simple heuristic to try to minimize an UNSAT core.
            - At level 2, we use propagation to minimize the core but also identify
              literal in at most one relationship in this core.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCoreMinimizationLevel">
            <summary>Gets whether the "core_minimization_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCoreMinimizationLevel">
            <summary>Clears the value of the "core_minimization_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FindMultipleCoresFieldNumber">
            <summary>Field number for the "find_multiple_cores" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FindMultipleCores">
            <summary>
            Whether we try to find more independent cores for a given set of
            assumptions in the core based max-SAT algorithms.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFindMultipleCores">
            <summary>Gets whether the "find_multiple_cores" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFindMultipleCores">
            <summary>Clears the value of the "find_multiple_cores" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CoverOptimizationFieldNumber">
            <summary>Field number for the "cover_optimization" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CoverOptimization">
            <summary>
            If true, when the max-sat algo find a core, we compute the minimal number
            of literals in the core that needs to be true to have a feasible solution.
            This is also called core exhaustion in more recent max-SAT papers.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCoverOptimization">
            <summary>Gets whether the "cover_optimization" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCoverOptimization">
            <summary>Clears the value of the "cover_optimization" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxSatAssumptionOrderFieldNumber">
            <summary>Field number for the "max_sat_assumption_order" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxSatAssumptionOrder">
            <summary>Gets whether the "max_sat_assumption_order" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxSatAssumptionOrder">
            <summary>Clears the value of the "max_sat_assumption_order" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxSatReverseAssumptionOrderFieldNumber">
            <summary>Field number for the "max_sat_reverse_assumption_order" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxSatReverseAssumptionOrder">
            <summary>
            If true, adds the assumption in the reverse order of the one defined by
            max_sat_assumption_order.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxSatReverseAssumptionOrder">
            <summary>Gets whether the "max_sat_reverse_assumption_order" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxSatReverseAssumptionOrder">
            <summary>Clears the value of the "max_sat_reverse_assumption_order" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxSatStratificationFieldNumber">
            <summary>Field number for the "max_sat_stratification" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxSatStratification">
            <summary>Gets whether the "max_sat_stratification" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxSatStratification">
            <summary>Clears the value of the "max_sat_stratification" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PropagationLoopDetectionFactorFieldNumber">
            <summary>Field number for the "propagation_loop_detection_factor" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PropagationLoopDetectionFactor">
             <summary>
             Some search decisions might cause a really large number of propagations to
             happen when integer variables with large domains are only reduced by 1 at
             each step. If we propagate more than the number of variable times this
             parameters we try to take counter-measure. Setting this to 0.0 disable this
             feature.
            
             TODO(user): Setting this to something like 10 helps in most cases, but the
             code is currently buggy and can cause the solve to enter a bad state where
             no progress is made.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPropagationLoopDetectionFactor">
            <summary>Gets whether the "propagation_loop_detection_factor" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPropagationLoopDetectionFactor">
            <summary>Clears the value of the "propagation_loop_detection_factor" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UsePrecedencesInDisjunctiveConstraintFieldNumber">
            <summary>Field number for the "use_precedences_in_disjunctive_constraint" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UsePrecedencesInDisjunctiveConstraint">
             <summary>
             When this is true, then a disjunctive constraint will try to use the
             precedence relations between time intervals to propagate their bounds
             further. For instance if task A and B are both before C and task A and B
             are in disjunction, then we can deduce that task C must start after
             duration(A) + duration(B) instead of simply max(duration(A), duration(B)),
             provided that the start time for all task was currently zero.
            
             This always result in better propagation, but it is usually slow, so
             depending on the problem, turning this off may lead to a faster solution.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUsePrecedencesInDisjunctiveConstraint">
            <summary>Gets whether the "use_precedences_in_disjunctive_constraint" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUsePrecedencesInDisjunctiveConstraint">
            <summary>Clears the value of the "use_precedences_in_disjunctive_constraint" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxSizeToCreatePrecedenceLiteralsInDisjunctiveFieldNumber">
            <summary>Field number for the "max_size_to_create_precedence_literals_in_disjunctive" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxSizeToCreatePrecedenceLiteralsInDisjunctive">
            <summary>
            Create one literal for each disjunction of two pairs of tasks. This slows
            down the solve time, but improves the lower bound of the objective in the
            makespan case. This will be triggered if the number of intervals is less or
            equal than the parameter and if use_strong_propagation_in_disjunctive is
            true.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxSizeToCreatePrecedenceLiteralsInDisjunctive">
            <summary>Gets whether the "max_size_to_create_precedence_literals_in_disjunctive" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxSizeToCreatePrecedenceLiteralsInDisjunctive">
            <summary>Clears the value of the "max_size_to_create_precedence_literals_in_disjunctive" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseStrongPropagationInDisjunctiveFieldNumber">
            <summary>Field number for the "use_strong_propagation_in_disjunctive" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseStrongPropagationInDisjunctive">
            <summary>
            Enable stronger and more expensive propagation on no_overlap constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseStrongPropagationInDisjunctive">
            <summary>Gets whether the "use_strong_propagation_in_disjunctive" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseStrongPropagationInDisjunctive">
            <summary>Clears the value of the "use_strong_propagation_in_disjunctive" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseDynamicPrecedenceInDisjunctiveFieldNumber">
            <summary>Field number for the "use_dynamic_precedence_in_disjunctive" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseDynamicPrecedenceInDisjunctive">
             <summary>
             Whether we try to branch on decision "interval A before interval B" rather
             than on intervals bounds. This usually works better, but slow down a bit
             the time to find the first solution.
            
             These parameters are still EXPERIMENTAL, the result should be correct, but
             it some corner cases, they can cause some failing CHECK in the solver.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseDynamicPrecedenceInDisjunctive">
            <summary>Gets whether the "use_dynamic_precedence_in_disjunctive" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseDynamicPrecedenceInDisjunctive">
            <summary>Clears the value of the "use_dynamic_precedence_in_disjunctive" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseDynamicPrecedenceInCumulativeFieldNumber">
            <summary>Field number for the "use_dynamic_precedence_in_cumulative" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseDynamicPrecedenceInCumulative">
            <summary>Gets whether the "use_dynamic_precedence_in_cumulative" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseDynamicPrecedenceInCumulative">
            <summary>Clears the value of the "use_dynamic_precedence_in_cumulative" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseOverloadCheckerInCumulativeFieldNumber">
            <summary>Field number for the "use_overload_checker_in_cumulative" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseOverloadCheckerInCumulative">
             <summary>
             When this is true, the cumulative constraint is reinforced with overload
             checking, i.e., an additional level of reasoning based on energy. This
             additional level supplements the default level of reasoning as well as
             timetable edge finding.
            
             This always result in better propagation, but it is usually slow, so
             depending on the problem, turning this off may lead to a faster solution.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseOverloadCheckerInCumulative">
            <summary>Gets whether the "use_overload_checker_in_cumulative" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseOverloadCheckerInCumulative">
            <summary>Clears the value of the "use_overload_checker_in_cumulative" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseConservativeScaleOverloadCheckerFieldNumber">
            <summary>Field number for the "use_conservative_scale_overload_checker" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseConservativeScaleOverloadChecker">
             <summary>
             Enable a heuristic to solve cumulative constraints using a modified energy
             constraint. We modify the usual energy definition by applying a
             super-additive function (also called "conservative scale" or "dual-feasible
             function") to the demand and the durations of the tasks.
            
             This heuristic is fast but for most problems it does not help much to find
             a solution.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseConservativeScaleOverloadChecker">
            <summary>Gets whether the "use_conservative_scale_overload_checker" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseConservativeScaleOverloadChecker">
            <summary>Clears the value of the "use_conservative_scale_overload_checker" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseTimetableEdgeFindingInCumulativeFieldNumber">
            <summary>Field number for the "use_timetable_edge_finding_in_cumulative" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseTimetableEdgeFindingInCumulative">
             <summary>
             When this is true, the cumulative constraint is reinforced with timetable
             edge finding, i.e., an additional level of reasoning based on the
             conjunction of energy and mandatory parts. This additional level
             supplements the default level of reasoning as well as overload_checker.
            
             This always result in better propagation, but it is usually slow, so
             depending on the problem, turning this off may lead to a faster solution.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseTimetableEdgeFindingInCumulative">
            <summary>Gets whether the "use_timetable_edge_finding_in_cumulative" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseTimetableEdgeFindingInCumulative">
            <summary>Clears the value of the "use_timetable_edge_finding_in_cumulative" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxNumIntervalsForTimetableEdgeFindingFieldNumber">
            <summary>Field number for the "max_num_intervals_for_timetable_edge_finding" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxNumIntervalsForTimetableEdgeFinding">
            <summary>
            Max number of intervals for the timetable_edge_finding algorithm to
            propagate. A value of 0 disables the constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxNumIntervalsForTimetableEdgeFinding">
            <summary>Gets whether the "max_num_intervals_for_timetable_edge_finding" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxNumIntervalsForTimetableEdgeFinding">
            <summary>Clears the value of the "max_num_intervals_for_timetable_edge_finding" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseHardPrecedencesInCumulativeFieldNumber">
            <summary>Field number for the "use_hard_precedences_in_cumulative" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseHardPrecedencesInCumulative">
             <summary>
             If true, detect and create constraint for integer variable that are "after"
             a set of intervals in the same cumulative constraint.
            
             Experimental: by default we just use "direct" precedences. If
             exploit_all_precedences is true, we explore the full precedence graph. This
             assumes we have a DAG otherwise it fails.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseHardPrecedencesInCumulative">
            <summary>Gets whether the "use_hard_precedences_in_cumulative" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseHardPrecedencesInCumulative">
            <summary>Clears the value of the "use_hard_precedences_in_cumulative" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExploitAllPrecedencesFieldNumber">
            <summary>Field number for the "exploit_all_precedences" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExploitAllPrecedences">
            <summary>Gets whether the "exploit_all_precedences" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExploitAllPrecedences">
            <summary>Clears the value of the "exploit_all_precedences" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseDisjunctiveConstraintInCumulativeFieldNumber">
            <summary>Field number for the "use_disjunctive_constraint_in_cumulative" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseDisjunctiveConstraintInCumulative">
             <summary>
             When this is true, the cumulative constraint is reinforced with propagators
             from the disjunctive constraint to improve the inference on a set of tasks
             that are disjunctive at the root of the problem. This additional level
             supplements the default level of reasoning.
            
             Propagators of the cumulative constraint will not be used at all if all the
             tasks are disjunctive at root node.
            
             This always result in better propagation, but it is usually slow, so
             depending on the problem, turning this off may lead to a faster solution.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseDisjunctiveConstraintInCumulative">
            <summary>Gets whether the "use_disjunctive_constraint_in_cumulative" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseDisjunctiveConstraintInCumulative">
            <summary>Clears the value of the "use_disjunctive_constraint_in_cumulative" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseTimetablingInNoOverlap2DFieldNumber">
            <summary>Field number for the "use_timetabling_in_no_overlap_2d" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseTimetablingInNoOverlap2D">
            <summary>
            When this is true, the no_overlap_2d constraint is reinforced with
            propagators from the cumulative constraints. It consists of ignoring the
            position of rectangles in one position and projecting the no_overlap_2d on
            the other dimension to create a cumulative constraint. This is done on both
            axis. This additional level supplements the default level of reasoning.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseTimetablingInNoOverlap2D">
            <summary>Gets whether the "use_timetabling_in_no_overlap_2d" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseTimetablingInNoOverlap2D">
            <summary>Clears the value of the "use_timetabling_in_no_overlap_2d" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseEnergeticReasoningInNoOverlap2DFieldNumber">
            <summary>Field number for the "use_energetic_reasoning_in_no_overlap_2d" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseEnergeticReasoningInNoOverlap2D">
            <summary>
            When this is true, the no_overlap_2d constraint is reinforced with
            energetic reasoning. This additional level supplements the default level of
            reasoning.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseEnergeticReasoningInNoOverlap2D">
            <summary>Gets whether the "use_energetic_reasoning_in_no_overlap_2d" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseEnergeticReasoningInNoOverlap2D">
            <summary>Clears the value of the "use_energetic_reasoning_in_no_overlap_2d" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseAreaEnergeticReasoningInNoOverlap2DFieldNumber">
            <summary>Field number for the "use_area_energetic_reasoning_in_no_overlap_2d" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseAreaEnergeticReasoningInNoOverlap2D">
            <summary>
            When this is true, the no_overlap_2d constraint is reinforced with
            an energetic reasoning that uses an area-based energy. This can be combined
            with the two other overlap heuristics above.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseAreaEnergeticReasoningInNoOverlap2D">
            <summary>Gets whether the "use_area_energetic_reasoning_in_no_overlap_2d" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseAreaEnergeticReasoningInNoOverlap2D">
            <summary>Clears the value of the "use_area_energetic_reasoning_in_no_overlap_2d" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxPairsPairwiseReasoningInNoOverlap2DFieldNumber">
            <summary>Field number for the "max_pairs_pairwise_reasoning_in_no_overlap_2d" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxPairsPairwiseReasoningInNoOverlap2D">
            <summary>
            If the number of pairs to look is below this threshold, do an extra step of
            propagation in the no_overlap_2d constraint by looking at all pairs of
            intervals.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxPairsPairwiseReasoningInNoOverlap2D">
            <summary>Gets whether the "max_pairs_pairwise_reasoning_in_no_overlap_2d" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxPairsPairwiseReasoningInNoOverlap2D">
            <summary>Clears the value of the "max_pairs_pairwise_reasoning_in_no_overlap_2d" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseDualSchedulingHeuristicsFieldNumber">
            <summary>Field number for the "use_dual_scheduling_heuristics" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseDualSchedulingHeuristics">
            <summary>
            When set, it activates a few scheduling parameters to improve the lower
            bound of scheduling problems. This is only effective with multiple workers
            as it modifies the reduced_cost, lb_tree_search, and probing workers.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseDualSchedulingHeuristics">
            <summary>Gets whether the "use_dual_scheduling_heuristics" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseDualSchedulingHeuristics">
            <summary>Clears the value of the "use_dual_scheduling_heuristics" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SearchBranchingFieldNumber">
            <summary>Field number for the "search_branching" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSearchBranching">
            <summary>Gets whether the "search_branching" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSearchBranching">
            <summary>Clears the value of the "search_branching" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.HintConflictLimitFieldNumber">
            <summary>Field number for the "hint_conflict_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HintConflictLimit">
            <summary>
            Conflict limit used in the phase that exploit the solution hint.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasHintConflictLimit">
            <summary>Gets whether the "hint_conflict_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearHintConflictLimit">
            <summary>Clears the value of the "hint_conflict_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RepairHintFieldNumber">
            <summary>Field number for the "repair_hint" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RepairHint">
            <summary>
            If true, the solver tries to repair the solution given in the hint. This
            search terminates after the 'hint_conflict_limit' is reached and the solver
            switches to regular search. If false, then  we do a FIXED_SEARCH using the
            hint until the hint_conflict_limit is reached.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRepairHint">
            <summary>Gets whether the "repair_hint" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRepairHint">
            <summary>Clears the value of the "repair_hint" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FixVariablesToTheirHintedValueFieldNumber">
            <summary>Field number for the "fix_variables_to_their_hinted_value" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FixVariablesToTheirHintedValue">
            <summary>
            If true, variables appearing in the solution hints will be fixed to their
            hinted value.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFixVariablesToTheirHintedValue">
            <summary>Gets whether the "fix_variables_to_their_hinted_value" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFixVariablesToTheirHintedValue">
            <summary>Clears the value of the "fix_variables_to_their_hinted_value" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseProbingSearchFieldNumber">
            <summary>Field number for the "use_probing_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseProbingSearch">
            <summary>
            If true, search will continuously probe Boolean variables, and integer
            variable bounds. This parameter is set to true in parallel on the probing
            worker.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseProbingSearch">
            <summary>Gets whether the "use_probing_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseProbingSearch">
            <summary>Clears the value of the "use_probing_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseExtendedProbingFieldNumber">
            <summary>Field number for the "use_extended_probing" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseExtendedProbing">
            <summary>
            Use extended probing (probe bool_or, at_most_one, exactly_one).
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseExtendedProbing">
            <summary>Gets whether the "use_extended_probing" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseExtendedProbing">
            <summary>Clears the value of the "use_extended_probing" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ProbingNumCombinationsLimitFieldNumber">
            <summary>Field number for the "probing_num_combinations_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ProbingNumCombinationsLimit">
            <summary>
            How many combinations of pairs or triplets of variables we want to scan.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasProbingNumCombinationsLimit">
            <summary>Gets whether the "probing_num_combinations_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearProbingNumCombinationsLimit">
            <summary>Clears the value of the "probing_num_combinations_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseShavingInProbingSearchFieldNumber">
            <summary>Field number for the "use_shaving_in_probing_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseShavingInProbingSearch">
            <summary>
            Add a shaving phase (where the solver tries to prove that the lower or
            upper bound of a variable are infeasible) to the probing search.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseShavingInProbingSearch">
            <summary>Gets whether the "use_shaving_in_probing_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseShavingInProbingSearch">
            <summary>Clears the value of the "use_shaving_in_probing_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ShavingSearchDeterministicTimeFieldNumber">
            <summary>Field number for the "shaving_search_deterministic_time" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ShavingSearchDeterministicTime">
            <summary>
            Specifies the amount of deterministic time spent of each try at shaving a
            bound in the shaving search.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasShavingSearchDeterministicTime">
            <summary>Gets whether the "shaving_search_deterministic_time" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearShavingSearchDeterministicTime">
            <summary>Clears the value of the "shaving_search_deterministic_time" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ShavingSearchThresholdFieldNumber">
            <summary>Field number for the "shaving_search_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ShavingSearchThreshold">
            <summary>
            Specifies the threshold between two modes in the shaving procedure.
            If the range of the variable/objective is less than this threshold, then
            the shaving procedure will try to remove values one by one. Otherwise, it
            will try to remove one range at a time.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasShavingSearchThreshold">
            <summary>Gets whether the "shaving_search_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearShavingSearchThreshold">
            <summary>Clears the value of the "shaving_search_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseObjectiveLbSearchFieldNumber">
            <summary>Field number for the "use_objective_lb_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseObjectiveLbSearch">
            <summary>
            If true, search will search in ascending max objective value (when
            minimizing) starting from the lower bound of the objective.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseObjectiveLbSearch">
            <summary>Gets whether the "use_objective_lb_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseObjectiveLbSearch">
            <summary>Clears the value of the "use_objective_lb_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseObjectiveShavingSearchFieldNumber">
            <summary>Field number for the "use_objective_shaving_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseObjectiveShavingSearch">
            <summary>
            This search differs from the previous search as it will not use assumptions
            to bound the objective, and it will recreate a full model with the
            hardcoded objective value.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseObjectiveShavingSearch">
            <summary>Gets whether the "use_objective_shaving_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseObjectiveShavingSearch">
            <summary>Clears the value of the "use_objective_shaving_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseVariablesShavingSearchFieldNumber">
            <summary>Field number for the "use_variables_shaving_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseVariablesShavingSearch">
            <summary>
            This search takes all Boolean or integer variables, and maximize or
            minimize them in order to reduce their domain.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseVariablesShavingSearch">
            <summary>Gets whether the "use_variables_shaving_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseVariablesShavingSearch">
            <summary>Clears the value of the "use_variables_shaving_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PseudoCostReliabilityThresholdFieldNumber">
            <summary>Field number for the "pseudo_cost_reliability_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PseudoCostReliabilityThreshold">
            <summary>
            The solver ignores the pseudo costs of variables with number of recordings
            less than this threshold.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPseudoCostReliabilityThreshold">
            <summary>Gets whether the "pseudo_cost_reliability_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPseudoCostReliabilityThreshold">
            <summary>Clears the value of the "pseudo_cost_reliability_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.OptimizeWithCoreFieldNumber">
            <summary>Field number for the "optimize_with_core" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.OptimizeWithCore">
            <summary>
            The default optimization method is a simple "linear scan", each time trying
            to find a better solution than the previous one. If this is true, then we
            use a core-based approach (like in max-SAT) when we try to increase the
            lower bound instead.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasOptimizeWithCore">
            <summary>Gets whether the "optimize_with_core" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearOptimizeWithCore">
            <summary>Clears the value of the "optimize_with_core" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.OptimizeWithLbTreeSearchFieldNumber">
            <summary>Field number for the "optimize_with_lb_tree_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.OptimizeWithLbTreeSearch">
            <summary>
            Do a more conventional tree search (by opposition to SAT based one) where
            we keep all the explored node in a tree. This is meant to be used in a
            portfolio and focus on improving the objective lower bound. Keeping the
            whole tree allow us to report a better objective lower bound coming from
            the worst open node in the tree.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasOptimizeWithLbTreeSearch">
            <summary>Gets whether the "optimize_with_lb_tree_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearOptimizeWithLbTreeSearch">
            <summary>Clears the value of the "optimize_with_lb_tree_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SaveLpBasisInLbTreeSearchFieldNumber">
            <summary>Field number for the "save_lp_basis_in_lb_tree_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SaveLpBasisInLbTreeSearch">
             <summary>
             Experimental. Save the current LP basis at each node of the search tree so
             that when we jump around, we can load it and reduce the number of LP
             iterations needed.
            
             It currently works okay if we do not change the lp with cuts or
             simplification... More work is needed to make it robust in all cases.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSaveLpBasisInLbTreeSearch">
            <summary>Gets whether the "save_lp_basis_in_lb_tree_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSaveLpBasisInLbTreeSearch">
            <summary>Clears the value of the "save_lp_basis_in_lb_tree_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.BinarySearchNumConflictsFieldNumber">
            <summary>Field number for the "binary_search_num_conflicts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.BinarySearchNumConflicts">
            <summary>
            If non-negative, perform a binary search on the objective variable in order
            to find an [min, max] interval outside of which the solver proved unsat/sat
            under this amount of conflict. This can quickly reduce the objective domain
            on some problems.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasBinarySearchNumConflicts">
            <summary>Gets whether the "binary_search_num_conflicts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearBinarySearchNumConflicts">
            <summary>Clears the value of the "binary_search_num_conflicts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.OptimizeWithMaxHsFieldNumber">
            <summary>Field number for the "optimize_with_max_hs" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.OptimizeWithMaxHs">
            <summary>
            This has no effect if optimize_with_core is false. If true, use a different
            core-based algorithm similar to the max-HS algo for max-SAT. This is a
            hybrid MIP/CP approach and it uses a MIP solver in addition to the CP/SAT
            one. This is also related to the PhD work of tobyodavies@
            "Automatic Logic-Based Benders Decomposition with MiniZinc"
            http://aaai.org/ocs/index.php/AAAI/AAAI17/paper/view/14489
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasOptimizeWithMaxHs">
            <summary>Gets whether the "optimize_with_max_hs" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearOptimizeWithMaxHs">
            <summary>Clears the value of the "optimize_with_max_hs" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseFeasibilityJumpFieldNumber">
            <summary>Field number for the "use_feasibility_jump" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseFeasibilityJump">
            <summary>
            Parameters for an heuristic similar to the one described in the paper:
            "Feasibility Jump: an LP-free Lagrangian MIP heuristic", Bjrnar
            Luteberget, Giorgio Sartor, 2023, Mathematical Programming Computation.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseFeasibilityJump">
            <summary>Gets whether the "use_feasibility_jump" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseFeasibilityJump">
            <summary>Clears the value of the "use_feasibility_jump" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseLsOnlyFieldNumber">
            <summary>Field number for the "use_ls_only" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseLsOnly">
            <summary>
            Disable every other type of subsolver, setting this turns CP-SAT into a
            pure local-search solver.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseLsOnly">
            <summary>Gets whether the "use_ls_only" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseLsOnly">
            <summary>Clears the value of the "use_ls_only" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FeasibilityJumpDecayFieldNumber">
            <summary>Field number for the "feasibility_jump_decay" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FeasibilityJumpDecay">
            <summary>
            On each restart, we randomly choose if we use decay (with this parameter)
            or no decay.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFeasibilityJumpDecay">
            <summary>Gets whether the "feasibility_jump_decay" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFeasibilityJumpDecay">
            <summary>Clears the value of the "feasibility_jump_decay" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FeasibilityJumpLinearizationLevelFieldNumber">
            <summary>Field number for the "feasibility_jump_linearization_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FeasibilityJumpLinearizationLevel">
            <summary>
            How much do we linearize the problem in the local search code.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFeasibilityJumpLinearizationLevel">
            <summary>Gets whether the "feasibility_jump_linearization_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFeasibilityJumpLinearizationLevel">
            <summary>Clears the value of the "feasibility_jump_linearization_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FeasibilityJumpRestartFactorFieldNumber">
            <summary>Field number for the "feasibility_jump_restart_factor" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FeasibilityJumpRestartFactor">
            <summary>
            This is a factor that directly influence the work before each restart.
            Increasing it leads to longer restart.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFeasibilityJumpRestartFactor">
            <summary>Gets whether the "feasibility_jump_restart_factor" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFeasibilityJumpRestartFactor">
            <summary>Clears the value of the "feasibility_jump_restart_factor" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FeasibilityJumpBatchDtimeFieldNumber">
            <summary>Field number for the "feasibility_jump_batch_dtime" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FeasibilityJumpBatchDtime">
            <summary>
            How much dtime for each LS batch.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFeasibilityJumpBatchDtime">
            <summary>Gets whether the "feasibility_jump_batch_dtime" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFeasibilityJumpBatchDtime">
            <summary>Clears the value of the "feasibility_jump_batch_dtime" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FeasibilityJumpVarRandomizationProbabilityFieldNumber">
            <summary>Field number for the "feasibility_jump_var_randomization_probability" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FeasibilityJumpVarRandomizationProbability">
            <summary>
            Probability for a variable to have a non default value upon restarts or
            perturbations.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFeasibilityJumpVarRandomizationProbability">
            <summary>Gets whether the "feasibility_jump_var_randomization_probability" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFeasibilityJumpVarRandomizationProbability">
            <summary>Clears the value of the "feasibility_jump_var_randomization_probability" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FeasibilityJumpVarPerburbationRangeRatioFieldNumber">
            <summary>Field number for the "feasibility_jump_var_perburbation_range_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FeasibilityJumpVarPerburbationRangeRatio">
            <summary>
            Max distance between the default value and the pertubated value relative to
            the range of the domain of the variable.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFeasibilityJumpVarPerburbationRangeRatio">
            <summary>Gets whether the "feasibility_jump_var_perburbation_range_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFeasibilityJumpVarPerburbationRangeRatio">
            <summary>Clears the value of the "feasibility_jump_var_perburbation_range_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FeasibilityJumpEnableRestartsFieldNumber">
            <summary>Field number for the "feasibility_jump_enable_restarts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FeasibilityJumpEnableRestarts">
            <summary>
            When stagnating, feasibility jump will either restart from a default
            solution (with some possible randomization), or randomly pertubate the
            current solution. This parameter selects the first option.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFeasibilityJumpEnableRestarts">
            <summary>Gets whether the "feasibility_jump_enable_restarts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFeasibilityJumpEnableRestarts">
            <summary>Clears the value of the "feasibility_jump_enable_restarts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FeasibilityJumpMaxExpandedConstraintSizeFieldNumber">
            <summary>Field number for the "feasibility_jump_max_expanded_constraint_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FeasibilityJumpMaxExpandedConstraintSize">
            <summary>
            Maximum size of no_overlap or no_overlap_2d constraint for a quadratic
            expansion. This might look a lot, but by expanding such constraint, we get
            a linear time evaluation per single variable moves instead of a slow O(n
            log n) one.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFeasibilityJumpMaxExpandedConstraintSize">
            <summary>Gets whether the "feasibility_jump_max_expanded_constraint_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFeasibilityJumpMaxExpandedConstraintSize">
            <summary>Clears the value of the "feasibility_jump_max_expanded_constraint_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.NumViolationLsFieldNumber">
            <summary>Field number for the "num_violation_ls" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.NumViolationLs">
            <summary>
            This will create incomplete subsolvers (that are not LNS subsolvers)
            that use the feasibility jump code to find improving solution, treating
            the objective improvement as a hard constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasNumViolationLs">
            <summary>Gets whether the "num_violation_ls" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearNumViolationLs">
            <summary>Clears the value of the "num_violation_ls" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ViolationLsPerturbationPeriodFieldNumber">
            <summary>Field number for the "violation_ls_perturbation_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ViolationLsPerturbationPeriod">
            <summary>
            How long violation_ls should wait before perturbating a solution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasViolationLsPerturbationPeriod">
            <summary>Gets whether the "violation_ls_perturbation_period" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearViolationLsPerturbationPeriod">
            <summary>Clears the value of the "violation_ls_perturbation_period" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ViolationLsCompoundMoveProbabilityFieldNumber">
            <summary>Field number for the "violation_ls_compound_move_probability" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ViolationLsCompoundMoveProbability">
            <summary>
            Probability of using compound move search each restart.
            TODO(user): Add reference to paper when published.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasViolationLsCompoundMoveProbability">
            <summary>Gets whether the "violation_ls_compound_move_probability" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearViolationLsCompoundMoveProbability">
            <summary>Clears the value of the "violation_ls_compound_move_probability" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SharedTreeNumWorkersFieldNumber">
            <summary>Field number for the "shared_tree_num_workers" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SharedTreeNumWorkers">
            <summary>
            Enables experimental workstealing-like shared tree search.
            If non-zero, start this many complete worker threads to explore a shared
            search tree. These workers communicate objective bounds and simple decision
            nogoods relating to the shared prefix of the tree, and will avoid exploring
            the same subtrees as one another.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSharedTreeNumWorkers">
            <summary>Gets whether the "shared_tree_num_workers" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSharedTreeNumWorkers">
            <summary>Clears the value of the "shared_tree_num_workers" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseSharedTreeSearchFieldNumber">
            <summary>Field number for the "use_shared_tree_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseSharedTreeSearch">
            <summary>
            Set on shared subtree workers. Users should not set this directly.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseSharedTreeSearch">
            <summary>Gets whether the "use_shared_tree_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseSharedTreeSearch">
            <summary>Clears the value of the "use_shared_tree_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SharedTreeWorkerObjectiveSplitProbabilityFieldNumber">
            <summary>Field number for the "shared_tree_worker_objective_split_probability" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SharedTreeWorkerObjectiveSplitProbability">
            <summary>
            After their assigned prefix, shared tree workers will branch on the
            objective with this probability. Higher numbers cause the shared tree
            search to focus on improving the lower bound over finding primal solutions.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSharedTreeWorkerObjectiveSplitProbability">
            <summary>Gets whether the "shared_tree_worker_objective_split_probability" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSharedTreeWorkerObjectiveSplitProbability">
            <summary>Clears the value of the "shared_tree_worker_objective_split_probability" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SharedTreeWorkerMinRestartsPerSubtreeFieldNumber">
            <summary>Field number for the "shared_tree_worker_min_restarts_per_subtree" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SharedTreeWorkerMinRestartsPerSubtree">
            <summary>
            Minimum number of restarts before a worker will replace a subtree
            that looks "bad" based on the average LBD of learned clauses.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSharedTreeWorkerMinRestartsPerSubtree">
            <summary>Gets whether the "shared_tree_worker_min_restarts_per_subtree" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSharedTreeWorkerMinRestartsPerSubtree">
            <summary>Clears the value of the "shared_tree_worker_min_restarts_per_subtree" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SharedTreeWorkerEnableTrailSharingFieldNumber">
            <summary>Field number for the "shared_tree_worker_enable_trail_sharing" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SharedTreeWorkerEnableTrailSharing">
            <summary>
            If true, workers share more of the information from their local trail.
            Specifically, literals implied by the shared tree decisions and
            the longest conflict-free assignment from the last restart (to enable
            cross-worker phase-saving).
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSharedTreeWorkerEnableTrailSharing">
            <summary>Gets whether the "shared_tree_worker_enable_trail_sharing" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSharedTreeWorkerEnableTrailSharing">
            <summary>Clears the value of the "shared_tree_worker_enable_trail_sharing" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SharedTreeOpenLeavesPerWorkerFieldNumber">
            <summary>Field number for the "shared_tree_open_leaves_per_worker" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SharedTreeOpenLeavesPerWorker">
            <summary>
            How many open leaf nodes should the shared tree maintain per worker.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSharedTreeOpenLeavesPerWorker">
            <summary>Gets whether the "shared_tree_open_leaves_per_worker" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSharedTreeOpenLeavesPerWorker">
            <summary>Clears the value of the "shared_tree_open_leaves_per_worker" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SharedTreeMaxNodesPerWorkerFieldNumber">
            <summary>Field number for the "shared_tree_max_nodes_per_worker" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SharedTreeMaxNodesPerWorker">
            <summary>
            In order to limit total shared memory and communication overhead, limit the
            total number of nodes that may be generated in the shared tree. If the
            shared tree runs out of unassigned leaves, workers act as portfolio
            workers. Note: this limit includes interior nodes, not just leaves.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSharedTreeMaxNodesPerWorker">
            <summary>Gets whether the "shared_tree_max_nodes_per_worker" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSharedTreeMaxNodesPerWorker">
            <summary>Clears the value of the "shared_tree_max_nodes_per_worker" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SharedTreeSplitStrategyFieldNumber">
            <summary>Field number for the "shared_tree_split_strategy" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSharedTreeSplitStrategy">
            <summary>Gets whether the "shared_tree_split_strategy" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSharedTreeSplitStrategy">
            <summary>Clears the value of the "shared_tree_split_strategy" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.EnumerateAllSolutionsFieldNumber">
            <summary>Field number for the "enumerate_all_solutions" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.EnumerateAllSolutions">
             <summary>
             Whether we enumerate all solutions of a problem without objective. Note
             that setting this to true automatically disable some presolve reduction
             that can remove feasible solution. That is it has the same effect as
             setting keep_all_feasible_solutions_in_presolve.
            
             TODO(user): Do not do that and let the user choose what behavior is best by
             setting keep_all_feasible_solutions_in_presolve ?
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasEnumerateAllSolutions">
            <summary>Gets whether the "enumerate_all_solutions" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearEnumerateAllSolutions">
            <summary>Clears the value of the "enumerate_all_solutions" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.KeepAllFeasibleSolutionsInPresolveFieldNumber">
            <summary>Field number for the "keep_all_feasible_solutions_in_presolve" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.KeepAllFeasibleSolutionsInPresolve">
             <summary>
             If true, we disable the presolve reductions that remove feasible solutions
             from the search space. Such solution are usually dominated by a "better"
             solution that is kept, but depending on the situation, we might want to
             keep all solutions.
            
             A trivial example is when a variable is unused. If this is true, then the
             presolve will not fix it to an arbitrary value and it will stay in the
             search space.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasKeepAllFeasibleSolutionsInPresolve">
            <summary>Gets whether the "keep_all_feasible_solutions_in_presolve" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearKeepAllFeasibleSolutionsInPresolve">
            <summary>Clears the value of the "keep_all_feasible_solutions_in_presolve" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FillTightenedDomainsInResponseFieldNumber">
            <summary>Field number for the "fill_tightened_domains_in_response" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FillTightenedDomainsInResponse">
            <summary>
            If true, add information about the derived variable domains to the
            CpSolverResponse. It is an option because it makes the response slighly
            bigger and there is a bit more work involved during the postsolve to
            construct it, but it should still have a low overhead. See the
            tightened_variables field in CpSolverResponse for more details.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFillTightenedDomainsInResponse">
            <summary>Gets whether the "fill_tightened_domains_in_response" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFillTightenedDomainsInResponse">
            <summary>Clears the value of the "fill_tightened_domains_in_response" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FillAdditionalSolutionsInResponseFieldNumber">
            <summary>Field number for the "fill_additional_solutions_in_response" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FillAdditionalSolutionsInResponse">
             <summary>
             If true, the final response addition_solutions field will be filled with
             all solutions from our solutions pool.
            
             Note that if both this field and enumerate_all_solutions is true, we will
             copy to the pool all of the solution found. So if solution_pool_size is big
             enough, you can get all solutions this way instead of using the solution
             callback.
            
             Note that this only affect the "final" solution, not the one passed to the
             solution callbacks.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFillAdditionalSolutionsInResponse">
            <summary>Gets whether the "fill_additional_solutions_in_response" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFillAdditionalSolutionsInResponse">
            <summary>Clears the value of the "fill_additional_solutions_in_response" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InstantiateAllVariablesFieldNumber">
            <summary>Field number for the "instantiate_all_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.InstantiateAllVariables">
            <summary>
            If true, the solver will add a default integer branching strategy to the
            already defined search strategy. If not, some variable might still not be
            fixed at the end of the search. For now we assume these variable can just
            be set to their lower bound.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInstantiateAllVariables">
            <summary>Gets whether the "instantiate_all_variables" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInstantiateAllVariables">
            <summary>Clears the value of the "instantiate_all_variables" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AutoDetectGreaterThanAtLeastOneOfFieldNumber">
            <summary>Field number for the "auto_detect_greater_than_at_least_one_of" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AutoDetectGreaterThanAtLeastOneOf">
            <summary>
            If true, then the precedences propagator try to detect for each variable if
            it has a set of "optional incoming arc" for which at least one of them is
            present. This is usually useful to have but can be slow on model with a lot
            of precedence.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAutoDetectGreaterThanAtLeastOneOf">
            <summary>Gets whether the "auto_detect_greater_than_at_least_one_of" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAutoDetectGreaterThanAtLeastOneOf">
            <summary>Clears the value of the "auto_detect_greater_than_at_least_one_of" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.StopAfterFirstSolutionFieldNumber">
            <summary>Field number for the "stop_after_first_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.StopAfterFirstSolution">
            <summary>
            For an optimization problem, stop the solver as soon as we have a solution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasStopAfterFirstSolution">
            <summary>Gets whether the "stop_after_first_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearStopAfterFirstSolution">
            <summary>Clears the value of the "stop_after_first_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.StopAfterPresolveFieldNumber">
            <summary>Field number for the "stop_after_presolve" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.StopAfterPresolve">
            <summary>
            Mainly used when improving the presolver. When true, stops the solver after
            the presolve is complete (or after loading and root level propagation).
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasStopAfterPresolve">
            <summary>Gets whether the "stop_after_presolve" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearStopAfterPresolve">
            <summary>Clears the value of the "stop_after_presolve" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.StopAfterRootPropagationFieldNumber">
            <summary>Field number for the "stop_after_root_propagation" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasStopAfterRootPropagation">
            <summary>Gets whether the "stop_after_root_propagation" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearStopAfterRootPropagation">
            <summary>Clears the value of the "stop_after_root_propagation" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseLnsFieldNumber">
            <summary>Field number for the "use_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseLns">
            <summary>
            Testing parameters used to disable all lns workers.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseLns">
            <summary>Gets whether the "use_lns" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseLns">
            <summary>Clears the value of the "use_lns" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseLnsOnlyFieldNumber">
            <summary>Field number for the "use_lns_only" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseLnsOnly">
            <summary>
            Experimental parameters to disable everything but lns.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseLnsOnly">
            <summary>Gets whether the "use_lns_only" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseLnsOnly">
            <summary>Clears the value of the "use_lns_only" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SolutionPoolSizeFieldNumber">
            <summary>Field number for the "solution_pool_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SolutionPoolSize">
            <summary>
            Size of the top-n different solutions kept by the solver.
            This parameter must be > 0.
            Currently this only impact the "base" solution chosen for a LNS fragment.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSolutionPoolSize">
            <summary>Gets whether the "solution_pool_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSolutionPoolSize">
            <summary>Clears the value of the "solution_pool_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseRinsLnsFieldNumber">
            <summary>Field number for the "use_rins_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseRinsLns">
            <summary>
            Turns on relaxation induced neighborhood generator.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseRinsLns">
            <summary>Gets whether the "use_rins_lns" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseRinsLns">
            <summary>Clears the value of the "use_rins_lns" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseFeasibilityPumpFieldNumber">
            <summary>Field number for the "use_feasibility_pump" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseFeasibilityPump">
            <summary>
            Adds a feasibility pump subsolver along with lns subsolvers.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseFeasibilityPump">
            <summary>Gets whether the "use_feasibility_pump" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseFeasibilityPump">
            <summary>Clears the value of the "use_feasibility_pump" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseLbRelaxLnsFieldNumber">
            <summary>Field number for the "use_lb_relax_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseLbRelaxLns">
            <summary>
            Turns on neighborhood generator based on local branching LP. Based on Huang
            et al., "Local Branching Relaxation Heuristics for Integer Linear
            Programs", 2023.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseLbRelaxLns">
            <summary>Gets whether the "use_lb_relax_lns" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseLbRelaxLns">
            <summary>Clears the value of the "use_lb_relax_lns" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FpRoundingFieldNumber">
            <summary>Field number for the "fp_rounding" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFpRounding">
            <summary>Gets whether the "fp_rounding" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFpRounding">
            <summary>Clears the value of the "fp_rounding" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.DiversifyLnsParamsFieldNumber">
            <summary>Field number for the "diversify_lns_params" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.DiversifyLnsParams">
            <summary>
            If true, registers more lns subsolvers with different parameters.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasDiversifyLnsParams">
            <summary>Gets whether the "diversify_lns_params" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearDiversifyLnsParams">
            <summary>Clears the value of the "diversify_lns_params" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RandomizeSearchFieldNumber">
            <summary>Field number for the "randomize_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RandomizeSearch">
            <summary>
            Randomize fixed search.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRandomizeSearch">
            <summary>Gets whether the "randomize_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRandomizeSearch">
            <summary>Clears the value of the "randomize_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SearchRandomVariablePoolSizeFieldNumber">
            <summary>Field number for the "search_random_variable_pool_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SearchRandomVariablePoolSize">
            <summary>
            Search randomization will collect the top
            'search_random_variable_pool_size' valued variables, and pick one randomly.
            The value of the variable is specific to each strategy.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSearchRandomVariablePoolSize">
            <summary>Gets whether the "search_random_variable_pool_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSearchRandomVariablePoolSize">
            <summary>Clears the value of the "search_random_variable_pool_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PushAllTasksTowardStartFieldNumber">
            <summary>Field number for the "push_all_tasks_toward_start" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PushAllTasksTowardStart">
            <summary>
            Experimental code: specify if the objective pushes all tasks toward the
            start of the schedule.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPushAllTasksTowardStart">
            <summary>Gets whether the "push_all_tasks_toward_start" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPushAllTasksTowardStart">
            <summary>Clears the value of the "push_all_tasks_toward_start" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseOptionalVariablesFieldNumber">
            <summary>Field number for the "use_optional_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseOptionalVariables">
             <summary>
             If true, we automatically detect variables whose constraint are always
             enforced by the same literal and we mark them as optional. This allows
             to propagate them as if they were present in some situation.
            
             TODO(user): This is experimental and seems to lead to wrong optimal in
             some situation. It should however gives correct solutions. Fix.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseOptionalVariables">
            <summary>Gets whether the "use_optional_variables" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseOptionalVariables">
            <summary>Clears the value of the "use_optional_variables" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseExactLpReasonFieldNumber">
            <summary>Field number for the "use_exact_lp_reason" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseExactLpReason">
            <summary>
            The solver usually exploit the LP relaxation of a model. If this option is
            true, then whatever is infered by the LP will be used like an heuristic to
            compute EXACT propagation on the IP. So with this option, there is no
            numerical imprecision issues.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseExactLpReason">
            <summary>Gets whether the "use_exact_lp_reason" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseExactLpReason">
            <summary>Clears the value of the "use_exact_lp_reason" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseCombinedNoOverlapFieldNumber">
            <summary>Field number for the "use_combined_no_overlap" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseCombinedNoOverlap">
            <summary>
            This can be beneficial if there is a lot of no-overlap constraints but a
            relatively low number of different intervals in the problem. Like 1000
            intervals, but 1M intervals in the no-overlap constraints covering them.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseCombinedNoOverlap">
            <summary>Gets whether the "use_combined_no_overlap" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseCombinedNoOverlap">
            <summary>Clears the value of the "use_combined_no_overlap" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AtMostOneMaxExpansionSizeFieldNumber">
            <summary>Field number for the "at_most_one_max_expansion_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AtMostOneMaxExpansionSize">
            <summary>
            All at_most_one constraints with a size &lt;= param will be replaced by a
            quadratic number of binary implications.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAtMostOneMaxExpansionSize">
            <summary>Gets whether the "at_most_one_max_expansion_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAtMostOneMaxExpansionSize">
            <summary>Clears the value of the "at_most_one_max_expansion_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CatchSigintSignalFieldNumber">
            <summary>Field number for the "catch_sigint_signal" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CatchSigintSignal">
            <summary>
            Indicates if the CP-SAT layer should catch Control-C (SIGINT) signals
            when calling solve. If set, catching the SIGINT signal will terminate the
            search gracefully, as if a time limit was reached.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCatchSigintSignal">
            <summary>Gets whether the "catch_sigint_signal" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCatchSigintSignal">
            <summary>Clears the value of the "catch_sigint_signal" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseImpliedBoundsFieldNumber">
            <summary>Field number for the "use_implied_bounds" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseImpliedBounds">
            <summary>
            Stores and exploits "implied-bounds" in the solver. That is, relations of
            the form literal => (var >= bound). This is currently used to derive
            stronger cuts.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseImpliedBounds">
            <summary>Gets whether the "use_implied_bounds" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseImpliedBounds">
            <summary>Clears the value of the "use_implied_bounds" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PolishLpSolutionFieldNumber">
            <summary>Field number for the "polish_lp_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PolishLpSolution">
            <summary>
            Whether we try to do a few degenerate iteration at the end of an LP solve
            to minimize the fractionality of the integer variable in the basis. This
            helps on some problems, but not so much on others. It also cost of bit of
            time to do such polish step.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPolishLpSolution">
            <summary>Gets whether the "polish_lp_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPolishLpSolution">
            <summary>Clears the value of the "polish_lp_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LpPrimalToleranceFieldNumber">
            <summary>Field number for the "lp_primal_tolerance" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LpPrimalTolerance">
            <summary>
            The internal LP tolerances used by CP-SAT. These applies to the internal
            and scaled problem. If the domains of your variables are large it might be
            good to use lower tolerances. If your problem is binary with low
            coefficients, it might be good to use higher ones to speed-up the lp
            solves.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLpPrimalTolerance">
            <summary>Gets whether the "lp_primal_tolerance" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLpPrimalTolerance">
            <summary>Clears the value of the "lp_primal_tolerance" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LpDualToleranceFieldNumber">
            <summary>Field number for the "lp_dual_tolerance" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLpDualTolerance">
            <summary>Gets whether the "lp_dual_tolerance" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLpDualTolerance">
            <summary>Clears the value of the "lp_dual_tolerance" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ConvertIntervalsFieldNumber">
            <summary>Field number for the "convert_intervals" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ConvertIntervals">
            <summary>
            Temporary flag util the feature is more mature. This convert intervals to
            the newer proto format that support affine start/var/end instead of just
            variables.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasConvertIntervals">
            <summary>Gets whether the "convert_intervals" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearConvertIntervals">
            <summary>Clears the value of the "convert_intervals" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SymmetryLevelFieldNumber">
            <summary>Field number for the "symmetry_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SymmetryLevel">
            <summary>
            Whether we try to automatically detect the symmetries in a model and
            exploit them. Currently, at level 1 we detect them in presolve and try
            to fix Booleans. At level 2, we also do some form of dynamic symmetry
            breaking during search. At level 3, we also detect symmetries for very
            large models, which can be slow. At level 4, we try to break as much
            symmetry as possible in presolve.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSymmetryLevel">
            <summary>Gets whether the "symmetry_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSymmetryLevel">
            <summary>Clears the value of the "symmetry_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.NewLinearPropagationFieldNumber">
            <summary>Field number for the "new_linear_propagation" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.NewLinearPropagation">
            <summary>
            The new linear propagation code treat all constraints at once and use
            an adaptation of Bellman-Ford-Tarjan to propagate constraint in a smarter
            order and potentially detect propagation cycle earlier.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasNewLinearPropagation">
            <summary>Gets whether the "new_linear_propagation" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearNewLinearPropagation">
            <summary>Clears the value of the "new_linear_propagation" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LinearSplitSizeFieldNumber">
            <summary>Field number for the "linear_split_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LinearSplitSize">
            <summary>
            Linear constraints that are not pseudo-Boolean and that are longer than
            this size will be split into sqrt(size) intermediate sums in order to have
            faster propation in the CP engine.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLinearSplitSize">
            <summary>Gets whether the "linear_split_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLinearSplitSize">
            <summary>Clears the value of the "linear_split_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LinearizationLevelFieldNumber">
            <summary>Field number for the "linearization_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LinearizationLevel">
            <summary>
            A non-negative level indicating the type of constraints we consider in the
            LP relaxation. At level zero, no LP relaxation is used. At level 1, only
            the linear constraint and full encoding are added. At level 2, we also add
            all the Boolean constraints.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLinearizationLevel">
            <summary>Gets whether the "linearization_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLinearizationLevel">
            <summary>Clears the value of the "linearization_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.BooleanEncodingLevelFieldNumber">
            <summary>Field number for the "boolean_encoding_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.BooleanEncodingLevel">
            <summary>
            A non-negative level indicating how much we should try to fully encode
            Integer variables as Boolean.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasBooleanEncodingLevel">
            <summary>Gets whether the "boolean_encoding_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearBooleanEncodingLevel">
            <summary>Clears the value of the "boolean_encoding_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxDomainSizeWhenEncodingEqNeqConstraintsFieldNumber">
            <summary>Field number for the "max_domain_size_when_encoding_eq_neq_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxDomainSizeWhenEncodingEqNeqConstraints">
            <summary>
            When loading a*x + b*y ==/!= c when x and y are both fully encoded.
            The solver may decide to replace the linear equation by a set of clauses.
            This is triggered if the sizes of the domains of x and y are below the
            threshold.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxDomainSizeWhenEncodingEqNeqConstraints">
            <summary>Gets whether the "max_domain_size_when_encoding_eq_neq_constraints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxDomainSizeWhenEncodingEqNeqConstraints">
            <summary>Clears the value of the "max_domain_size_when_encoding_eq_neq_constraints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxNumCutsFieldNumber">
            <summary>Field number for the "max_num_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxNumCuts">
             <summary>
             The limit on the number of cuts in our cut pool. When this is reached we do
             not generate cuts anymore.
            
             TODO(user): We should probably remove this parameters, and just always
             generate cuts but only keep the best n or something.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxNumCuts">
            <summary>Gets whether the "max_num_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxNumCuts">
            <summary>Clears the value of the "max_num_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CutLevelFieldNumber">
            <summary>Field number for the "cut_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CutLevel">
            <summary>
            Control the global cut effort. Zero will turn off all cut. For now we just
            have one level. Note also that most cuts are only used at linearization
            level >= 2.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCutLevel">
            <summary>Gets whether the "cut_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCutLevel">
            <summary>Clears the value of the "cut_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.OnlyAddCutsAtLevelZeroFieldNumber">
            <summary>Field number for the "only_add_cuts_at_level_zero" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.OnlyAddCutsAtLevelZero">
            <summary>
            For the cut that can be generated at any level, this control if we only
            try to generate them at the root node.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasOnlyAddCutsAtLevelZero">
            <summary>Gets whether the "only_add_cuts_at_level_zero" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearOnlyAddCutsAtLevelZero">
            <summary>Clears the value of the "only_add_cuts_at_level_zero" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddObjectiveCutFieldNumber">
            <summary>Field number for the "add_objective_cut" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddObjectiveCut">
            <summary>
            When the LP objective is fractional, do we add the cut that forces the
            linear objective expression to be greater or equal to this fractional value
            rounded up? We can always do that since our objective is integer, and
            combined with MIR heuristic to reduce the coefficient of such cut, it can
            help.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddObjectiveCut">
            <summary>Gets whether the "add_objective_cut" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddObjectiveCut">
            <summary>Clears the value of the "add_objective_cut" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddCgCutsFieldNumber">
            <summary>Field number for the "add_cg_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddCgCuts">
            <summary>
            Whether we generate and add Chvatal-Gomory cuts to the LP at root node.
            Note that for now, this is not heavily tuned.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddCgCuts">
            <summary>Gets whether the "add_cg_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddCgCuts">
            <summary>Clears the value of the "add_cg_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddMirCutsFieldNumber">
            <summary>Field number for the "add_mir_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddMirCuts">
            <summary>
            Whether we generate MIR cuts at root node.
            Note that for now, this is not heavily tuned.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddMirCuts">
            <summary>Gets whether the "add_mir_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddMirCuts">
            <summary>Clears the value of the "add_mir_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddZeroHalfCutsFieldNumber">
            <summary>Field number for the "add_zero_half_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddZeroHalfCuts">
            <summary>
            Whether we generate Zero-Half cuts at root node.
            Note that for now, this is not heavily tuned.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddZeroHalfCuts">
            <summary>Gets whether the "add_zero_half_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddZeroHalfCuts">
            <summary>Clears the value of the "add_zero_half_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddCliqueCutsFieldNumber">
            <summary>Field number for the "add_clique_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddCliqueCuts">
            <summary>
            Whether we generate clique cuts from the binary implication graph. Note
            that as the search goes on, this graph will contains new binary clauses
            learned by the SAT engine.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddCliqueCuts">
            <summary>Gets whether the "add_clique_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddCliqueCuts">
            <summary>Clears the value of the "add_clique_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddRltCutsFieldNumber">
            <summary>Field number for the "add_rlt_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddRltCuts">
            <summary>
            Whether we generate RLT cuts. This is still experimental but can help on
            binary problem with a lot of clauses of size 3.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddRltCuts">
            <summary>Gets whether the "add_rlt_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddRltCuts">
            <summary>Clears the value of the "add_rlt_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxAllDiffCutSizeFieldNumber">
            <summary>Field number for the "max_all_diff_cut_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxAllDiffCutSize">
            <summary>
            Cut generator for all diffs can add too many cuts for large all_diff
            constraints. This parameter restricts the large all_diff constraints to
            have a cut generator.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxAllDiffCutSize">
            <summary>Gets whether the "max_all_diff_cut_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxAllDiffCutSize">
            <summary>Clears the value of the "max_all_diff_cut_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddLinMaxCutsFieldNumber">
            <summary>Field number for the "add_lin_max_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddLinMaxCuts">
            <summary>
            For the lin max constraints, generates the cuts described in "Strong
            mixed-integer programming formulations for trained neural networks" by Ross
            Anderson et. (https://arxiv.org/pdf/1811.01988.pdf)
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddLinMaxCuts">
            <summary>Gets whether the "add_lin_max_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddLinMaxCuts">
            <summary>Clears the value of the "add_lin_max_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxIntegerRoundingScalingFieldNumber">
            <summary>Field number for the "max_integer_rounding_scaling" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxIntegerRoundingScaling">
             <summary>
             In the integer rounding procedure used for MIR and Gomory cut, the maximum
             "scaling" we use (must be positive). The lower this is, the lower the
             integer coefficients of the cut will be. Note that cut generated by lower
             values are not necessarily worse than cut generated by larger value. There
             is no strict dominance relationship.
            
             Setting this to 2 result in the "strong fractional rouding" of Letchford
             and Lodi.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxIntegerRoundingScaling">
            <summary>Gets whether the "max_integer_rounding_scaling" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxIntegerRoundingScaling">
            <summary>Clears the value of the "max_integer_rounding_scaling" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddLpConstraintsLazilyFieldNumber">
            <summary>Field number for the "add_lp_constraints_lazily" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddLpConstraintsLazily">
            <summary>
            If true, we start by an empty LP, and only add constraints not satisfied
            by the current LP solution batch by batch. A constraint that is only added
            like this is known as a "lazy" constraint in the literature, except that we
            currently consider all constraints as lazy here.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddLpConstraintsLazily">
            <summary>Gets whether the "add_lp_constraints_lazily" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddLpConstraintsLazily">
            <summary>Clears the value of the "add_lp_constraints_lazily" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RootLpIterationsFieldNumber">
            <summary>Field number for the "root_lp_iterations" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RootLpIterations">
            <summary>
            Even at the root node, we do not want to spend too much time on the LP if
            it is "difficult". So we solve it in "chunks" of that many iterations. The
            solve will be continued down in the tree or the next time we go back to the
            root node.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRootLpIterations">
            <summary>Gets whether the "root_lp_iterations" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRootLpIterations">
            <summary>Clears the value of the "root_lp_iterations" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MinOrthogonalityForLpConstraintsFieldNumber">
            <summary>Field number for the "min_orthogonality_for_lp_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MinOrthogonalityForLpConstraints">
            <summary>
            While adding constraints, skip the constraints which have orthogonality
            less than 'min_orthogonality_for_lp_constraints' with already added
            constraints during current call. Orthogonality is defined as 1 -
            cosine(vector angle between constraints). A value of zero disable this
            feature.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMinOrthogonalityForLpConstraints">
            <summary>Gets whether the "min_orthogonality_for_lp_constraints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMinOrthogonalityForLpConstraints">
            <summary>Clears the value of the "min_orthogonality_for_lp_constraints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxCutRoundsAtLevelZeroFieldNumber">
            <summary>Field number for the "max_cut_rounds_at_level_zero" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxCutRoundsAtLevelZero">
            <summary>
            Max number of time we perform cut generation and resolve the LP at level 0.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxCutRoundsAtLevelZero">
            <summary>Gets whether the "max_cut_rounds_at_level_zero" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxCutRoundsAtLevelZero">
            <summary>Clears the value of the "max_cut_rounds_at_level_zero" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxConsecutiveInactiveCountFieldNumber">
            <summary>Field number for the "max_consecutive_inactive_count" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxConsecutiveInactiveCount">
            <summary>
            If a constraint/cut in LP is not active for that many consecutive OPTIMAL
            solves, remove it from the LP. Note that it might be added again later if
            it become violated by the current LP solution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxConsecutiveInactiveCount">
            <summary>Gets whether the "max_consecutive_inactive_count" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxConsecutiveInactiveCount">
            <summary>Clears the value of the "max_consecutive_inactive_count" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CutMaxActiveCountValueFieldNumber">
            <summary>Field number for the "cut_max_active_count_value" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CutMaxActiveCountValue">
            <summary>
            These parameters are similar to sat clause management activity parameters.
            They are effective only if the number of generated cuts exceed the storage
            limit. Default values are based on a few experiments on miplib instances.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCutMaxActiveCountValue">
            <summary>Gets whether the "cut_max_active_count_value" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCutMaxActiveCountValue">
            <summary>Clears the value of the "cut_max_active_count_value" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CutActiveCountDecayFieldNumber">
            <summary>Field number for the "cut_active_count_decay" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCutActiveCountDecay">
            <summary>Gets whether the "cut_active_count_decay" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCutActiveCountDecay">
            <summary>Clears the value of the "cut_active_count_decay" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CutCleanupTargetFieldNumber">
            <summary>Field number for the "cut_cleanup_target" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CutCleanupTarget">
            <summary>
            Target number of constraints to remove during cleanup.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCutCleanupTarget">
            <summary>Gets whether the "cut_cleanup_target" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCutCleanupTarget">
            <summary>Clears the value of the "cut_cleanup_target" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.NewConstraintsBatchSizeFieldNumber">
            <summary>Field number for the "new_constraints_batch_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.NewConstraintsBatchSize">
            <summary>
            Add that many lazy constraints (or cuts) at once in the LP. Note that at
            the beginning of the solve, we do add more than this.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasNewConstraintsBatchSize">
            <summary>Gets whether the "new_constraints_batch_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearNewConstraintsBatchSize">
            <summary>Clears the value of the "new_constraints_batch_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExploitIntegerLpSolutionFieldNumber">
            <summary>Field number for the "exploit_integer_lp_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExploitIntegerLpSolution">
            <summary>
            If true and the Lp relaxation of the problem has an integer optimal
            solution, try to exploit it. Note that since the LP relaxation may not
            contain all the constraints, such a solution is not necessarily a solution
            of the full problem.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExploitIntegerLpSolution">
            <summary>Gets whether the "exploit_integer_lp_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExploitIntegerLpSolution">
            <summary>Clears the value of the "exploit_integer_lp_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExploitAllLpSolutionFieldNumber">
            <summary>Field number for the "exploit_all_lp_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExploitAllLpSolution">
            <summary>
            If true and the Lp relaxation of the problem has a solution, try to exploit
            it. This is same as above except in this case the lp solution might not be
            an integer solution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExploitAllLpSolution">
            <summary>Gets whether the "exploit_all_lp_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExploitAllLpSolution">
            <summary>Clears the value of the "exploit_all_lp_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExploitBestSolutionFieldNumber">
            <summary>Field number for the "exploit_best_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExploitBestSolution">
            <summary>
            When branching on a variable, follow the last best solution value.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExploitBestSolution">
            <summary>Gets whether the "exploit_best_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExploitBestSolution">
            <summary>Clears the value of the "exploit_best_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExploitRelaxationSolutionFieldNumber">
            <summary>Field number for the "exploit_relaxation_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExploitRelaxationSolution">
            <summary>
            When branching on a variable, follow the last best relaxation solution
            value. We use the relaxation with the tightest bound on the objective as
            the best relaxation solution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExploitRelaxationSolution">
            <summary>Gets whether the "exploit_relaxation_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExploitRelaxationSolution">
            <summary>Clears the value of the "exploit_relaxation_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExploitObjectiveFieldNumber">
            <summary>Field number for the "exploit_objective" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExploitObjective">
            <summary>
            When branching an a variable that directly affect the objective,
            branch on the value that lead to the best objective first.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExploitObjective">
            <summary>Gets whether the "exploit_objective" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExploitObjective">
            <summary>Clears the value of the "exploit_objective" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.DetectLinearizedProductFieldNumber">
            <summary>Field number for the "detect_linearized_product" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.DetectLinearizedProduct">
            <summary>
            Infer products of Boolean or of Boolean time IntegerVariable from the
            linear constrainst in the problem. This can be used in some cuts, altough
            for now we don't really exploit it.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasDetectLinearizedProduct">
            <summary>Gets whether the "detect_linearized_product" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearDetectLinearizedProduct">
            <summary>Clears the value of the "detect_linearized_product" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipMaxBoundFieldNumber">
            <summary>Field number for the "mip_max_bound" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipMaxBound">
            <summary>
            We need to bound the maximum magnitude of the variables for CP-SAT, and
            that is the bound we use. If the MIP model expect larger variable value in
            the solution, then the converted model will likely not be relevant.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipMaxBound">
            <summary>Gets whether the "mip_max_bound" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipMaxBound">
            <summary>Clears the value of the "mip_max_bound" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipVarScalingFieldNumber">
            <summary>Field number for the "mip_var_scaling" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipVarScaling">
            <summary>
            All continuous variable of the problem will be multiplied by this factor.
            By default, we don't do any variable scaling and rely on the MIP model to
            specify continuous variable domain with the wanted precision.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipVarScaling">
            <summary>Gets whether the "mip_var_scaling" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipVarScaling">
            <summary>Clears the value of the "mip_var_scaling" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipScaleLargeDomainFieldNumber">
            <summary>Field number for the "mip_scale_large_domain" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipScaleLargeDomain">
            <summary>
            If this is false, then mip_var_scaling is only applied to variables with
            "small" domain. If it is true, we scale all floating point variable
            independenlty of their domain.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipScaleLargeDomain">
            <summary>Gets whether the "mip_scale_large_domain" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipScaleLargeDomain">
            <summary>Clears the value of the "mip_scale_large_domain" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipAutomaticallyScaleVariablesFieldNumber">
            <summary>Field number for the "mip_automatically_scale_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipAutomaticallyScaleVariables">
            <summary>
            If true, some continuous variable might be automatically scaled. For now,
            this is only the case where we detect that a variable is actually an
            integer multiple of a constant. For instance, variables of the form k * 0.5
            are quite frequent, and if we detect this, we will scale such variable
            domain by 2 to make it implied integer.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipAutomaticallyScaleVariables">
            <summary>Gets whether the "mip_automatically_scale_variables" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipAutomaticallyScaleVariables">
            <summary>Clears the value of the "mip_automatically_scale_variables" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.OnlySolveIpFieldNumber">
            <summary>Field number for the "only_solve_ip" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.OnlySolveIp">
             <summary>
             If one try to solve a MIP model with CP-SAT, because we assume all variable
             to be integer after scaling, we will not necessarily have the correct
             optimal. Note however that all feasible solutions are valid since we will
             just solve a more restricted version of the original problem.
            
             This parameters is here to prevent user to think the solution is optimal
             when it might not be. One will need to manually set this to false to solve
             a MIP model where the optimal might be different.
            
             Note that this is tested after some MIP presolve steps, so even if not
             all original variable are integer, we might end up with a pure IP after
             presolve and after implied integer detection.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasOnlySolveIp">
            <summary>Gets whether the "only_solve_ip" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearOnlySolveIp">
            <summary>Clears the value of the "only_solve_ip" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipWantedPrecisionFieldNumber">
            <summary>Field number for the "mip_wanted_precision" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipWantedPrecision">
             <summary>
             When scaling constraint with double coefficients to integer coefficients,
             we will multiply by a power of 2 and round the coefficients. We will choose
             the lowest power such that we have no potential overflow (see
             mip_max_activity_exponent) and the worst case constraint activity error
             does not exceed this threshold.
            
             Note that we also detect constraint with rational coefficients and scale
             them accordingly when it seems better instead of using a power of 2.
            
             We also relax all constraint bounds by this absolute value. For pure
             integer constraint, if this value if lower than one, this will not change
             anything. However it is needed when scaling MIP problems.
            
             If we manage to scale a constraint correctly, the maximum error we can make
             will be twice this value (once for the scaling error and once for the
             relaxed bounds). If we are not able to scale that well, we will display
             that fact but still scale as best as we can.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipWantedPrecision">
            <summary>Gets whether the "mip_wanted_precision" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipWantedPrecision">
            <summary>Clears the value of the "mip_wanted_precision" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipMaxActivityExponentFieldNumber">
            <summary>Field number for the "mip_max_activity_exponent" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipMaxActivityExponent">
             <summary>
             To avoid integer overflow, we always force the maximum possible constraint
             activity (and objective value) according to the initial variable domain to
             be smaller than 2 to this given power. Because of this, we cannot always
             reach the "mip_wanted_precision" parameter above.
            
             This can go as high as 62, but some internal algo currently abort early if
             they might run into integer overflow, so it is better to keep it a bit
             lower than this.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipMaxActivityExponent">
            <summary>Gets whether the "mip_max_activity_exponent" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipMaxActivityExponent">
            <summary>Clears the value of the "mip_max_activity_exponent" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipCheckPrecisionFieldNumber">
            <summary>Field number for the "mip_check_precision" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipCheckPrecision">
            <summary>
            As explained in mip_precision and mip_max_activity_exponent, we cannot
            always reach the wanted precision during scaling. We use this threshold to
            enphasize in the logs when the precision seems bad.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipCheckPrecision">
            <summary>Gets whether the "mip_check_precision" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipCheckPrecision">
            <summary>Clears the value of the "mip_check_precision" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipComputeTrueObjectiveBoundFieldNumber">
            <summary>Field number for the "mip_compute_true_objective_bound" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipComputeTrueObjectiveBound">
            <summary>
            Even if we make big error when scaling the objective, we can always derive
            a correct lower bound on the original objective by using the exact lower
            bound on the scaled integer version of the objective. This should be fast,
            but if you don't care about having a precise lower bound, you can turn it
            off.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipComputeTrueObjectiveBound">
            <summary>Gets whether the "mip_compute_true_objective_bound" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipComputeTrueObjectiveBound">
            <summary>Clears the value of the "mip_compute_true_objective_bound" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipMaxValidMagnitudeFieldNumber">
            <summary>Field number for the "mip_max_valid_magnitude" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipMaxValidMagnitude">
            <summary>
            Any finite values in the input MIP must be below this threshold, otherwise
            the model will be reported invalid. This is needed to avoid floating point
            overflow when evaluating bounds * coeff for instance. We are a bit more
            defensive, but in practice, users shouldn't use super large values in a
            MIP.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipMaxValidMagnitude">
            <summary>Gets whether the "mip_max_valid_magnitude" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipMaxValidMagnitude">
            <summary>Clears the value of the "mip_max_valid_magnitude" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipTreatHighMagnitudeBoundsAsInfinityFieldNumber">
            <summary>Field number for the "mip_treat_high_magnitude_bounds_as_infinity" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipTreatHighMagnitudeBoundsAsInfinity">
             <summary>
             By default, any variable/constraint bound with a finite value and a
             magnitude greater than the mip_max_valid_magnitude will result with a
             invalid model. This flags change the behavior such that such bounds are
             silently transformed to + or -.
            
             It is recommended to keep it at false, and create valid bounds.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipTreatHighMagnitudeBoundsAsInfinity">
            <summary>Gets whether the "mip_treat_high_magnitude_bounds_as_infinity" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipTreatHighMagnitudeBoundsAsInfinity">
            <summary>Clears the value of the "mip_treat_high_magnitude_bounds_as_infinity" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipDropToleranceFieldNumber">
            <summary>Field number for the "mip_drop_tolerance" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipDropTolerance">
            <summary>
            Any value in the input mip with a magnitude lower than this will be set to
            zero. This is to avoid some issue in LP presolving.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipDropTolerance">
            <summary>Gets whether the "mip_drop_tolerance" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipDropTolerance">
            <summary>Clears the value of the "mip_drop_tolerance" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipPresolveLevelFieldNumber">
            <summary>Field number for the "mip_presolve_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipPresolveLevel">
            <summary>
            When solving a MIP, we do some basic floating point presolving before
            scaling the problem to integer to be handled by CP-SAT. This control how
            much of that presolve we do. It can help to better scale floating point
            model, but it is not always behaving nicely.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipPresolveLevel">
            <summary>Gets whether the "mip_presolve_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipPresolveLevel">
            <summary>Clears the value of the "mip_presolve_level" field</summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types">
            <summary>Container for nested types declared in the SatParameters message type.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.VariableOrder">
            <summary>
            Variables without activity (i.e. at the beginning of the search) will be
            tried in this preferred order.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.VariableOrder.InOrder">
            <summary>
            As specified by the problem.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.Polarity">
             <summary>
             Specifies the initial polarity (true/false) when the solver branches on a
             variable. This can be modified later by the user, or the phase saving
             heuristic.
            
             Note(user): POLARITY_FALSE is usually a good choice because of the
             "natural" way to express a linear boolean problem.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.ConflictMinimizationAlgorithm">
            <summary>
            Do we try to minimize conflicts (greedily) when creating them.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.BinaryMinizationAlgorithm">
            <summary>
            Whether to expoit the binary clause to minimize learned clauses further.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.ClauseProtection">
            <summary>
            Each time a clause activity is bumped, the clause has a chance to be
            protected during the next cleanup phase. Note that clauses used as a reason
            are always protected.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.ClauseProtection.ProtectionNone">
            <summary>
            No protection.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.ClauseProtection.ProtectionAlways">
            <summary>
            Protect all clauses whose activity is bumped.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.ClauseProtection.ProtectionLbd">
            <summary>
            Only protect clause with a better LBD.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.ClauseOrdering">
            <summary>
            The clauses that will be kept during a cleanup are the ones that come
            first under this order. We always keep or exclude ties together.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.ClauseOrdering.ClauseActivity">
            <summary>
            Order clause by decreasing activity, then by increasing LBD.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.ClauseOrdering.ClauseLbd">
            <summary>
            Order clause by increasing LBD, then by decreasing activity.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.RestartAlgorithm">
             <summary>
             Restart algorithms.
            
             A reference for the more advanced ones is:
             Gilles Audemard, Laurent Simon, "Refining Restarts Strategies for SAT
             and UNSAT", Principles and Practice of Constraint Programming Lecture
             Notes in Computer Science 2012, pp 118-126
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.RestartAlgorithm.LubyRestart">
            <summary>
            Just follow a Luby sequence times restart_period.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.RestartAlgorithm.DlMovingAverageRestart">
            <summary>
            Moving average restart based on the decision level of conflicts.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.RestartAlgorithm.LbdMovingAverageRestart">
            <summary>
            Moving average restart based on the LBD of conflicts.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.RestartAlgorithm.FixedRestart">
            <summary>
            Fixed period restart every restart period.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.MaxSatAssumptionOrder">
            <summary>
            In what order do we add the assumptions in a core-based max-sat algorithm
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.MaxSatStratificationAlgorithm">
            <summary>
            What stratification algorithm we use in the presence of weight.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.MaxSatStratificationAlgorithm.StratificationNone">
            <summary>
            No stratification of the problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.MaxSatStratificationAlgorithm.StratificationDescent">
            <summary>
            Start with literals with the highest weight, and when SAT, add the
            literals with the next highest weight and so on.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.MaxSatStratificationAlgorithm.StratificationAscent">
            <summary>
            Start with all literals. Each time a core is found with a given minimum
            weight, do not consider literals with a lower weight for the next core
            computation. If the subproblem is SAT, do like in STRATIFICATION_DESCENT
            and just add the literals with the next highest weight.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.SearchBranching">
            <summary>
            The search branching will be used to decide how to branch on unfixed nodes.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.AutomaticSearch">
            <summary>
            Try to fix all literals using the underlying SAT solver's heuristics,
            then generate and fix literals until integer variables are fixed. New
            literals on integer variables are generated using the fixed search
            specified by the user or our default one.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.FixedSearch">
            <summary>
            If used then all decisions taken by the solver are made using a fixed
            order as specified in the API or in the CpModelProto search_strategy
            field.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.PortfolioSearch">
            <summary>
            Simple portfolio search used by LNS workers.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.LpSearch">
            <summary>
            If used, the solver will use heuristics from the LP relaxation. This
            exploit the reduced costs of the variables in the relaxation.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.PseudoCostSearch">
            <summary>
            If used, the solver uses the pseudo costs for branching. Pseudo costs
            are computed using the historical change in objective bounds when some
            decision are taken. Note that this works whether we use an LP or not.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.PortfolioWithQuickRestartSearch">
            <summary>
            Mainly exposed here for testing. This quickly tries a lot of randomized
            heuristics with a low conflict limit. It usually provides a good first
            solution.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.HintSearch">
            <summary>
            Mainly used internally. This is like FIXED_SEARCH, except we follow the
            solution_hint field of the CpModelProto rather than using the information
            provided in the search_strategy.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.PartialFixedSearch">
            <summary>
            Similar to FIXED_SEARCH, but differ in how the variable not listed into
            the fixed search heuristics are branched on. This will always start the
            search tree according to the specified fixed search strategy, but will
            complete it using the default automatic search.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.RandomizedSearch">
            <summary>
            Randomized search. Used to increase entropy in the search.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SharedTreeSplitStrategy.SplitStrategyAuto">
            <summary>
            Uses the default strategy, currently equivalent to
            SPLIT_STRATEGY_DISCREPANCY.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SharedTreeSplitStrategy.SplitStrategyDiscrepancy">
            <summary>
            Only accept splits if the node to be split's depth+discrepancy is minimal
            for the desired number of leaves.
            The preferred child for discrepancy calculation is the one with the
            lowest objective lower bound or the original branch direction if the
            bounds are equal. This rule allows twice as many workers to work in the
            preferred subtree as non-preferred.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SharedTreeSplitStrategy.SplitStrategyObjectiveLb">
            <summary>
            Only split nodes with an objective lb equal to the global lb. If there is
            no objective, this is equivalent to SPLIT_STRATEGY_FIRST_PROPOSAL.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SharedTreeSplitStrategy.SplitStrategyBalancedTree">
            <summary>
            Attempt to keep the shared tree balanced.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SharedTreeSplitStrategy.SplitStrategyFirstProposal">
            <summary>
            Workers race to split their subtree, the winner's proposal is accepted.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.FPRoundingMethod">
            <summary>
            Rounding method to use for feasibility pump.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.FPRoundingMethod.NearestInteger">
            <summary>
            Rounds to the nearest integer value.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.FPRoundingMethod.LockBased">
            <summary>
            Counts the number of linear constraints restricting the variable in the
            increasing values (up locks) and decreasing values (down locks). Rounds
            the variable in the direction of lesser locks.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.FPRoundingMethod.ActiveLockBased">
            <summary>
            Similar to lock based rounding except this only considers locks of active
            constraints from the last lp solve.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.FPRoundingMethod.PropagationAssisted">
            <summary>
            This is expensive rounding algorithm. We round variables one by one and
            propagate the bounds in between. If none of the rounded values fall in
            the continuous domain specified by lower and upper bound, we use the
            current lower/upper bound (whichever one is closest) instead of rounding
            the fractional lp solution value. If both the rounded values are in the
            domain, we round to nearest integer.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.Constraint">
             <summary>
             Wrapper around a ConstraintProto.
             </summary>
            
             <remarks>Constraints created by the CpModel class are automatically added to the model. One needs this
             class to add an enforcement literal to a constraint. </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.Constraint.OnlyEnforceIf(Google.OrTools.Sat.ILiteral)">
            <summary>Adds a literal to the constraint.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.Constraint.OnlyEnforceIf(Google.OrTools.Sat.ILiteral[])">
            <summary>Adds a list of literals to the constraint.</summary> 
        </member>
        <member name="P:Google.OrTools.Sat.Constraint.Index">
            <summary>The index of the constraint in the model.</summary> 
        </member>
        <member name="P:Google.OrTools.Sat.Constraint.Proto">
            <summary>The underlying constraint proto.</summary> 
        </member>
        <member name="T:Google.OrTools.Sat.CircuitConstraint">
            <summary>
             Specialized circuit constraint.
             </summary>
            
             <remarks>
             This constraint allows adding arcs to the circuit constraint incrementally.
             </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.CircuitConstraint.AddArc(System.Int32,System.Int32,Google.OrTools.Sat.ILiteral)">
             <summary>
             Add an arc to the graph of the circuit constraint.
             </summary>
            
             <param name="tail"> the index of the tail node</param>
             <param name="head"> the index of the head node</param>
             <param name="literal"> it will be set to true if the arc is selected</param>
        </member>
        <member name="T:Google.OrTools.Sat.MultipleCircuitConstraint">
            <summary>
             Specialized multiple circuit constraint.
             </summary>
            
             <remarks>
             This constraint allows adding arcs to the multiple circuit constraint incrementally.
             </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.MultipleCircuitConstraint.AddArc(System.Int32,System.Int32,Google.OrTools.Sat.ILiteral)">
             <summary>
             Add an arc to the graph of the multiple circuit constraint.
             </summary>
            
             <param name="tail"> the index of the tail node</param>
             <param name="head"> the index of the head node</param>
             <param name="literal"> it will be set to true if the arc is selected</param>
        </member>
        <member name="T:Google.OrTools.Sat.TableConstraint">
             <summary>
             Specialized assignment constraint.
             </summary>
            
             <remarks>This constraint allows adding tuples to the allowed/forbidden assignment constraint
             incrementally.</remarks>
        </member>
        <member name="M:Google.OrTools.Sat.TableConstraint.AddTuple(System.Collections.Generic.IEnumerable{System.Int32})">
             <summary>
             Adds a tuple of possible/forbidden values to the constraint.
             </summary>
            
             <param name="tuple"> the tuple to add to the constraint</param>
             <exception cref="T:System.ArgumentException"> if the tuple does not have the same length as the array of
                 variables of the constraint</exception>
        </member>
        <member name="M:Google.OrTools.Sat.TableConstraint.AddTuple(System.Collections.Generic.IEnumerable{System.Int64})">
             <summary>
             Adds a tuple of possible/forbidden values to the constraint.
             </summary>
            
             <param name="tuple"> the tuple to add to the constraint</param>
             <exception cref="T:System.ArgumentException"> if the tuple does not have the same length as the array of
                 variables of the constraint</exception>
        </member>
        <member name="M:Google.OrTools.Sat.TableConstraint.AddTuples(System.Int32[0:,0:])">
             <summary>
             Adds a set of tuples of possible/forbidden values to the constraint.
             </summary>
            
             <param name="tuples"> the set of tuple to add to the constraint</param>
             <exception cref="T:System.ArgumentException"> if the tuple does not have the same length as the array of
                 variables of the constraint</exception>
        </member>
        <member name="M:Google.OrTools.Sat.TableConstraint.AddTuples(System.Int64[0:,0:])">
             <summary>
             Adds a set of tuples of possible/forbidden values to the constraint.
             </summary>
            
             <param name="tuples"> the set of tuple to add to the constraint</param>
             <exception cref="T:System.ArgumentException"> if the tuple does not have the same length as the array of
                 variables of the constraint</exception>
        </member>
        <member name="T:Google.OrTools.Sat.AutomatonConstraint">
             <summary>
             Specialized automaton constraint.
             </summary>
            
             <remarks>
             This constraint allows adding transitions to the automaton constraint incrementally.
             </remarks>
        </member>
        <member name="T:Google.OrTools.Sat.ReservoirConstraint">
             <summary>
             Specialized reservoir constraint.
             </summary>
            
             <remarks>
             This constraint allows adding events (time, levelChange, isActive (optional)) to the reservoir
             constraint incrementally.
             </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.ReservoirConstraint.AddEvent``2(``0,``1)">
             <summary>
             Adds a mandatory event.
             </summary>
            
             <remarks>
             It will increase the used capacity by `level_change` at time `time`. `time` must be an affine
             expression.
             </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.ReservoirConstraint.AddOptionalEvent``2(``0,``1,Google.OrTools.Sat.ILiteral)">
             <summary>
             Adds an optional event.
             </summary>
            
             <remarks>
             If `is_active` is true, It will increase the used capacity by `level_change` at time `time`.
             `time` must be an affine expression.
             </remarks>
        </member>
        <member name="T:Google.OrTools.Sat.CumulativeConstraint">
             <summary>
             Specialized cumulative constraint.
             </summary>
            
             <remarks>
             This constraint allows adding (interval, demand) pairs to the cumulative constraint
             incrementally.
             </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.CumulativeConstraint.AddDemand``1(Google.OrTools.Sat.IntervalVar,``0)">
            <summary>Adds a pair (interval, demand) to the constraint. </summary> 
        </member>
        <member name="M:Google.OrTools.Sat.CumulativeConstraint.AddDemands``1(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.IntervalVar},System.Collections.Generic.IEnumerable{``0})">
            <summary>Adds all pairs (interval, demand) to the constraint. </summary> 
        </member>
        <member name="T:Google.OrTools.Sat.NoOverlap2dConstraint">
             <summary>
             Specialized NoOverlap2D constraint.
             </summary>
            
             <remarks>
             This constraint allows adding rectangles to the NoOverlap2D constraint incrementally.
             </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.NoOverlap2dConstraint.AddRectangle(Google.OrTools.Sat.IntervalVar,Google.OrTools.Sat.IntervalVar)">
            <summary>Adds a rectangle (xInterval, yInterval) to the constraint. </summary> 
        </member>
        <member name="T:Google.OrTools.Sat.CpModel">
            <summary>
             Wrapper class around the cp_model proto.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModel.Model">
            <summary>
            The underlying CpModelProto.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.NewIntVar(System.Int64,System.Int64,System.String)">
             <summary>
             Creates an integer variable with domain [lb, ub].
             </summary>
            
             <param name="lb"> the lower bound of the domain</param>
             <param name="ub"> the upper bound of the domain</param>
             <param name="name"> the name of the variable</param>
             <returns> a variable with the given domain</returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.NewIntVarFromDomain(Google.OrTools.Util.Domain,System.String)">
             <summary>
             Creates an integer variable with given domain.
             </summary>
            
             <param name="domain"> an instance of the Domain class</param>
             <param name="name"> the name of the variable</param>
             <returns> a variable with the given domain</returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.NewConstant(System.Int64)">
            <summary>
            Creates a constant variable.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.NewBoolVar(System.String)">
            <summary>
            Creates a Boolean variable with given domain.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.TrueLiteral">
            <summary>
            Returns a constant true literal.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.FalseLiteral">
            <summary>
            Returns a constant false literal.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddLinearConstraint(Google.OrTools.Sat.LinearExpr,System.Int64,System.Int64)">
            <summary>
            Adds <c>lb  expr  ub</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddLinearExpressionInDomain(Google.OrTools.Sat.LinearExpr,Google.OrTools.Util.Domain)">
            <summary>
            Adds <c>expr  domain</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.Add(Google.OrTools.Sat.BoundedLinearExpression)">
            <summary>
            Adds a linear constraint to the model.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddAllDifferent(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.LinearExpr})">
            <summary>
            Adds the constraint <c>AllDifferent(exprs)</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddElement(Google.OrTools.Sat.IntVar,System.Collections.Generic.IEnumerable{Google.OrTools.Sat.IntVar},Google.OrTools.Sat.IntVar)">
            <summary>
            Adds the element constraint: <c>variables[index] == target</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddElement(Google.OrTools.Sat.IntVar,System.Collections.Generic.IEnumerable{System.Int64},Google.OrTools.Sat.IntVar)">
            <summary>
            Adds the element constraint: <c> values[index] == target</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddElement(Google.OrTools.Sat.IntVar,System.Collections.Generic.IEnumerable{System.Int32},Google.OrTools.Sat.IntVar)">
            <summary>
            Adds the element constraint: <c> values[index] == target</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddCircuit">
             <summary>
             Adds and returns an empty circuit constraint.
             </summary>
            
             <remarks> A circuit is a unique Hamiltonian path in a subgraph of the total graph. In case a node <c>i</c>
             is not in the path, then there must be a loop arc <c> i -> i</c> associated with a true
             literal. Otherwise this constraint will fail.
             </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddMultipleCircuit">
             <summary>
             Adds and returns an empty multiple circuit constraint.
             </summary>
            
             <remarks> A multiple circuit is set of cycles in a subgraph of the total graph. The node index by 0
             must be part of all cycles of length > 1. Each node with index > 0 belongs to exactly one
             cycle. If such node does not belong in any cycle of length > 1, then there must be a looping
             arc on this node attached to a literal that will be true. Otherwise, the constraint will fail.
             </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddAllowedAssignments(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.IntVar})">
             <summary>
             Adds <c> AllowedAssignments(variables)</c>.
             </summary>
            
             <remarks>An AllowedAssignments constraint is a constraint on an array of variables that forces, when
             all variables are fixed to a single value, that the corresponding list of values is equal to
             one of the tuples of the tupleList.
             </remarks>
            
             <param name="vars"> a list of variables</param>
             <returns> an instance of the TableConstraint class without any tuples. Tuples can be added
             directly to the table constraint
             </returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddForbiddenAssignments(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.IntVar})">
             <summary>
             Adds <c> ForbiddenAssignments(variables)</c>.
             </summary>
            
             <remarks>A ForbiddenAssignments constraint is a constraint on an array of variables where the list of
             impossible combinations is provided in the tuples list.
             </remarks>
            
             <param name="vars"> a list of variables</param>
             <returns> an instance of the TableConstraint class without any tuples. Tuples can be added
             directly to the table constraint
             </returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddAutomaton(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.IntVar},System.Int64,System.Collections.Generic.IEnumerable{System.Int64})">
             <summary>
             Adds an automaton constraint.
             </summary>
            
             <remarks>
             <para>An automaton constraint takes a list of variables (of size n), an initial state, a set of
             final states, and a set of transitions that will be added incrementally directly on the
             returned AutomatonConstraint instance. A transition is a triplet (<c>tail</c>, <c>transition</c>,
             <c>head</c>), where <c>tail</c> and <c>head</c> are states, and <c>transition</c> is the label of an arc from
             <c>head</c> to <c>tail</c>, corresponding to the value of one variable in the list of variables. </para>
            
             <para>This automaton will be unrolled into a flow with n + 1 phases. Each phase contains the
             possible states of the automaton. The first state contains the initial state. The last phase
             contains the final states. </para>
            
             <para>Between two consecutive phases i and i + 1, the automaton creates a set of arcs. For each
             transition (<c>tail</c>, <c>label</c>, <c>head</c>), it will add an arc from the state <c>tail</c> of phase i and
             the state <c>head</c> of phase i + 1. This arc labeled by the value <c>label</c> of the variables
             <c>variables[i]</c>. That is, this arc can only be selected <c>variables[i]</c>a is assigned the value
             <c>label</c>. </para>
            
             <para>A feasible solution of this constraint is an assignment of variables such that, starting
             from the initial state in phase 0, there is a path labeled by the values of the variables that
             ends in one of the final states in the final phase. </para>
             </remarks>
            
             <param name="vars"> a non empty list of variables whose values correspond to the labels
                 of the arcs traversed by the automaton</param>
             <param name="starting_state"> the initial state of the automaton</param>
             <param name="final_states"> a non empty list of admissible final states </param>
             <returns> an instance of the AutomatonConstraint class </returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddInverse(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.IntVar},System.Collections.Generic.IEnumerable{Google.OrTools.Sat.IntVar})">
             <summary>
             Adds <c> Inverse(variables, inverseVariables)</c>.
             </summary>
            
             <remarks>An inverse constraint enforces that if <c>direct[i] == j</c>, then
             <c>reverse[j] == i</c>, and vice versa.
             </remarks>
            
             <param name="direct"> an array of integer variables</param>
             <param name="reverse"> an array of integer variables</param>
             <returns> an instance of the Constraint class </returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddReservoirConstraint(System.Int64,System.Int64)">
             <summary>
             Adds a reservoir constraint with optional refill/emptying events.
             </summary>
            
             <remarks>
             <para>Maintain a reservoir level within bounds. The water level starts at 0, and at any time, it
             must be within [min_level, max_level].
             </para>
            
             <para>Given an event (time, levelChange, active), if active is true, and if time is assigned a
             value t, then the level of the reservoir changes by levelChange (which is constant) at time t.
             Therefore, at any time t:
             <code>(levelChanges[i] * actives[i] if times[i]  t) in [min_level, max_level]</code>
             </para>
            
             <para>Note that min level must be  0, and the max level must be  0. Please use fixed
             level_changes to simulate an initial state. </para>
             </remarks>
            
             <param name="minLevel"> at any time, the level of the reservoir must be greater of equal than the min
                 level. minLevel must me  0 </param>
             <param name="maxLevel"> at any time, the level of the reservoir must be less or equal than the max
                 level. maxLevel must be  0 </param>
             <returns> an instance of the ReservoirConstraint class </returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddMapDomain(Google.OrTools.Sat.IntVar,System.Collections.Generic.IEnumerable{Google.OrTools.Sat.IntVar},System.Int64)">
            <summary>
            Adds <c>var == i + offset  bool_vars[i] == true for all i</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddImplication(Google.OrTools.Sat.ILiteral,Google.OrTools.Sat.ILiteral)">
            <summary>
            Adds <c>a  b</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddBoolOr(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral})">
            <summary>
            Adds <c>Or(literals) == true</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddAtLeastOne(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral})">
            <summary>
            Same as AddBoolOr: <c>(literals)  1</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddAtMostOne(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral})">
            <summary>
            Adds <c> AtMostOne(literals): (literals)  1</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddExactlyOne(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral})">
            <summary>
            Adds <c> ExactlyOne(literals): (literals) == 1</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddBoolAnd(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral})">
            <summary>
            Adds <c>And(literals) == true</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddBoolXor(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral})">
            <summary>
            Adds <c>XOr(literals) == true</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddMinEquality(Google.OrTools.Sat.LinearExpr,System.Collections.Generic.IEnumerable{Google.OrTools.Sat.LinearExpr})">
            <summary>
            Adds <c>target == Min(exprs)</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddMaxEquality(Google.OrTools.Sat.LinearExpr,System.Collections.Generic.IEnumerable{Google.OrTools.Sat.LinearExpr})">
            <summary>
            Adds <c>target == Max(exprs)</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddDivisionEquality``3(``0,``1,``2)">
            <summary>
            Adds <c>target == num / denom</c> (integer division rounded towards 0).
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddAbsEquality(Google.OrTools.Sat.LinearExpr,Google.OrTools.Sat.LinearExpr)">
            <summary>
            Adds <c>target == abs(expr)</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddModuloEquality``3(``0,``1,``2)">
            <summary>
            Adds <c>target == v % m</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddMultiplicationEquality(Google.OrTools.Sat.LinearExpr,System.Collections.Generic.IEnumerable{Google.OrTools.Sat.LinearExpr})">
            <summary>
            Adds <c>target == (exprs)</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddMultiplicationEquality(Google.OrTools.Sat.LinearExpr,Google.OrTools.Sat.LinearExpr,Google.OrTools.Sat.LinearExpr)">
            <summary>
            Adds <c>target == left * right</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.NewIntervalVar``3(``0,``1,``2,System.String)">
             <summary>
             Creates an interval variable from three affine expressions start, size, and end.
             </summary>
            
             <remarks>An interval variable is a constraint, that is itself used in other constraints like
             NoOverlap. Internally, it ensures that <c>start + size == end</c>.
             </remarks>
            
             <param name="start"> the start of the interval. It needs to be an affine or constant expression. </param>
             <param name="size"> the size of the interval. It needs to be an affine or constant expression. </param>
             <param name="end"> the end of the interval. It needs to be an affine or constant expression. </param>
             <param name="name"> the name of the interval variable </param>
             <returns> An IntervalVar object</returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.NewFixedSizeIntervalVar``1(``0,System.Int64,System.String)">
             <summary>
             Creates an interval variable from an affine expression start, and a fixed size.
             </summary>
            
             <remarks>An interval variable is a constraint, that is itself used in other constraints like
             NoOverlap.
             </remarks>
            
             <param name="start"> the start of the interval. It needs to be an affine or constant expression.         *
             </param>
             <param name="size"> the fixed size of the interval </param>
             <param name="name"> the name of the interval variable </param>
             <returns> An IntervalVar object</returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.NewOptionalIntervalVar``3(``0,``1,``2,Google.OrTools.Sat.ILiteral,System.String)">
             <summary>
             Creates an optional interval variable from three affine expressions start, size, and end, and a literal
             is_present.
             </summary>
            
             <remarks>An interval variable is a constraint, that is itself used in other constraints like
             NoOverlap. Internally, it ensures that <c>is_present  start + size == end</c>.
             </remarks>
            
             <param name="start"> the start of the interval. It needs to be an affine or constant expression. </param>
             <param name="size"> the size of the interval. It needs to be an affine or constant expression. </param>
             <param name="end"> the end of the interval. It needs to be an affine or constant expression. </param>
             <param name="is_present"> a literal that indicates if the interval is active or not. A inactive interval
                 is simply ignored by all constraints.</param>
             <param name="name"> the name of the interval variable </param>
             <returns> An IntervalVar object</returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.NewOptionalFixedSizeIntervalVar``1(``0,System.Int64,Google.OrTools.Sat.ILiteral,System.String)">
             <summary>
             Creates an optional interval variable from an affine expression start, a fixed size, and a literal
             is_present.
             </summary>
            
             <remarks>An interval variable is a constraint, that is itself used in other constraints like
             NoOverlap.
             </remarks>
            
             <param name="start"> the start of the interval. It needs to be an affine or constant expression.         *
             </param>
             <param name="size"> the fixed size of the interval </param>
             <param name="is_present"> a literal that indicates if the interval is active or not. A inactive interval
                 is simply ignored by all constraints.</param>
             <param name="name"> the name of the interval variable </param>
             <returns> An IntervalVar object</returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddNoOverlap(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.IntervalVar})">
             Adds <c> NoOverlap(intervalVars)</c>.
            
             <remarks>A NoOverlap constraint ensures that all present intervals do not overlap in time.
             </remarks>
            
             <param name="intervals"> the list of interval variables to constrain</param>
             <returns> an instance of the Constraint class</returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddNoOverlap2D">
             <summary>
             Adds <c>NoOverlap2D()</c>.
             </summary>
            
             <remarks>
             <para>A NoOverlap2D constraint ensures that all present rectangles do not overlap on a plan. Each
             rectangle is aligned with the X and Y axis, and is defined by two intervals which represent its
             projection onto the X and Y axis. </para>
            
             <para>Furthermore, one box is optional if at least one of the x or y interval is optional. </para>
             </remarks>
            
             <returns> an instance of the NoOverlap2dConstraint class. This class allows adding rectangles
                 incrementally</returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddCumulative``1(``0)">
             <summary>
             Adds <c>Cumulative(capacity)</c>.
             </summary>
            
             <remarks>
             This constraint enforces that:
             <code>
             forall t:
                  ( demands[i] if (start(intervals[t])  t &lt; end(intervals[t])) and
                                   (t is present) )  capacity
             </code>
             </remarks>
            
             <param name="capacity"> the maximum capacity of the cumulative constraint. It must be a positive affine
                 expression </param>
             <returns> an instance of the CumulativeConstraint class. this class allows adding (interval,
                 demand) pairs incrementally </returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.Minimize(Google.OrTools.Sat.LinearExpr)">
            <summary>Adds a minimization objective of a linear expression.</summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.Maximize(Google.OrTools.Sat.LinearExpr)">
            <summary>Adds a maximization objective of a linear expression.</summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.ClearObjective">
            <summary>Clears the objective.</summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.HasObjective">
            <summary>Returns whether the model contains an objective.</summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddDecisionStrategy(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.IntVar},Google.OrTools.Sat.DecisionStrategyProto.Types.VariableSelectionStrategy,Google.OrTools.Sat.DecisionStrategyProto.Types.DomainReductionStrategy)">
            <summary>Adds <c> DecisionStrategy(variables, var_str, dom_str)</c>.</summary>. 
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddHint(Google.OrTools.Sat.IntVar,System.Int64)">
            <summary>Adds variable hinting to the model.</summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddHint(Google.OrTools.Sat.ILiteral,System.Boolean)">
            <summary>Adds variable hinting to the model.</summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.ClearHints">
            <summary>Clears all hinting from the model.</summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddAssumption(Google.OrTools.Sat.ILiteral)">
            <summary>Adds a literal to the model as assumption.</summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.AddAssumptions(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral})">
            <summary>Adds multiple literals to the model as assumptions.</summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.ClearAssumptions">
            <summary>Clears all assumptions from the model.</summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.ModelStats">
            <summary>Returns some statistics on model as a string. </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.ExportToFile(System.String)">
             <summary>
             Write the model as a protocol buffer to <c>file</c>.
             </summary>
            
             <param name="file"> file to write the model to. If the filename ends with <c>txt</c>, the
                model will be written as a text file, otherwise, the binary format will be used. </param>
            
             <returns> true if the model was correctly written </returns>
        </member>
        <member name="M:Google.OrTools.Sat.CpModel.Validate">
            <summary>
            Returns a non empty string explaining the issue if the model is invalid.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpSolver">
             <summary>
             Wrapper around the SAT solver.
             </summary>
            
             <remarks>This class proposes a <c>Solve()</c> method, as well as accessors to get the values of
             variables in the best solution, as well as general statistics of the search.
             </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.CpSolver.Solve(Google.OrTools.Sat.CpModel,Google.OrTools.Sat.SolutionCallback)">
            <summary>Solves the given model, and returns the solve status.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.CpSolver.SolveWithSolutionCallback(Google.OrTools.Sat.CpModel,Google.OrTools.Sat.SolutionCallback)">
            <summary> Deprecated, use Solve() instead. </summary> 
        </member>
        <member name="M:Google.OrTools.Sat.CpSolver.SearchAllSolutions(Google.OrTools.Sat.CpModel,Google.OrTools.Sat.SolutionCallback)">
            <summary> Deprecated, use Solve() instead. </summary> 
        </member>
        <member name="M:Google.OrTools.Sat.CpSolver.StopSearch">
            <summary>Stops the search asynchronously.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.CpSolver.ResponseStats">
            <summary>Statistics on the solution found as a string.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolver.ObjectiveValue">
            <summary>The best objective value found during search.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolver.BestObjectiveBound">
            <summary>
            The best lower bound found when minimizing, of the best upper bound found when maximizing
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolver.StringParameters">
            The parameters of the search, stored as a string 
        </member>
        <member name="M:Google.OrTools.Sat.CpSolver.Value(Google.OrTools.Sat.IntVar)">
            <summary>
            Returns the value of an integer variable in the last solution found.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpSolver.Value(Google.OrTools.Sat.LinearExpr)">
            <summary>
            Returns the value of a linear expression in the last solution found.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpSolver.BooleanValue(Google.OrTools.Sat.ILiteral)">
            <summary>
            Returns the Boolean value of a literal in the last solution found.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpSolver.NumBranches">
            <summary>Returns the number of branches explored during search. </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpSolver.NumConflicts">
            <summary>Returns the number of conflicts created during search. </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpSolver.WallTime">
            <summary>Returns the wall time of the search. </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpSolver.SolutionInfo">
            <summary>
            Returns some information on how the solution was found, or the reason why the model or the
            parameters are invalid.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.ILiteral">
            <summary>Holds a Boolean variable or its negation.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.ILiteral.Not">
            <summary>Returns the Boolean negation of the literal.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.ILiteral.GetIndex">
            <summary>Returns the logical index of the literal. </summary> 
        </member>
        <member name="M:Google.OrTools.Sat.ILiteral.AsExpr">
            <summary>Returns the literal as a linear expression.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.ILiteral.NotAsExpr">
            <summary>Returns the Boolean negation of the literal as a linear expression.</summary> 
        </member>
        <member name="T:Google.OrTools.Sat.LinearExpr">
            <summary>
            Holds a linear expression: <c>sum (ai * xi) + b</c>.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.Sum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.LinearExpr})">
            <summary> Creates <c>Sum(exprs)</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.Sum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral})">
            <summary> Creates <c>Sum(literals)</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.Sum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.BoolVar})">
            <summary> Creates <c>Sum(vars)</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.WeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.LinearExpr},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary> Creates <c>Sum(exprs[i] * coeffs[i])</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.WeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.LinearExpr},System.Collections.Generic.IEnumerable{System.Int64})">
            <summary> Creates <c>Sum(exprs[i] * coeffs[i])</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.WeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary> Creates <c>Sum(literals[i] * coeffs[i])</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.WeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral},System.Collections.Generic.IEnumerable{System.Int64})">
            <summary> Creates <c>Sum(literals[i] * coeffs[i])</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.WeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.BoolVar},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary> Creates <c>Sum(vars[i] * coeffs[i])</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.WeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.BoolVar},System.Collections.Generic.IEnumerable{System.Int64})">
            <summary> Creates <c>Sum(vars[i] * coeffs[i])</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.Term(Google.OrTools.Sat.LinearExpr,System.Int64)">
            <summary> Creates <c>expr * coeff</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.Term(Google.OrTools.Sat.ILiteral,System.Int64)">
            <summary> Creates <c>literal * coeff</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.Term(Google.OrTools.Sat.BoolVar,System.Int64)">
            <summary> Creates <c>var * coeff</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.Affine(Google.OrTools.Sat.LinearExpr,System.Int64,System.Int64)">
            <summary> Creates <c>expr * coeff + offset</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.Affine(Google.OrTools.Sat.ILiteral,System.Int64,System.Int64)">
            <summary> Creates <c>literal * coeff + offset</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.Affine(Google.OrTools.Sat.BoolVar,System.Int64,System.Int64)">
            <summary> Creates <c>var * coeff + offset</c>.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.Constant(System.Int64)">
            <summary> Creates a constant expression.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExpr.NewBuilder(System.Int32)">
            <summary> Creates a builder class for linear expression.</summary> 
        </member>
        <member name="T:Google.OrTools.Sat.LinearExprBuilder">
            <summary> A builder class for linear expressions.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.Add(Google.OrTools.Sat.LinearExpr)">
            <summary> Adds <c>expr</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.Add(Google.OrTools.Sat.ILiteral)">
            <summary> Adds <c>literal</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.Add(Google.OrTools.Sat.BoolVar)">
            <summary> Adds <c>var</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.Add(System.Int64)">
            <summary> Adds <c>constant</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.AddTerm(Google.OrTools.Sat.LinearExpr,System.Int64)">
            <summary> Adds <c>expr * coefficient</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.AddTerm(Google.OrTools.Sat.ILiteral,System.Int64)">
            <summary> Adds <c>literal * coefficient</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.AddTerm(Google.OrTools.Sat.BoolVar,System.Int64)">
            <summary> Adds <c>var * coefficient</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.AddSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.LinearExpr})">
            <summary> Adds <c>sum(exprs)</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.AddSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral})">
            <summary> Adds <c>sum(literals)</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.AddSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.BoolVar})">
            <summary> Adds <c>sum(vars)</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.AddWeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.LinearExpr},System.Collections.Generic.IEnumerable{System.Int64})">
            <summary> Adds <c>sum(exprs[i] * coeffs[i])</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.AddWeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.LinearExpr},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary> Adds <c>sum(exprs[i] * coeffs[i])</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.AddWeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary> Adds <c>sum(literals[i] * coeffs[i])</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.AddWeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.ILiteral},System.Collections.Generic.IEnumerable{System.Int64})">
            <summary> Adds <c>sum(literals[i] * coeffs[i])</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.AddWeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.BoolVar},System.Collections.Generic.IEnumerable{System.Int64})">
            <summary> Adds <c>sum(vars[i] * coeffs[i])</c> to the builder.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.LinearExprBuilder.AddWeightedSum(System.Collections.Generic.IEnumerable{Google.OrTools.Sat.BoolVar},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary> Adds <c>sum(vars[i] * coeffs[i])</c> to the builder.</summary> 
        </member>
        <member name="T:Google.OrTools.Sat.IntVar">
            <summary>
            Holds a integer variable with a discrete domain.
            </summary>
            <remarks>
            This class must be constructed from the CpModel class.
            </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.IntVar.GetIndex">
            Returns the index of the variable in the underlying CpModelProto. 
        </member>
        <member name="P:Google.OrTools.Sat.IntVar.Index">
            Returns the index of the variable in the underlying CpModelProto. 
        </member>
        <member name="P:Google.OrTools.Sat.IntVar.Proto">
            The underlying IntegerVariableProto. 
        </member>
        <member name="P:Google.OrTools.Sat.IntVar.Domain">
            Returns the domain of the variable. 
        </member>
        <member name="M:Google.OrTools.Sat.IntVar.Name">
            Returns the name of the variable given upon creation. 
        </member>
        <member name="T:Google.OrTools.Sat.BoolVar">
            <summary>
            Holds a Boolean variable.
            </summary>
            <remarks>
            This class must be constructed from the CpModel class.
            </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.BoolVar.Not">
            <summary> Returns the Boolean negation of that variable.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.BoolVar.AsExpr">
            <summary>Returns the literal as a linear expression.</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.BoolVar.NotAsExpr">
            <summary> Returns the Boolean negation of that variable as a linear expression.</summary> 
        </member>
        <member name="T:Google.OrTools.Sat.BoundedLinearExpression">
            <summary>
            Holds a linear constraint: <c> expression  domain</c>
            </summary>
            <remarks>
            This class must be constructed from the CpModel class or from the comparison operators.
            </remarks>
        </member>
        <member name="T:Google.OrTools.Sat.IntervalVar">
             <summary>An interval variable </summary>
            
             <remarks>
             This class must be constructed from the CpModel class.
             </remarks>
        </member>
        <member name="M:Google.OrTools.Sat.IntervalVar.GetIndex">
            <summary>The Index of the interval in the model proto</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.IntervalVar.StartExpr">
            <summary>The start expression of the interval</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.IntervalVar.SizeExpr">
            <summary>The size expression of the interval</summary> 
        </member>
        <member name="M:Google.OrTools.Sat.IntervalVar.EndExpr">
            <summary>The end expression of the interval</summary> 
        </member>
        <member name="P:Google.OrTools.Sat.IntervalVar.Proto">
            <summary>The underlying interval proto</summary> 
        </member>
        <member name="T:Google.OrTools.Sat.CpSolverSolutionCallback">
            <summary>
            Parent class to create a callback called at each solution.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpSolverSolutionCallback.Value(Google.OrTools.Sat.LinearExpr)">
            <summary>
            Returns the value of a linear expression in the current solution.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpSolverSolutionCallback.Value(Google.OrTools.Sat.IntVar)">
            <summary>
            Returns the value of an integer variable in the current solution.
            </summary>
        </member>
        <member name="M:Google.OrTools.Sat.CpSolverSolutionCallback.BooleanValue(Google.OrTools.Sat.ILiteral)">
            <summary>
            Returns the Boolean value of a literal in the current solution.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.ObjectiveSolutionPrinter">
            <summary>
            A specialized solution printer.
            </summary>
        </member>
        <member name="T:Google.OrTools.Util.Int128Reflection">
            <summary>Holder for reflection information generated from ortools/util/int128.proto</summary>
        </member>
        <member name="P:Google.OrTools.Util.Int128Reflection.Descriptor">
            <summary>File descriptor for ortools/util/int128.proto</summary>
        </member>
        <member name="T:Google.OrTools.Util.Int128">
            <summary>
            The low 64 bits are stored in "low", and the high 64-bits (including the
            sign) are stored in "high".
            </summary>
        </member>
        <member name="F:Google.OrTools.Util.Int128.HighFieldNumber">
            <summary>Field number for the "high" field.</summary>
        </member>
        <member name="F:Google.OrTools.Util.Int128.LowFieldNumber">
            <summary>Field number for the "low" field.</summary>
        </member>
        <member name="T:Google.OrTools.Util.Int64Vector.Int64VectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.Util.Int64VectorVector.Int64VectorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.Util.OptionalBooleanReflection">
            <summary>Holder for reflection information generated from ortools/util/optional_boolean.proto</summary>
        </member>
        <member name="P:Google.OrTools.Util.OptionalBooleanReflection.Descriptor">
            <summary>File descriptor for ortools/util/optional_boolean.proto</summary>
        </member>
        <member name="T:Google.OrTools.Util.OptionalBoolean">
             <summary>
             A "three-way" boolean: unspecified, false or true.
            
             We don't use the value of 1 to increase the chance to catch bugs: eg. in
             python, a user may set a proto field of this type enum to a boolean value
             without type checks, if they set it to True, the proto validity code will
             catch it (because it'll be cast to 1, which is an invalid enum value).
             Note that if the user sets if to False (i.e. 0), it will be caught by the
             routing library's parameter validity check too.
             </summary>
        </member>
        <member name="T:OperationsResearch.SetCoverReflection">
            <summary>Holder for reflection information generated from ortools/algorithms/set_cover.proto</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverReflection.Descriptor">
            <summary>File descriptor for ortools/algorithms/set_cover.proto</summary>
        </member>
        <member name="F:OperationsResearch.SetCoverProto.SubsetFieldNumber">
            <summary>Field number for the "subset" field.</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverProto.Subset">
            <summary>
            The list of subsets in the model.
            </summary>
        </member>
        <member name="F:OperationsResearch.SetCoverProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverProto.Name">
            <summary>
            A user-defined name for the model.
            </summary>
        </member>
        <member name="P:OperationsResearch.SetCoverProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:OperationsResearch.SetCoverProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:OperationsResearch.SetCoverProto.FingerprintFieldNumber">
            <summary>Field number for the "fingerprint" field.</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverProto.Fingerprint">
            <summary>
            An automatically fingerprint for the model. TODO(user): Implement.
            </summary>
        </member>
        <member name="T:OperationsResearch.SetCoverProto.Types">
            <summary>Container for nested types declared in the SetCoverProto message type.</summary>
        </member>
        <member name="F:OperationsResearch.SetCoverProto.Types.Subset.CostFieldNumber">
            <summary>Field number for the "cost" field.</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverProto.Types.Subset.Cost">
            <summary>
            The cost for using the given subset.
            </summary>
        </member>
        <member name="P:OperationsResearch.SetCoverProto.Types.Subset.HasCost">
            <summary>Gets whether the "cost" field is set</summary>
        </member>
        <member name="M:OperationsResearch.SetCoverProto.Types.Subset.ClearCost">
            <summary>Clears the value of the "cost" field</summary>
        </member>
        <member name="F:OperationsResearch.SetCoverProto.Types.Subset.ElementFieldNumber">
            <summary>Field number for the "element" field.</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverProto.Types.Subset.Element">
            <summary>
            The list of elements in the subset.
            </summary>
        </member>
        <member name="F:OperationsResearch.SetCoverSolutionResponse.StatusFieldNumber">
            <summary>Field number for the "status" field.</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverSolutionResponse.Status">
            <summary>
            For future use. TODO(user): Implement.
            </summary>
        </member>
        <member name="P:OperationsResearch.SetCoverSolutionResponse.HasStatus">
            <summary>Gets whether the "status" field is set</summary>
        </member>
        <member name="M:OperationsResearch.SetCoverSolutionResponse.ClearStatus">
            <summary>Clears the value of the "status" field</summary>
        </member>
        <member name="F:OperationsResearch.SetCoverSolutionResponse.NumSubsetsFieldNumber">
            <summary>Field number for the "num_subsets" field.</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverSolutionResponse.NumSubsets">
            <summary>
            The number of subsets that are selected in the solution. This is used
            to decompress their indices below.
            </summary>
        </member>
        <member name="P:OperationsResearch.SetCoverSolutionResponse.HasNumSubsets">
            <summary>Gets whether the "num_subsets" field is set</summary>
        </member>
        <member name="M:OperationsResearch.SetCoverSolutionResponse.ClearNumSubsets">
            <summary>Clears the value of the "num_subsets" field</summary>
        </member>
        <member name="F:OperationsResearch.SetCoverSolutionResponse.SubsetFieldNumber">
            <summary>Field number for the "subset" field.</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverSolutionResponse.Subset">
            <summary>
            The list of the subsets selected in the solution.
            </summary>
        </member>
        <member name="F:OperationsResearch.SetCoverSolutionResponse.CostFieldNumber">
            <summary>Field number for the "cost" field.</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverSolutionResponse.Cost">
            <summary>
            The cost of the solution, as computed by the algorithm.
            </summary>
        </member>
        <member name="P:OperationsResearch.SetCoverSolutionResponse.HasCost">
            <summary>Gets whether the "cost" field is set</summary>
        </member>
        <member name="M:OperationsResearch.SetCoverSolutionResponse.ClearCost">
            <summary>Clears the value of the "cost" field</summary>
        </member>
        <member name="F:OperationsResearch.SetCoverSolutionResponse.CostLowerBoundFieldNumber">
            <summary>Field number for the "cost_lower_bound" field.</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverSolutionResponse.CostLowerBound">
            <summary>
            A lower bound of the solution, as computed by the algorithm.
            </summary>
        </member>
        <member name="P:OperationsResearch.SetCoverSolutionResponse.HasCostLowerBound">
            <summary>Gets whether the "cost_lower_bound" field is set</summary>
        </member>
        <member name="M:OperationsResearch.SetCoverSolutionResponse.ClearCostLowerBound">
            <summary>Clears the value of the "cost_lower_bound" field</summary>
        </member>
        <member name="F:OperationsResearch.SetCoverSolutionResponse.FingerprintFieldNumber">
            <summary>Field number for the "fingerprint" field.</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverSolutionResponse.Fingerprint">
            <summary>
            An automatically fingerprint for the solution. TODO(user): Implement.
            </summary>
        </member>
        <member name="F:OperationsResearch.SetCoverSolutionResponse.ModelFingerprintFieldNumber">
            <summary>Field number for the "model_fingerprint" field.</summary>
        </member>
        <member name="P:OperationsResearch.SetCoverSolutionResponse.ModelFingerprint">
            <summary>
            A reference to the model the solution applies to. TODO(user): Implement.
            </summary>
        </member>
        <member name="T:OperationsResearch.SetCoverSolutionResponse.Types">
            <summary>Container for nested types declared in the SetCoverSolutionResponse message type.</summary>
        </member>
        <member name="T:OperationsResearch.SetCoverSolutionResponse.Types.Status">
            <summary>
            Result of the optimization.
            </summary>
        </member>
        <member name="F:OperationsResearch.SetCoverSolutionResponse.Types.Status.Undefined">
            <summary>
            Undefined.
            </summary>
        </member>
        <member name="F:OperationsResearch.SetCoverSolutionResponse.Types.Status.Optimal">
            <summary>
            The solver found the proven optimal solution.
            </summary>
        </member>
        <member name="F:OperationsResearch.SetCoverSolutionResponse.Types.Status.Feasible">
            <summary>
            The solver had enough time to find some solution that satisfied all
            constraints, but it did not reach the optimal.
            </summary>
        </member>
        <member name="F:OperationsResearch.SetCoverSolutionResponse.Types.Status.Infeasible">
            <summary>
            The model does not have any solution.
            </summary>
        </member>
        <member name="F:OperationsResearch.SetCoverSolutionResponse.Types.Status.Invalid">
            <summary>
            The model is invalid.
            </summary>
        </member>
        <member name="T:OperationsResearch.LinearSolverReflection">
            <summary>Holder for reflection information generated from ortools/linear_solver/linear_solver.proto</summary>
        </member>
        <member name="P:OperationsResearch.LinearSolverReflection.Descriptor">
            <summary>File descriptor for ortools/linear_solver/linear_solver.proto</summary>
        </member>
        <member name="T:OperationsResearch.MPSolverResponseStatus">
             <summary>
             Status returned by the solver. They follow a hierarchical nomenclature, to
             allow us to add more enum values in the future. Clients should use
             InCategory() to match these enums, with the following C++ pseudo-code:
            
             bool InCategory(MPSolverResponseStatus status, MPSolverResponseStatus cat) {
               if (cat == MPSOLVER_OPTIMAL) return status == MPSOLVER_OPTIMAL;
               while (status > cat) status >>= 4;
               return status == cat;
             }
             </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverOptimal">
             <summary>
             The solver found the proven optimal solution. This is what should be
             returned in most cases.
            
             WARNING: for historical reason, the value is zero, which means that this
             value can't have any subcategories.
             </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverFeasible">
             <summary>
             The solver had enough time to find some solution that satisfies all
             constraints, but it did not prove optimality (which means it may or may
             not have reached the optimal).
            
             This can happen for large LP models (Linear Programming), and is a frequent
             response for time-limited MIPs (Mixed Integer Programming). In the MIP
             case, the difference between the solution 'objective_value' and
             'best_objective_bound' fields of the MPSolutionResponse will give an
             indication of how far this solution is from the optimal one.
             </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverInfeasible">
            <summary>
            The model does not have any solution, according to the solver (which
            "proved" it, with the caveat that numerical proofs aren't actual proofs),
            or based on trivial considerations (eg. a variable whose lower bound is
            strictly greater than its upper bound).
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverUnbounded">
            <summary>
            There exist solutions that make the magnitude of the objective value
            as large as wanted (i.e. -infinity (resp. +infinity) for a minimization
            (resp. maximization) problem.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverAbnormal">
            <summary>
            An error (most probably numerical) occurred.
            One likely cause for such errors is a large numerical range among variable
            coefficients (eg. 1e-16, 1e20), in which case one should try to shrink it.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverNotSolved">
            <summary>
            The solver did not have a chance to diagnose the model in one of the
            categories above.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverModelIsValid">
            <summary>
            Like "NOT_SOLVED", but typically used by model validation functions
            returning a "model status", to enhance readability of the client code.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverCancelledByUser">
            <summary>
            The solve was interrupted by the user, and the solver didn't have time to
            return a proper status.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverUnknownStatus">
            <summary>
            Special value: the solver status could not be properly translated and is
            unknown.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverModelInvalid">
            <summary>
            Model errors. These are always deterministic and repeatable.
            They should be accompanied with a string description of the error.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverModelInvalidSolutionHint">
            <summary>
            Something is wrong with the fields "solution_hint_var_index" and/or
            "solution_hint_var_value".
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverModelInvalidSolverParameters">
            <summary>
            Something is wrong with the solver_specific_parameters request field.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverSolverTypeUnavailable">
            <summary>
            Implementation error: the requested solver implementation is not
            available (see MPModelRequest.solver_type).
            The linear solver binary was probably not linked with the required library,
            eg //ortools/linear_solver:linear_solver_scip for SCIP.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverResponseStatus.MpsolverIncompatibleOptions">
            <summary>
            Some of the selected options were incompatible, e.g. a cancellable solve
            was requested via SolverClient::SolveMipRemotely() with an underlying
            solver that doesn't support cancellation. status_str should contain a
            description of the issue.
            </summary>
        </member>
        <member name="T:OperationsResearch.MPVariableProto">
            <summary>
            A variable is always constrained in the form:
               lower_bound &lt;= x &lt;= upper_bound
            where lower_bound and upper_bound:
            - Can form a singleton: x = constant = lower_bound = upper_bound.
            - Can form a finite interval: lower_bound &lt;= x &lt;= upper_bound. (x is boxed.)
            - Can form a semi-infinite interval.
                - lower_bound = -infinity: x &lt;= upper_bound.
                - upper_bound = +infinity: x >= lower_bound.
            - Can form the infinite interval: lower_bound = -infinity and
              upper_bound = +infinity, x is free.
            MPVariableProto furthermore stores:
             - The coefficient of the variable in the objective.
             - Whether the variable is integer.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPVariableProto.LowerBoundFieldNumber">
            <summary>Field number for the "lower_bound" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPVariableProto.LowerBound">
            <summary>
            lower_bound must be &lt;= upper_bound.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPVariableProto.HasLowerBound">
            <summary>Gets whether the "lower_bound" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPVariableProto.ClearLowerBound">
            <summary>Clears the value of the "lower_bound" field</summary>
        </member>
        <member name="F:OperationsResearch.MPVariableProto.UpperBoundFieldNumber">
            <summary>Field number for the "upper_bound" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPVariableProto.HasUpperBound">
            <summary>Gets whether the "upper_bound" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPVariableProto.ClearUpperBound">
            <summary>Clears the value of the "upper_bound" field</summary>
        </member>
        <member name="F:OperationsResearch.MPVariableProto.ObjectiveCoefficientFieldNumber">
            <summary>Field number for the "objective_coefficient" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPVariableProto.ObjectiveCoefficient">
            <summary>
            The coefficient of the variable in the objective. Must be finite.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPVariableProto.HasObjectiveCoefficient">
            <summary>Gets whether the "objective_coefficient" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPVariableProto.ClearObjectiveCoefficient">
            <summary>Clears the value of the "objective_coefficient" field</summary>
        </member>
        <member name="F:OperationsResearch.MPVariableProto.IsIntegerFieldNumber">
            <summary>Field number for the "is_integer" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPVariableProto.IsInteger">
            <summary>
            True if the variable is constrained to be integer.
            Ignored if MPModelProto::solver_type is *LINEAR_PROGRAMMING*.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPVariableProto.HasIsInteger">
            <summary>Gets whether the "is_integer" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPVariableProto.ClearIsInteger">
            <summary>Clears the value of the "is_integer" field</summary>
        </member>
        <member name="F:OperationsResearch.MPVariableProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPVariableProto.Name">
            <summary>
            The name of the variable.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPVariableProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPVariableProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:OperationsResearch.MPVariableProto.BranchingPriorityFieldNumber">
            <summary>Field number for the "branching_priority" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPVariableProto.HasBranchingPriority">
            <summary>Gets whether the "branching_priority" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPVariableProto.ClearBranchingPriority">
            <summary>Clears the value of the "branching_priority" field</summary>
        </member>
        <member name="T:OperationsResearch.MPConstraintProto">
            <summary>
            A linear constraint is always of the form:
            lower_bound &lt;= sum of linear term elements &lt;= upper_bound,
            where lower_bound and upper_bound:
            - Can form a singleton: lower_bound == upper_bound. The constraint is an
              equation.
            - Can form a finite interval [lower_bound, upper_bound]. The constraint is
              both lower- and upper-bounded, i.e. "boxed".
            - Can form a semi-infinite interval. lower_bound = -infinity: the constraint
              is upper-bounded. upper_bound = +infinity: the constraint is lower-bounded.
            - Can form the infinite interval: lower_bound = -infinity and
              upper_bound = +infinity. The constraint is free.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPConstraintProto.VarIndexFieldNumber">
            <summary>Field number for the "var_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPConstraintProto.VarIndex">
            <summary>
            var_index[i] is the variable index (w.r.t. to "variable" field of
            MPModelProto) of the i-th linear term involved in this constraint, and
            coefficient[i] is its coefficient. Only the terms with non-zero
            coefficients need to appear. var_index may not contain duplicates.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPConstraintProto.CoefficientFieldNumber">
            <summary>Field number for the "coefficient" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPConstraintProto.Coefficient">
            <summary>
            Must be finite.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPConstraintProto.LowerBoundFieldNumber">
            <summary>Field number for the "lower_bound" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPConstraintProto.LowerBound">
            <summary>
            lower_bound must be &lt;= upper_bound.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPConstraintProto.HasLowerBound">
            <summary>Gets whether the "lower_bound" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPConstraintProto.ClearLowerBound">
            <summary>Clears the value of the "lower_bound" field</summary>
        </member>
        <member name="F:OperationsResearch.MPConstraintProto.UpperBoundFieldNumber">
            <summary>Field number for the "upper_bound" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPConstraintProto.HasUpperBound">
            <summary>Gets whether the "upper_bound" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPConstraintProto.ClearUpperBound">
            <summary>Clears the value of the "upper_bound" field</summary>
        </member>
        <member name="F:OperationsResearch.MPConstraintProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPConstraintProto.Name">
            <summary>
            The name of the constraint.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPConstraintProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPConstraintProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:OperationsResearch.MPConstraintProto.IsLazyFieldNumber">
            <summary>Field number for the "is_lazy" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPConstraintProto.IsLazy">
            <summary>
            [Advanced usage: do not use this if you don't know what you're doing.]
            A lazy constraint is handled differently by the core solving engine, but
            it does not change the result. It may or may not impact the performance.
            For more info see: http://tinyurl.com/lazy-constraints.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPConstraintProto.HasIsLazy">
            <summary>Gets whether the "is_lazy" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPConstraintProto.ClearIsLazy">
            <summary>Clears the value of the "is_lazy" field</summary>
        </member>
        <member name="T:OperationsResearch.MPGeneralConstraintProto">
            <summary>
            General constraints. See each individual proto type for more information.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPGeneralConstraintProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPGeneralConstraintProto.Name">
            <summary>
            The name of the constraint.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPGeneralConstraintProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPGeneralConstraintProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:OperationsResearch.MPGeneralConstraintProto.IndicatorConstraintFieldNumber">
            <summary>Field number for the "indicator_constraint" field.</summary>
        </member>
        <member name="F:OperationsResearch.MPGeneralConstraintProto.SosConstraintFieldNumber">
            <summary>Field number for the "sos_constraint" field.</summary>
        </member>
        <member name="F:OperationsResearch.MPGeneralConstraintProto.QuadraticConstraintFieldNumber">
            <summary>Field number for the "quadratic_constraint" field.</summary>
        </member>
        <member name="F:OperationsResearch.MPGeneralConstraintProto.AbsConstraintFieldNumber">
            <summary>Field number for the "abs_constraint" field.</summary>
        </member>
        <member name="F:OperationsResearch.MPGeneralConstraintProto.AndConstraintFieldNumber">
            <summary>Field number for the "and_constraint" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPGeneralConstraintProto.AndConstraint">
            <summary>
            All variables in "and" constraints must be Boolean.
            resultant_var = and(var_1, var_2... var_n)
            </summary>
        </member>
        <member name="F:OperationsResearch.MPGeneralConstraintProto.OrConstraintFieldNumber">
            <summary>Field number for the "or_constraint" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPGeneralConstraintProto.OrConstraint">
            <summary>
            All variables in "or" constraints must be Boolean.
            resultant_var = or(var_1, var_2... var_n)
            </summary>
        </member>
        <member name="F:OperationsResearch.MPGeneralConstraintProto.MinConstraintFieldNumber">
            <summary>Field number for the "min_constraint" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPGeneralConstraintProto.MinConstraint">
            <summary>
            resultant_var = min(var_1, var_2, ..., constant)
            </summary>
        </member>
        <member name="F:OperationsResearch.MPGeneralConstraintProto.MaxConstraintFieldNumber">
            <summary>Field number for the "max_constraint" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPGeneralConstraintProto.MaxConstraint">
            <summary>
            resultant_var = max(var_1, var_2, ..., constant)
            </summary>
        </member>
        <member name="T:OperationsResearch.MPGeneralConstraintProto.GeneralConstraintOneofCase">
            <summary>Enum of possible cases for the "general_constraint" oneof.</summary>
        </member>
        <member name="T:OperationsResearch.MPIndicatorConstraint">
            <summary>
            Indicator constraints encode the activation or deactivation of linear
            constraints given the value of one Boolean variable in the model. For
            example:
                y = 0 => 2 * x1 + 3 * x2 >= 42
            The 2 * x1 + 3 * x2 >= 42 constraint is only active if the variable y is
            equal to 0.
            As of 2019/04, only SCIP, CP-SAT and Gurobi support this constraint type.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPIndicatorConstraint.VarIndexFieldNumber">
            <summary>Field number for the "var_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPIndicatorConstraint.VarIndex">
            <summary>
            Variable index (w.r.t. the "variable" field of MPModelProto) of the Boolean
            variable used as indicator.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPIndicatorConstraint.HasVarIndex">
            <summary>Gets whether the "var_index" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPIndicatorConstraint.ClearVarIndex">
            <summary>Clears the value of the "var_index" field</summary>
        </member>
        <member name="F:OperationsResearch.MPIndicatorConstraint.VarValueFieldNumber">
            <summary>Field number for the "var_value" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPIndicatorConstraint.VarValue">
            <summary>
            Value the above variable should take. Must be 0 or 1.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPIndicatorConstraint.HasVarValue">
            <summary>Gets whether the "var_value" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPIndicatorConstraint.ClearVarValue">
            <summary>Clears the value of the "var_value" field</summary>
        </member>
        <member name="F:OperationsResearch.MPIndicatorConstraint.ConstraintFieldNumber">
            <summary>Field number for the "constraint" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPIndicatorConstraint.Constraint">
            <summary>
            The constraint activated by the indicator variable.
            </summary>
        </member>
        <member name="T:OperationsResearch.MPSosConstraint">
            <summary>
            Special Ordered Set (SOS) constraints of type 1 or 2.
            See https://en.wikipedia.org/wiki/Special_ordered_set
            As of 2019/04, only SCIP and Gurobi support this constraint type.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSosConstraint.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSosConstraint.HasType">
            <summary>Gets whether the "type" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPSosConstraint.ClearType">
            <summary>Clears the value of the "type" field</summary>
        </member>
        <member name="F:OperationsResearch.MPSosConstraint.VarIndexFieldNumber">
            <summary>Field number for the "var_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSosConstraint.VarIndex">
            <summary>
            Variable index (w.r.t. the "variable" field of MPModelProto) of the
            variables in the SOS.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSosConstraint.WeightFieldNumber">
            <summary>Field number for the "weight" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSosConstraint.Weight">
            <summary>
            Optional: SOS weights. If non-empty, must be of the same size as
            "var_index", and strictly increasing. If empty and required by the
            underlying solver, the 1..n sequence will be given as weights.
            SUBTLE: The weights can help the solver make branch-and-bound decisions
            that fit the underlying optimization model: after each LP relaxation, it
            will compute the "average weight" of the SOS variables, weighted by value
            (this is confusing: here we're using the values as weights), and the binary
            branch decision will be: is the non-zero variable above or below that?
            (weights are strictly monotonous, so the "cutoff" average weight
            corresponds to a "cutoff" index in the var_index sequence).
            </summary>
        </member>
        <member name="T:OperationsResearch.MPSosConstraint.Types">
            <summary>Container for nested types declared in the MPSosConstraint message type.</summary>
        </member>
        <member name="F:OperationsResearch.MPSosConstraint.Types.Type.Sos1Default">
            <summary>
            At most one variable in `var_index` must be non-zero.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSosConstraint.Types.Type.Sos2">
            <summary>
            At most two consecutive variables from `var_index` can be non-zero (i.e.
            for some i, var_index[i] and var_index[i+1]). See
            https://en.wikipedia.org/wiki/Special_ordered_set#Types_of_SOS
            </summary>
        </member>
        <member name="T:OperationsResearch.MPQuadraticConstraint">
            <summary>
            Quadratic constraints of the form lb &lt;= sum a_i x_i + sum b_ij x_i x_j &lt;= ub,
            where a, b, lb and ub are constants, and x are the model's variables.
            Quadratic matrices that are Positive Semi-Definite, Second-Order Cones or
            rotated Second-Order Cones are always accepted. Other forms may or may not be
            accepted depending on the underlying solver used.
            See https://scip.zib.de/doc/html/cons__quadratic_8h.php and
            https://www.gurobi.com/documentation/9.0/refman/constraints.html#subsubsection:QuadraticConstraints
            </summary>
        </member>
        <member name="F:OperationsResearch.MPQuadraticConstraint.VarIndexFieldNumber">
            <summary>Field number for the "var_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPQuadraticConstraint.VarIndex">
            <summary>
            Sparse representation of linear terms in the quadratic constraint, where
            term i is var_index[i] * coefficient[i].
            `var_index` are variable indices w.r.t the "variable" field in
            MPModelProto, and should be unique.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPQuadraticConstraint.CoefficientFieldNumber">
            <summary>Field number for the "coefficient" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPQuadraticConstraint.Coefficient">
            <summary>
            Must be finite.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPQuadraticConstraint.Qvar1IndexFieldNumber">
            <summary>Field number for the "qvar1_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPQuadraticConstraint.Qvar1Index">
            <summary>
            Sparse representation of quadratic terms in the quadratic constraint, where
            term i is qvar1_index[i] * qvar2_index[i] * qcoefficient[i].
            `qvar1_index` and `qvar2_index` are variable indices w.r.t the "variable"
            field in MPModelProto.
            `qvar1_index`, `qvar2_index` and `coefficients` must have the same size.
            If the same unordered pair (qvar1_index, qvar2_index) appears several
            times, the sum of all of the associated coefficients will be applied.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPQuadraticConstraint.Qvar2IndexFieldNumber">
            <summary>Field number for the "qvar2_index" field.</summary>
        </member>
        <member name="F:OperationsResearch.MPQuadraticConstraint.QcoefficientFieldNumber">
            <summary>Field number for the "qcoefficient" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPQuadraticConstraint.Qcoefficient">
            <summary>
            Must be finite.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPQuadraticConstraint.LowerBoundFieldNumber">
            <summary>Field number for the "lower_bound" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPQuadraticConstraint.LowerBound">
            <summary>
            lower_bound must be &lt;= upper_bound.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPQuadraticConstraint.HasLowerBound">
            <summary>Gets whether the "lower_bound" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPQuadraticConstraint.ClearLowerBound">
            <summary>Clears the value of the "lower_bound" field</summary>
        </member>
        <member name="F:OperationsResearch.MPQuadraticConstraint.UpperBoundFieldNumber">
            <summary>Field number for the "upper_bound" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPQuadraticConstraint.HasUpperBound">
            <summary>Gets whether the "upper_bound" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPQuadraticConstraint.ClearUpperBound">
            <summary>Clears the value of the "upper_bound" field</summary>
        </member>
        <member name="T:OperationsResearch.MPAbsConstraint">
            <summary>
            Sets a variable's value to the absolute value of another variable.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPAbsConstraint.VarIndexFieldNumber">
            <summary>Field number for the "var_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPAbsConstraint.VarIndex">
            <summary>
            Variable indices are relative to the "variable" field in MPModelProto.
            resultant_var = abs(var)
            </summary>
        </member>
        <member name="P:OperationsResearch.MPAbsConstraint.HasVarIndex">
            <summary>Gets whether the "var_index" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPAbsConstraint.ClearVarIndex">
            <summary>Clears the value of the "var_index" field</summary>
        </member>
        <member name="F:OperationsResearch.MPAbsConstraint.ResultantVarIndexFieldNumber">
            <summary>Field number for the "resultant_var_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPAbsConstraint.HasResultantVarIndex">
            <summary>Gets whether the "resultant_var_index" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPAbsConstraint.ClearResultantVarIndex">
            <summary>Clears the value of the "resultant_var_index" field</summary>
        </member>
        <member name="T:OperationsResearch.MPArrayConstraint">
            <summary>
            Sets a variable's value equal to a function on a set of variables.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPArrayConstraint.VarIndexFieldNumber">
            <summary>Field number for the "var_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPArrayConstraint.VarIndex">
            <summary>
            Variable indices are relative to the "variable" field in MPModelProto.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPArrayConstraint.ResultantVarIndexFieldNumber">
            <summary>Field number for the "resultant_var_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPArrayConstraint.HasResultantVarIndex">
            <summary>Gets whether the "resultant_var_index" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPArrayConstraint.ClearResultantVarIndex">
            <summary>Clears the value of the "resultant_var_index" field</summary>
        </member>
        <member name="T:OperationsResearch.MPArrayWithConstantConstraint">
            <summary>
            Sets a variable's value equal to a function on a set of variables and,
            optionally, a constant.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPArrayWithConstantConstraint.VarIndexFieldNumber">
            <summary>Field number for the "var_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPArrayWithConstantConstraint.VarIndex">
            <summary>
            Variable indices are relative to the "variable" field in MPModelProto.
            resultant_var = f(var_1, var_2, ..., constant)
            </summary>
        </member>
        <member name="F:OperationsResearch.MPArrayWithConstantConstraint.ConstantFieldNumber">
            <summary>Field number for the "constant" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPArrayWithConstantConstraint.HasConstant">
            <summary>Gets whether the "constant" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPArrayWithConstantConstraint.ClearConstant">
            <summary>Clears the value of the "constant" field</summary>
        </member>
        <member name="F:OperationsResearch.MPArrayWithConstantConstraint.ResultantVarIndexFieldNumber">
            <summary>Field number for the "resultant_var_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPArrayWithConstantConstraint.HasResultantVarIndex">
            <summary>Gets whether the "resultant_var_index" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPArrayWithConstantConstraint.ClearResultantVarIndex">
            <summary>Clears the value of the "resultant_var_index" field</summary>
        </member>
        <member name="T:OperationsResearch.MPQuadraticObjective">
            <summary>
            Quadratic part of a model's objective. Added with other objectives (such as
            linear), this creates the model's objective function to be optimized.
            Note: the linear part of the objective currently needs to be specified in the
            MPVariableProto.objective_coefficient fields. If you'd rather have a
            dedicated linear array here, talk to or-core-team@
            </summary>
        </member>
        <member name="F:OperationsResearch.MPQuadraticObjective.Qvar1IndexFieldNumber">
            <summary>Field number for the "qvar1_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPQuadraticObjective.Qvar1Index">
            <summary>
            Sparse representation of quadratic terms in the objective function, where
            term i is qvar1_index[i] * qvar2_index[i] * coefficient[i].
            `qvar1_index` and `qvar2_index` are variable indices w.r.t the "variable"
            field in MPModelProto.
            `qvar1_index`, `qvar2_index` and `coefficients` must have the same size.
            If the same unordered pair (qvar1_index, qvar2_index) appears several
            times, the sum of all of the associated coefficients will be applied.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPQuadraticObjective.Qvar2IndexFieldNumber">
            <summary>Field number for the "qvar2_index" field.</summary>
        </member>
        <member name="F:OperationsResearch.MPQuadraticObjective.CoefficientFieldNumber">
            <summary>Field number for the "coefficient" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPQuadraticObjective.Coefficient">
            <summary>
            Must be finite.
            </summary>
        </member>
        <member name="T:OperationsResearch.PartialVariableAssignment">
            <summary>
            This message encodes a partial (or full) assignment of the variables of a
            MPModelProto problem. The indices in var_index should be unique and valid
            variable indices of the associated problem.
            </summary>
        </member>
        <member name="F:OperationsResearch.PartialVariableAssignment.VarIndexFieldNumber">
            <summary>Field number for the "var_index" field.</summary>
        </member>
        <member name="F:OperationsResearch.PartialVariableAssignment.VarValueFieldNumber">
            <summary>Field number for the "var_value" field.</summary>
        </member>
        <member name="T:OperationsResearch.MPModelProto">
            <summary>
            MPModelProto contains all the information for a Linear Programming model.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.VariableFieldNumber">
            <summary>Field number for the "variable" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.Variable">
            <summary>
            All the variables appearing in the model.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.ConstraintFieldNumber">
            <summary>Field number for the "constraint" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.Constraint">
            <summary>
            All the constraints appearing in the model.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.GeneralConstraintFieldNumber">
            <summary>Field number for the "general_constraint" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.GeneralConstraint">
            <summary>
            All the general constraints appearing in the model. Note that not all
            solvers support all types of general constraints.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.MaximizeFieldNumber">
            <summary>Field number for the "maximize" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.Maximize">
            <summary>
            True if the problem is a maximization problem. Minimize by default.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.HasMaximize">
            <summary>Gets whether the "maximize" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelProto.ClearMaximize">
            <summary>Clears the value of the "maximize" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.ObjectiveOffsetFieldNumber">
            <summary>Field number for the "objective_offset" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.ObjectiveOffset">
            <summary>
            Offset for the objective function. Must be finite.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.HasObjectiveOffset">
            <summary>Gets whether the "objective_offset" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelProto.ClearObjectiveOffset">
            <summary>Clears the value of the "objective_offset" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.QuadraticObjectiveFieldNumber">
            <summary>Field number for the "quadratic_objective" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.QuadraticObjective">
            <summary>
            Optionally, a quadratic objective.
            As of 2019/06, only SCIP and Gurobi support quadratic objectives.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.Name">
            <summary>
            Name of the model.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelProto.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.SolutionHintFieldNumber">
            <summary>Field number for the "solution_hint" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.SolutionHint">
             <summary>
             Solution hint.
            
             If a feasible or almost-feasible solution to the problem is already known,
             it may be helpful to pass it to the solver so that it can be used. A solver
             that supports this feature will try to use this information to create its
             initial feasible solution.
            
             Note that it may not always be faster to give a hint like this to the
             solver. There is also no guarantee that the solver will use this hint or
             try to return a solution "close" to this assignment in case of multiple
             optimal solutions.
             </summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.AnnotationFieldNumber">
            <summary>Field number for the "annotation" field.</summary>
        </member>
        <member name="T:OperationsResearch.MPModelProto.Types">
            <summary>Container for nested types declared in the MPModelProto message type.</summary>
        </member>
        <member name="T:OperationsResearch.MPModelProto.Types.Annotation">
            <summary>
            Annotations can be freely added by users who want to attach arbitrary
            payload to the model's variables or constraints.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.Types.Annotation.TargetTypeFieldNumber">
            <summary>Field number for the "target_type" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.Types.Annotation.HasTargetType">
            <summary>Gets whether the "target_type" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelProto.Types.Annotation.ClearTargetType">
            <summary>Clears the value of the "target_type" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.Types.Annotation.TargetIndexFieldNumber">
            <summary>Field number for the "target_index" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.Types.Annotation.TargetIndex">
            <summary>
            If both `target_index` and `target_name` are set, they must point to the
            same entity.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.Types.Annotation.HasTargetIndex">
            <summary>Gets whether the "target_index" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelProto.Types.Annotation.ClearTargetIndex">
            <summary>Clears the value of the "target_index" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.Types.Annotation.TargetNameFieldNumber">
            <summary>Field number for the "target_name" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.Types.Annotation.TargetName">
            <summary>
            Alternate to index. Assumes uniqueness.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.Types.Annotation.HasTargetName">
            <summary>Gets whether the "target_name" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelProto.Types.Annotation.ClearTargetName">
            <summary>Clears the value of the "target_name" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.Types.Annotation.PayloadKeyFieldNumber">
            <summary>Field number for the "payload_key" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.Types.Annotation.PayloadKey">
            <summary>
            The payload is a (key, value) string pair. Depending on the use cases,
            one of the two may be omitted.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.Types.Annotation.HasPayloadKey">
            <summary>Gets whether the "payload_key" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelProto.Types.Annotation.ClearPayloadKey">
            <summary>Clears the value of the "payload_key" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelProto.Types.Annotation.PayloadValueFieldNumber">
            <summary>Field number for the "payload_value" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelProto.Types.Annotation.HasPayloadValue">
            <summary>Gets whether the "payload_value" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelProto.Types.Annotation.ClearPayloadValue">
            <summary>Clears the value of the "payload_value" field</summary>
        </member>
        <member name="T:OperationsResearch.MPModelProto.Types.Annotation.Types">
            <summary>Container for nested types declared in the Annotation message type.</summary>
        </member>
        <member name="T:OperationsResearch.MPModelProto.Types.Annotation.Types.TargetType">
            <summary>
            The target of an Annotation is a single entity (e.g. a variable).
            Several Annotations may apply to the same entity.
            </summary>
        </member>
        <member name="T:OperationsResearch.OptionalDouble">
            <summary>
            To support 'unspecified' double value in proto3, the simplest is to wrap
            any double value in a nested message (has_XXX works for message fields).
            </summary>
        </member>
        <member name="F:OperationsResearch.OptionalDouble.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="P:OperationsResearch.OptionalDouble.HasValue">
            <summary>Gets whether the "value" field is set</summary>
        </member>
        <member name="M:OperationsResearch.OptionalDouble.ClearValue">
            <summary>Clears the value of the "value" field</summary>
        </member>
        <member name="T:OperationsResearch.MPSolverCommonParameters">
            <summary>
            MPSolverCommonParameters holds advanced usage parameters that apply to any of
            the solvers we support.
            All of the fields in this proto can have a value of unspecified. In this
            case each inner solver will use their own safe defaults.
            Some values won't be supported by some solvers. The behavior in that case is
            not defined yet.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverCommonParameters.RelativeMipGapFieldNumber">
            <summary>Field number for the "relative_mip_gap" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolverCommonParameters.RelativeMipGap">
             <summary>
             The solver stops if the relative MIP gap reaches this value or below.
             The relative MIP gap is an upper bound of the relative distance to the
             optimum, and it is defined as:
            
               abs(best_bound - incumbent) / abs(incumbent) [Gurobi]
               abs(best_bound - incumbent) / min(abs(best_bound), abs(incumbent)) [SCIP]
            
             where "incumbent" is the objective value of the best solution found so far
             (i.e., lowest when minimizing, highest when maximizing), and "best_bound"
             is the tightest bound of the objective determined so far (i.e., highest
             when minimizing, and lowest when maximizing). The MIP Gap is sensitive to
             objective offset. If the denominator is 0 the MIP Gap is INFINITY for SCIP
             and Gurobi. Of note, "incumbent" and "best bound" are called "primal bound"
             and "dual bound" in SCIP, respectively.
             Ask or-core-team@ for other solvers.
             </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverCommonParameters.PrimalToleranceFieldNumber">
            <summary>Field number for the "primal_tolerance" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolverCommonParameters.PrimalTolerance">
            <summary>
            Tolerance for primal feasibility of basic solutions: this is the maximum
            allowed error in constraint satisfiability.
            For SCIP this includes integrality constraints. For Gurobi it does not, you
            need to set the custom parameter IntFeasTol.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverCommonParameters.DualToleranceFieldNumber">
            <summary>Field number for the "dual_tolerance" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolverCommonParameters.DualTolerance">
            <summary>
            Tolerance for dual feasibility.
            For SCIP and Gurobi this is the feasibility tolerance for reduced costs in
            LP solution: reduced costs must all be smaller than this value in the
            improving direction in order for a model to be declared optimal.
            Not supported for other solvers.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverCommonParameters.LpAlgorithmFieldNumber">
            <summary>Field number for the "lp_algorithm" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolverCommonParameters.LpAlgorithm">
            <summary>
            Algorithm to solve linear programs.
            Ask or-core-team@ if you want to know what this does exactly.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPSolverCommonParameters.HasLpAlgorithm">
            <summary>Gets whether the "lp_algorithm" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPSolverCommonParameters.ClearLpAlgorithm">
            <summary>Clears the value of the "lp_algorithm" field</summary>
        </member>
        <member name="F:OperationsResearch.MPSolverCommonParameters.PresolveFieldNumber">
            <summary>Field number for the "presolve" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolverCommonParameters.Presolve">
            <summary>
            Gurobi and SCIP enable presolve by default.
            Ask or-core-team@ for other solvers.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPSolverCommonParameters.HasPresolve">
            <summary>Gets whether the "presolve" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPSolverCommonParameters.ClearPresolve">
            <summary>Clears the value of the "presolve" field</summary>
        </member>
        <member name="F:OperationsResearch.MPSolverCommonParameters.ScalingFieldNumber">
            <summary>Field number for the "scaling" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolverCommonParameters.Scaling">
            <summary>
            Enable automatic scaling of matrix coefficients and objective. Available
            for Gurobi and GLOP.
            Ask or-core-team@ if you want more details.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPSolverCommonParameters.HasScaling">
            <summary>Gets whether the "scaling" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPSolverCommonParameters.ClearScaling">
            <summary>Clears the value of the "scaling" field</summary>
        </member>
        <member name="T:OperationsResearch.MPSolverCommonParameters.Types">
            <summary>Container for nested types declared in the MPSolverCommonParameters message type.</summary>
        </member>
        <member name="F:OperationsResearch.MPSolverCommonParameters.Types.LPAlgorithmValues.LpAlgoDual">
            <summary>
            Dual simplex.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverCommonParameters.Types.LPAlgorithmValues.LpAlgoPrimal">
            <summary>
            Primal simplex.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolverCommonParameters.Types.LPAlgorithmValues.LpAlgoBarrier">
            <summary>
            Barrier algorithm.
            </summary>
        </member>
        <member name="T:OperationsResearch.MPModelDeltaProto">
            <summary>
            Encodes a full MPModelProto by way of referencing to a "baseline"
            MPModelProto stored in a file, and a "delta" to apply to this model.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelDeltaProto.BaselineModelFilePathFieldNumber">
            <summary>Field number for the "baseline_model_file_path" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelDeltaProto.HasBaselineModelFilePath">
            <summary>Gets whether the "baseline_model_file_path" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelDeltaProto.ClearBaselineModelFilePath">
            <summary>Clears the value of the "baseline_model_file_path" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelDeltaProto.VariableOverridesFieldNumber">
            <summary>Field number for the "variable_overrides" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelDeltaProto.VariableOverrides">
            <summary>
            The variable protos listed here will override (via MergeFrom()) the ones
            in the baseline model: you only need to specify the fields that change.
            To add a new variable, add it with a new variable index (variable indices
            still need to span a dense integer interval).
            You can't "delete" a variable but you can "neutralize" it by fixing its
            value, setting its objective coefficient to zero, and by nullifying all
            the terms involving it in the constraints.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelDeltaProto.ConstraintOverridesFieldNumber">
            <summary>Field number for the "constraint_overrides" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelDeltaProto.ConstraintOverrides">
            <summary>
            Constraints can be changed (or added) in the same way as variables, see
            above. It's mostly like applying MergeFrom(), except that:
            - the "var_index" and "coefficient" fields will be overridden like a map:
              if a key pre-exists, we overwrite its value, otherwise we add it.
            - if you set the lower bound to -inf and the upper bound to +inf, thus
              effectively neutralizing the constraint, the solver will implicitly
              remove all of the constraint's terms.
            </summary>
        </member>
        <member name="T:OperationsResearch.MPModelRequest">
            <summary>
            Next id: 18.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.ModelFieldNumber">
            <summary>Field number for the "model" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelRequest.Model">
            <summary>
            The model to be optimized by the server.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.SolverTypeFieldNumber">
            <summary>Field number for the "solver_type" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelRequest.HasSolverType">
            <summary>Gets whether the "solver_type" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelRequest.ClearSolverType">
            <summary>Clears the value of the "solver_type" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.SolverTimeLimitSecondsFieldNumber">
            <summary>Field number for the "solver_time_limit_seconds" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelRequest.SolverTimeLimitSeconds">
             <summary>
             Maximum time to be spent by the solver to solve 'model'. If the server is
             busy and the RPC's deadline_left is less than this, it will immediately
             give up and return an error, without even trying to solve.
            
             The client can use this to have a guarantee on how much time the
             solver will spend on the problem (unless it finds and proves
             an optimal solution more quickly).
            
             If not specified, the time limit on the solver is the RPC's deadline_left.
             </summary>
        </member>
        <member name="P:OperationsResearch.MPModelRequest.HasSolverTimeLimitSeconds">
            <summary>Gets whether the "solver_time_limit_seconds" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelRequest.ClearSolverTimeLimitSeconds">
            <summary>Clears the value of the "solver_time_limit_seconds" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.EnableInternalSolverOutputFieldNumber">
            <summary>Field number for the "enable_internal_solver_output" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelRequest.EnableInternalSolverOutput">
            <summary>
            If this is set, then EnableOutput() will be set on the internal MPSolver
            that solves the model.
            WARNING: if you set this on a request to prod servers, it will be rejected
            and yield the RPC Application Error code MPSOLVER_SOLVER_TYPE_UNAVAILABLE.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPModelRequest.HasEnableInternalSolverOutput">
            <summary>Gets whether the "enable_internal_solver_output" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelRequest.ClearEnableInternalSolverOutput">
            <summary>Clears the value of the "enable_internal_solver_output" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.SolverSpecificParametersFieldNumber">
            <summary>Field number for the "solver_specific_parameters" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelRequest.SolverSpecificParameters">
             <summary>
             Advanced usage. Solver-specific parameters in the solver's own format,
             different for each solver. For example, if you use SCIP and you want to
             stop the solve earlier than the time limit if it reached a solution that is
             at most 1% away from the optimal, you can set this to "limits/gap=0.01".
            
             Note however that there is no "security" mechanism in place so it is up to
             the client to make sure that the given options don't make the solve
             non thread safe or use up too much memory for instance.
            
             If the option format is not understood by the solver, the request will be
             rejected and yield an RPC Application error with code
             MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS, unless you have set
             ignore_solver_specific_parameters_failure=true (in which case they are
             simply ignored).
             </summary>
        </member>
        <member name="P:OperationsResearch.MPModelRequest.HasSolverSpecificParameters">
            <summary>Gets whether the "solver_specific_parameters" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelRequest.ClearSolverSpecificParameters">
            <summary>Clears the value of the "solver_specific_parameters" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.IgnoreSolverSpecificParametersFailureFieldNumber">
            <summary>Field number for the "ignore_solver_specific_parameters_failure" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelRequest.HasIgnoreSolverSpecificParametersFailure">
            <summary>Gets whether the "ignore_solver_specific_parameters_failure" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelRequest.ClearIgnoreSolverSpecificParametersFailure">
            <summary>Clears the value of the "ignore_solver_specific_parameters_failure" field</summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.ModelDeltaFieldNumber">
            <summary>Field number for the "model_delta" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelRequest.ModelDelta">
            <summary>
            Advanced usage: model "delta". If used, "model" must be unset. See the
            definition of MPModelDeltaProto.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.PopulateAdditionalSolutionsUpToFieldNumber">
            <summary>Field number for the "populate_additional_solutions_up_to" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPModelRequest.PopulateAdditionalSolutionsUpTo">
            <summary>
            Controls the recovery of additional solutions, if any, saved by the
            underlying solver back in the MPSolutionResponse.additional_solutions.
            The repeated field will be length
               min(populate_addition_solutions_up_to,
                   #additional_solutions_available_in_underlying_solver)
            These additional solutions may have a worse objective than the main
            solution returned in the response.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPModelRequest.HasPopulateAdditionalSolutionsUpTo">
            <summary>Gets whether the "populate_additional_solutions_up_to" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPModelRequest.ClearPopulateAdditionalSolutionsUpTo">
            <summary>Clears the value of the "populate_additional_solutions_up_to" field</summary>
        </member>
        <member name="T:OperationsResearch.MPModelRequest.Types">
            <summary>Container for nested types declared in the MPModelRequest message type.</summary>
        </member>
        <member name="T:OperationsResearch.MPModelRequest.Types.SolverType">
            <summary>
            The solver type, which will select a specific implementation, and will also
            impact the interpretation of the model (i.e. are we solving the problem
            as a mixed integer program or are we relaxing it as a continuous linear
            program?).
            This must remain consistent with MPSolver::OptimizationProblemType.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.Types.SolverType.GlopLinearProgramming">
            <summary>
            Recommended default for LP models.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.Types.SolverType.GurobiLinearProgramming">
            <summary>
            Commercial, needs a valid license.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.Types.SolverType.XpressLinearProgramming">
            <summary>
            Commercial, needs a valid license. NOLINT
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.Types.SolverType.CplexLinearProgramming">
            <summary>
            Commercial, needs a valid license. NOLINT
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.Types.SolverType.ScipMixedIntegerProgramming">
            <summary>
            Recommended default for MIP models.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.Types.SolverType.GurobiMixedIntegerProgramming">
            <summary>
            Commercial, needs a valid license.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.Types.SolverType.XpressMixedIntegerProgramming">
            <summary>
            Commercial, needs a valid license. NOLINT
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.Types.SolverType.CplexMixedIntegerProgramming">
            <summary>
            Commercial, needs a valid license. NOLINT
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.Types.SolverType.SatIntegerProgramming">
            <summary>
            WARNING: This solver will currently interpret all variables as integer,
            so any solution you get will be valid, but the optimal might be far away
            for the real one (when you authorise non-integer value for continuous
            variables).
            </summary>
        </member>
        <member name="F:OperationsResearch.MPModelRequest.Types.SolverType.PdlpLinearProgramming">
            <summary>
            In-house linear programming solver based on the primal-dual hybrid
            gradient method. Sometimes faster than Glop for medium-size problems and
            scales to much larger problems than Glop.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolution.ObjectiveValueFieldNumber">
            <summary>Field number for the "objective_value" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolution.HasObjectiveValue">
            <summary>Gets whether the "objective_value" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPSolution.ClearObjectiveValue">
            <summary>Clears the value of the "objective_value" field</summary>
        </member>
        <member name="F:OperationsResearch.MPSolution.VariableValueFieldNumber">
            <summary>Field number for the "variable_value" field.</summary>
        </member>
        <member name="F:OperationsResearch.MPSolveInfo.SolveWallTimeSecondsFieldNumber">
            <summary>Field number for the "solve_wall_time_seconds" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolveInfo.SolveWallTimeSeconds">
            <summary>
            How much wall time (resp. user time) elapsed during the Solve() of the
            underlying solver library. "wall" time and "user" time are to be
            interpreted like for the "time" command in bash (see "help time").
            In particular, "user time" is CPU time and can be greater than wall time
            when using several threads.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPSolveInfo.HasSolveWallTimeSeconds">
            <summary>Gets whether the "solve_wall_time_seconds" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPSolveInfo.ClearSolveWallTimeSeconds">
            <summary>Clears the value of the "solve_wall_time_seconds" field</summary>
        </member>
        <member name="F:OperationsResearch.MPSolveInfo.SolveUserTimeSecondsFieldNumber">
            <summary>Field number for the "solve_user_time_seconds" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolveInfo.HasSolveUserTimeSeconds">
            <summary>Gets whether the "solve_user_time_seconds" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPSolveInfo.ClearSolveUserTimeSeconds">
            <summary>Clears the value of the "solve_user_time_seconds" field</summary>
        </member>
        <member name="T:OperationsResearch.MPSolutionResponse">
            <summary>
            Next id: 12.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolutionResponse.StatusFieldNumber">
            <summary>Field number for the "status" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.Status">
            <summary>
            Result of the optimization.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.HasStatus">
            <summary>Gets whether the "status" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPSolutionResponse.ClearStatus">
            <summary>Clears the value of the "status" field</summary>
        </member>
        <member name="F:OperationsResearch.MPSolutionResponse.StatusStrFieldNumber">
            <summary>Field number for the "status_str" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.StatusStr">
            <summary>
            Human-readable string giving more details about the status. For example,
            when the status is MPSOLVER_INVALID_MODE, this can hold a description of
            why the model is invalid.
            This isn't always filled: don't depend on its value or even its presence.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.HasStatusStr">
            <summary>Gets whether the "status_str" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPSolutionResponse.ClearStatusStr">
            <summary>Clears the value of the "status_str" field</summary>
        </member>
        <member name="F:OperationsResearch.MPSolutionResponse.ObjectiveValueFieldNumber">
            <summary>Field number for the "objective_value" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.ObjectiveValue">
            <summary>
            Objective value corresponding to the "variable_value" below, taking into
            account the source "objective_offset" and "objective_coefficient".
            This is set iff 'status' is OPTIMAL or FEASIBLE.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.HasObjectiveValue">
            <summary>Gets whether the "objective_value" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPSolutionResponse.ClearObjectiveValue">
            <summary>Clears the value of the "objective_value" field</summary>
        </member>
        <member name="F:OperationsResearch.MPSolutionResponse.BestObjectiveBoundFieldNumber">
            <summary>Field number for the "best_objective_bound" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.BestObjectiveBound">
            <summary>
            This field is only filled for MIP problems. For a minimization problem,
            this is a lower bound on the optimal objective value. For a maximization
            problem, it is an upper bound. It is only filled if the status is OPTIMAL
            or FEASIBLE. In the former case, best_objective_bound should be equal to
            objective_value (modulo numerical errors).
            </summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.HasBestObjectiveBound">
            <summary>Gets whether the "best_objective_bound" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPSolutionResponse.ClearBestObjectiveBound">
            <summary>Clears the value of the "best_objective_bound" field</summary>
        </member>
        <member name="F:OperationsResearch.MPSolutionResponse.VariableValueFieldNumber">
            <summary>Field number for the "variable_value" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.VariableValue">
            <summary>
            Variable values in the same order as the MPModelProto::variable field.
            This is a dense representation. These are set iff 'status' is OPTIMAL or
            FEASIBLE.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolutionResponse.SolveInfoFieldNumber">
            <summary>Field number for the "solve_info" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.SolveInfo">
            <summary>
            Contains extra information about the solve, populated if the underlying
            solver (and its interface) supports it. As of 2021/07/19 this is supported
            by SCIP and Gurobi proto solves.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolutionResponse.SolverSpecificInfoFieldNumber">
            <summary>Field number for the "solver_specific_info" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.SolverSpecificInfo">
            <summary>
            Opaque solver-specific information.
            For the PDLP solver, this is a serialized pdlp::SolveLog proto.
            </summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.HasSolverSpecificInfo">
            <summary>Gets whether the "solver_specific_info" field is set</summary>
        </member>
        <member name="M:OperationsResearch.MPSolutionResponse.ClearSolverSpecificInfo">
            <summary>Clears the value of the "solver_specific_info" field</summary>
        </member>
        <member name="F:OperationsResearch.MPSolutionResponse.DualValueFieldNumber">
            <summary>Field number for the "dual_value" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.DualValue">
            <summary>
            [Advanced usage.]
            Values of the dual variables values in the same order as the
            MPModelProto::constraint field. This is a dense representation.
            These are not set if the problem was solved with a MIP solver (even if
            it is actually a linear program).
            These are set iff 'status' is OPTIMAL or FEASIBLE.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolutionResponse.ReducedCostFieldNumber">
            <summary>Field number for the "reduced_cost" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.ReducedCost">
            <summary>
            [Advanced usage.]
            Values of the reduced cost of the variables in the same order as the
            MPModelProto::variable. This is a dense representation.
            These are not set if the problem was solved with a MIP solver (even if it
            is actually a linear program).
            These are set iff 'status' is OPTIMAL or FEASIBLE.
            </summary>
        </member>
        <member name="F:OperationsResearch.MPSolutionResponse.AdditionalSolutionsFieldNumber">
            <summary>Field number for the "additional_solutions" field.</summary>
        </member>
        <member name="P:OperationsResearch.MPSolutionResponse.AdditionalSolutions">
            <summary>
            [Advanced usage.]
            If `MPModelRequest.populate_additional_solutions_up_to` > 0, up to that
            number of additional solutions may be populated here, if available. These
            additional solutions are different than the main solution described by the
            above fields `objective_value` and `variable_value`.
            </summary>
        </member>
        <member name="T:OperationsResearch.RoutingIlsReflection">
            <summary>Holder for reflection information generated from ortools/constraint_solver/routing_ils.proto</summary>
        </member>
        <member name="P:OperationsResearch.RoutingIlsReflection.Descriptor">
            <summary>File descriptor for ortools/constraint_solver/routing_ils.proto</summary>
        </member>
        <member name="T:OperationsResearch.RuinStrategy">
            <summary>
            Ruin strategies, used in perturbation based on ruin and recreate approaches.
            </summary>
        </member>
        <member name="T:OperationsResearch.RuinStrategy.Types">
            <summary>Container for nested types declared in the RuinStrategy message type.</summary>
        </member>
        <member name="F:OperationsResearch.RuinStrategy.Types.Value.Unset">
            <summary>
            Unspecified value.
            </summary>
        </member>
        <member name="F:OperationsResearch.RuinStrategy.Types.Value.SpatiallyCloseRoutesRemoval">
            <summary>
            Removes a number of spatially close routes.
            </summary>
        </member>
        <member name="T:OperationsResearch.RuinRecreateParameters">
            <summary>
            Parameters to configure a perturbation based on a ruin and recreate approach.
            </summary>
        </member>
        <member name="F:OperationsResearch.RuinRecreateParameters.RuinStrategyFieldNumber">
            <summary>Field number for the "ruin_strategy" field.</summary>
        </member>
        <member name="P:OperationsResearch.RuinRecreateParameters.RuinStrategy">
            <summary>
            Strategy defining how a reference solution is ruined.
            </summary>
        </member>
        <member name="F:OperationsResearch.RuinRecreateParameters.RecreateStrategyFieldNumber">
            <summary>Field number for the "recreate_strategy" field.</summary>
        </member>
        <member name="P:OperationsResearch.RuinRecreateParameters.RecreateStrategy">
            <summary>
            Strategy defining how a reference solution is recreated.
            </summary>
        </member>
        <member name="F:OperationsResearch.RuinRecreateParameters.NumRuinedRoutesFieldNumber">
            <summary>Field number for the "num_ruined_routes" field.</summary>
        </member>
        <member name="P:OperationsResearch.RuinRecreateParameters.NumRuinedRoutes">
            <summary>
            Number of routes removed during a ruin application defined on routes.
            </summary>
        </member>
        <member name="T:OperationsResearch.PerturbationStrategy">
            <summary>
            Defines how a reference solution is perturbed.
            </summary>
        </member>
        <member name="T:OperationsResearch.PerturbationStrategy.Types">
            <summary>Container for nested types declared in the PerturbationStrategy message type.</summary>
        </member>
        <member name="F:OperationsResearch.PerturbationStrategy.Types.Value.Unset">
            <summary>
            Unspecified value.
            </summary>
        </member>
        <member name="F:OperationsResearch.PerturbationStrategy.Types.Value.RuinAndRecreate">
            <summary>
            Performs a perturbation in a ruin and recreate fashion.
            </summary>
        </member>
        <member name="T:OperationsResearch.AcceptanceStrategy">
            <summary>
            Determines when a neighbor solution, obtained by the application of a
            perturbation and improvement step to a reference solution, is used to
            replace the reference solution.
            </summary>
        </member>
        <member name="T:OperationsResearch.AcceptanceStrategy.Types">
            <summary>Container for nested types declared in the AcceptanceStrategy message type.</summary>
        </member>
        <member name="F:OperationsResearch.AcceptanceStrategy.Types.Value.Unset">
            <summary>
            Unspecified value.
            </summary>
        </member>
        <member name="F:OperationsResearch.AcceptanceStrategy.Types.Value.GreedyDescent">
            <summary>
            Accept only solutions that are improving with respect to the reference
            one.
            </summary>
        </member>
        <member name="T:OperationsResearch.IteratedLocalSearchParameters">
            <summary>
            Specifies the behavior of a search based on ILS.
            </summary>
        </member>
        <member name="F:OperationsResearch.IteratedLocalSearchParameters.PerturbationStrategyFieldNumber">
            <summary>Field number for the "perturbation_strategy" field.</summary>
        </member>
        <member name="P:OperationsResearch.IteratedLocalSearchParameters.PerturbationStrategy">
            <summary>
            Determines how a reference solution S is perturbed to obtain a neighbor
            solution S'.
            </summary>
        </member>
        <member name="F:OperationsResearch.IteratedLocalSearchParameters.RuinRecreateParametersFieldNumber">
            <summary>Field number for the "ruin_recreate_parameters" field.</summary>
        </member>
        <member name="P:OperationsResearch.IteratedLocalSearchParameters.RuinRecreateParameters">
            <summary>
            Parameters to customize a ruin and recreate perturbation.
            </summary>
        </member>
        <member name="F:OperationsResearch.IteratedLocalSearchParameters.ImprovePerturbedSolutionFieldNumber">
            <summary>Field number for the "improve_perturbed_solution" field.</summary>
        </member>
        <member name="P:OperationsResearch.IteratedLocalSearchParameters.ImprovePerturbedSolution">
            <summary>
            Determines whether solution S', obtained from the perturbation, should be
            optimized with a local search application.
            </summary>
        </member>
        <member name="F:OperationsResearch.IteratedLocalSearchParameters.AcceptanceStrategyFieldNumber">
            <summary>Field number for the "acceptance_strategy" field.</summary>
        </member>
        <member name="P:OperationsResearch.IteratedLocalSearchParameters.AcceptanceStrategy">
            <summary>
            Determines when the neighbor solution S', possibly improved if
            `improve_perturbed_solution` is true, replaces the reference solution S.
            </summary>
        </member>
    </members>
</doc>
